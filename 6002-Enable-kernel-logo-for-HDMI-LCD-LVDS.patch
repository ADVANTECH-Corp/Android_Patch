diff -ruNp kernel_imx/arch/arm/boot/dts/imx6qdl-advantech.dtsi kernel_imx-hdmi-lcd-lvds/arch/arm/boot/dts/imx6qdl-advantech.dtsi
--- kernel_imx/arch/arm/boot/dts/imx6qdl-advantech.dtsi	2018-03-28 09:57:50.458692112 +0800
+++ kernel_imx-hdmi-lcd-lvds/arch/arm/boot/dts/imx6qdl-advantech.dtsi	2018-03-28 14:02:30.358429223 +0800
@@ -109,7 +109,8 @@
 		status = "disabled";
 	};
 
-	lcd: lcd@0 {
+/*	lcd: lcd@0 {*/
+mxclcd0:lcd@0 {
 		compatible = "fsl,lcd";
 		ipu_id = <0>;
 		disp_id = <0>;
@@ -972,8 +973,20 @@
 		status = "okay";
 
 		display-timings {
-			native-mode = <&timing00>;
-			timing00: g070vw01v0 {
+			native-mode = <&timing0>;
+		timing0: Raise3D1024x600 {
+			clock-frequency = <51200000>;
+			hactive = <1024>;
+			vactive = <600>;
+			hback-porch = <96>;
+			hfront-porch = <24>;
+			vback-porch = <3>;
+			vfront-porch = <10>;
+			hsync-len = <72>;
+			vsync-len = <7>;
+		};
+/*
+			timing0: g070vw01v0 {
 				clock-frequency = <29500000>;
 				hactive = <800>;
 				vactive = <480>;
@@ -984,9 +997,8 @@
 				hsync-len = <72>;
 				vsync-len = <7>;
 			};
-
 			//SI Test panel
-			timing10: g150xgel04 {
+			timing0: g150xgel04 {
 				clock-frequency = <63500000>;
 				hactive = <1024>;
 				vactive = <768>;
@@ -998,7 +1010,7 @@
 				vsync-len = <4>;
 			};
 			//Dual channel panel
-			timing20: g190eg01v1 {
+			timing0: g190eg01v1 {
 				clock-frequency = <109000000>;
 				hactive = <1280>;
 				vactive = <1024>;
@@ -1010,7 +1022,7 @@
 				vsync-len = <7>;
 			};
 			//Dual channel panel 
-			timing30: g215hvn0 {
+			timing0: g215hvn0 {
 				clock-frequency = <170000000>;
 				hactive = <1920>;
 				vactive = <1080>;
@@ -1021,18 +1033,7 @@
 				hsync-len = <60>;
 				vsync-len = <7>;
 			};
-
-			timing40:g150xgel05 {
-				clock-frequency = <65000000>;
-				hactive = <1024>;
-				vactive = <768>;
-				hback-porch = <220>;
-				hfront-porch = <40>;
-				vback-porch = <21>;
-				vfront-porch = <7>;
-				hsync-len = <60>;
-				vsync-len = <10>;
-			};
+*/
 		};
 	};
 
@@ -1044,8 +1045,8 @@
 		status = "okay";
 
 		display-timings {
-			native-mode = <&timing01>;
-			timing01: g070vw01v0 {
+			native-mode = <&timing1>;
+			timing1: g070vw01v0 {
 				clock-frequency = <29500000>;
 				hactive = <800>;
 				vactive = <480>;
@@ -1056,9 +1057,9 @@
 				hsync-len = <72>;
 				vsync-len = <7>;
 			};
-
+/*
 			//SI Test panel
-			timing11: g150xgel04 {
+			timing1: g150xgel04 {
 				clock-frequency = <63500000>;
 				hactive = <1024>;
 				vactive = <768>;
@@ -1069,18 +1070,7 @@
 				hsync-len = <104>;
 				vsync-len = <4>;
 			};
-			
-			timing21:g150xgel05 {
-				clock-frequency = <65000000>;
-				hactive = <1024>;
-				vactive = <768>;
-				hback-porch = <220>;
-				hfront-porch = <40>;
-				vback-porch = <21>;
-				vfront-porch = <7>;
-				hsync-len = <60>;
-				vsync-len = <10>;
-			};
+*/
 		};
 	};
 };
diff -ruNp kernel_imx/arch/arm/boot/dts/imx6q-rsb4411-a1.dts kernel_imx-hdmi-lcd-lvds/arch/arm/boot/dts/imx6q-rsb4411-a1.dts
--- kernel_imx/arch/arm/boot/dts/imx6q-rsb4411-a1.dts	2017-07-10 15:44:12.000000000 +0800
+++ kernel_imx-hdmi-lcd-lvds/arch/arm/boot/dts/imx6q-rsb4411-a1.dts	2018-03-28 14:14:32.002416299 +0800
@@ -449,3 +449,85 @@
         status = "okay";
 };
 
+//HDMI
+&mxcfb1 {
+	compatible = "fsl,mxc_sdc_fb";
+	disp_dev = "hdmi";
+	interface_pix_fmt = "RGB24";
+	default_bpp = <32>;
+	int_clk = <0>;
+	late_init = <1>;
+	fb_base = <0x27800000>; 
+	fb_size = <0x01800000>; 
+	status = "okay";
+};
+
+&hdmi_core {
+	ipu_id = <0>;
+	disp_id = <0>;
+	status = "okay";
+};
+ 
+&ipu1 {
+	bypass_reset = <1>;
+	status = "okay";
+};
+
+//LVDS
+/*
+&mxcfb1 {
+	compatible = "fsl,mxc_sdc_fb";
+	disp_dev = "ldb";
+	interface_pix_fmt = "RGB24";
+	default_bpp = <32>;
+	int_clk = <0>;
+	late_init = <1>;
+	fb_base = <0x27800000>;  
+	fb_size = <0x01800000>;  
+	status = "okay";
+};
+
+&ldb {
+	lvds-channel@0 {
+		primary;
+		crtc = "ipu1-di0";
+	status = "okay";
+	};
+
+	lvds-channel@1 {
+		status = "disabled";
+	};
+};
+
+&ipu1 {
+	bypass_reset = <1>;
+	status = "okay";
+};
+*/
+
+//LCD(VGA)
+/*
+&mxcfb1 {
+	compatible = "fsl,mxc_sdc_fb";
+	disp_dev = "lcd";
+	interface_pix_fmt = "RGB565";
+	mode_str ="1024x768M@60";
+	default_bpp = <32>;
+	int_clk = <0>;
+	late_init = <1>;
+	fb_base = <0x27800000>;  
+	fb_size = <0x01800000>;  
+	status = "okay";
+};
+
+&mxclcd0 {
+	ipu_id = <0>;
+	disp_id = <0>;
+	status = "okay";
+};
+
+&ipu1 {
+	bypass_reset = <1>;
+	status = "okay";
+};
+*/
diff -ruNp kernel_imx/arch/arm/configs/imx_v7_adv_android_defconfig kernel_imx-hdmi-lcd-lvds/arch/arm/configs/imx_v7_adv_android_defconfig
--- kernel_imx/arch/arm/configs/imx_v7_adv_android_defconfig	2017-08-11 09:35:35.000000000 +0800
+++ kernel_imx-hdmi-lcd-lvds/arch/arm/configs/imx_v7_adv_android_defconfig	2018-03-28 14:14:59.946415799 +0800
@@ -26,6 +26,13 @@ CONFIG_ARCH_ADVANTECH=y
 CONFIG_SOC_IMX50=y
 CONFIG_SOC_IMX53=y
 CONFIG_SOC_IMX6Q=y
+CONFIG_MX6_CLK_FOR_BOOTUI_TRANS=y
+CONFIG_MX6_CLK_FOR_BOOTUI_TRANS_HDMI_IPU1_DI0=y
+# CONFIG_MX6_CLK_FOR_BOOTUI_TRANS_HDMI_IPU2_DI0 is not set
+# CONFIG_MX6_CLK_FOR_BOOTUI_TRANS_LCD_IPU1_DI0 is not set
+# CONFIG_MX6_CLK_FOR_BOOTUI_TRANS_LVDS_IPU1_DI0 is not set
+# CONFIG_MX6_CLK_FOR_BOOTUI_TRANS_LVDS_IPU1_DI1 is not set
+# CONFIG_MX6_CLK_FOR_BOOTUI_TRANS_LVDS_IPU2_DI1 is not set
 CONFIG_SOC_IMX6SL=y
 CONFIG_SOC_IMX6SX=y
 CONFIG_SOC_VF610=y
@@ -402,9 +409,6 @@ CONFIG_FB_MXC_CH7055=y
 CONFIG_LCD_L4F00242T03=m
 CONFIG_LCD_PLATFORM=m
 CONFIG_BACKLIGHT_PWM=y
-CONFIG_FRAMEBUFFER_CONSOLE=m
-CONFIG_FRAMEBUFFER_CONSOLE_DETECT_PRIMARY=y
-CONFIG_LOGO=y
 CONFIG_SOUND=y
 CONFIG_SND=y
 CONFIG_SND_USB_AUDIO=y
@@ -632,9 +636,6 @@ CONFIG_CRYPTO_DEV_FSL_CAAM_SECVIO=y
 CONFIG_CRC_T10DIF=y
 CONFIG_CRC7=y
 CONFIG_LIBCRC32C=y
-CONFIG_FONTS=y
-CONFIG_FONT_8x8=y
-CONFIG_FONT_8x16=y
 
 CONFIG_ARM_CRYPTO=y
 CONFIG_PROFILING=y
diff -ruNp kernel_imx/arch/arm/mach-imx/clk-imx6q.c kernel_imx-hdmi-lcd-lvds/arch/arm/mach-imx/clk-imx6q.c
--- kernel_imx/arch/arm/mach-imx/clk-imx6q.c	2017-05-23 10:50:55.000000000 +0800
+++ kernel_imx-hdmi-lcd-lvds/arch/arm/mach-imx/clk-imx6q.c	2018-03-27 14:20:44.879956881 +0800
@@ -302,7 +302,11 @@ static void init_ldb_clks(struct device_
 	ldb_di0_sel[2] = ldb_di0_sel[3] | 4;	/* Change the upper mux while lower mux is selected. */
 	ldb_di1_sel[1] = ldb_di1_sel[0] | 4;
 	ldb_di1_sel[2] = ldb_di1_sel[3] | 4;
-
+#if defined(CONFIG_MX6_CLK_FOR_BOOTUI_TRANS_LVDS_IPU1_DI0) || \
+	defined(CONFIG_MX6_CLK_FOR_BOOTUI_TRANS_LVDS_IPU1_DI1) || \
+	defined(CONFIG_MX6_CLK_FOR_BOOTUI_TRANS_LVDS_IPU2_DI1)
+	return;
+#else
 	mmdc_ch1_handshake(false);
 	mmdc_ch1_disable();
 
@@ -315,10 +319,14 @@ static void init_ldb_clks(struct device_
 
 	mmdc_ch1_reenable();
 	mmdc_ch1_handshake(true);
+#endif
 }
 
 static void disable_anatop_clocks(void)
 {
+#ifdef CONFIG_MX6_CLK_FOR_BOOTUI_TRANS
+	return;
+#else
 	u32 reg;
 
 	/* Make sure PFDs are disabled at boot. */
@@ -340,6 +348,7 @@ static void disable_anatop_clocks(void)
 	reg = readl_relaxed(anatop_base + 0xa0);
 	reg &= ~(1 << 13);
 	writel_relaxed(reg, anatop_base + 0xa0);
+#endif
 }
 
 static void __init imx6q_clocks_init(struct device_node *ccm_node)
@@ -795,10 +804,40 @@ static void __init imx6q_clocks_init(str
 	imx_clk_set_parent(clk[IMX6QDL_CLK_IPU1_DI1_PRE_SEL], clk[IMX6QDL_CLK_PLL5_VIDEO_DIV]);
 	imx_clk_set_parent(clk[IMX6QDL_CLK_IPU2_DI0_PRE_SEL], clk[IMX6QDL_CLK_PLL5_VIDEO_DIV]);
 	imx_clk_set_parent(clk[IMX6QDL_CLK_IPU2_DI1_PRE_SEL], clk[IMX6QDL_CLK_PLL5_VIDEO_DIV]);
+#ifdef CONFIG_MX6_CLK_FOR_BOOTUI_TRANS
+#if defined(CONFIG_MX6_CLK_FOR_BOOTUI_TRANS_LCD_IPU1_DI0)
+	imx_clk_set_parent(clk[IMX6QDL_CLK_IPU1_DI0_SEL], clk[IMX6QDL_CLK_IPU1_DI0_PRE]);
+	imx_clk_set_parent(clk[IMX6QDL_CLK_IPU1_DI1_SEL], clk[IMX6QDL_CLK_IPU1_DI1_PRE]);
+	imx_clk_set_parent(clk[IMX6QDL_CLK_IPU2_DI0_SEL], clk[IMX6QDL_CLK_IPU2_DI0_PRE]);
+	imx_clk_set_parent(clk[IMX6QDL_CLK_IPU2_DI1_SEL], clk[IMX6QDL_CLK_IPU2_DI1_PRE]);
+#endif
+
+#ifdef CONFIG_MX6_CLK_FOR_BOOTUI_TRANS_LVDS_IPU1_DI0
+	imx_clk_set_parent(clk[IMX6QDL_CLK_IPU1_DI0_SEL], clk[IMX6QDL_CLK_LDB_DI0]);
+	imx_clk_set_parent(clk[IMX6QDL_CLK_IPU1_DI1_SEL], clk[IMX6QDL_CLK_IPU1_DI1_PRE]);
+	imx_clk_set_parent(clk[IMX6QDL_CLK_IPU2_DI0_SEL], clk[IMX6QDL_CLK_IPU2_DI0_PRE]);
+	imx_clk_set_parent(clk[IMX6QDL_CLK_IPU2_DI1_SEL], clk[IMX6QDL_CLK_IPU2_DI1_PRE]);
+#endif
+
+#ifdef CONFIG_MX6_CLK_FOR_BOOTUI_TRANS_LVDS_IPU1_DI1
+	imx_clk_set_parent(clk[IMX6QDL_CLK_IPU1_DI0_SEL], clk[IMX6QDL_CLK_IPU1_DI0_PRE]);
+	imx_clk_set_parent(clk[IMX6QDL_CLK_IPU1_DI1_SEL], clk[IMX6QDL_CLK_LDB_DI1]);
+	imx_clk_set_parent(clk[IMX6QDL_CLK_IPU2_DI0_SEL], clk[IMX6QDL_CLK_IPU2_DI0_PRE]);
+	imx_clk_set_parent(clk[IMX6QDL_CLK_IPU2_DI1_SEL], clk[IMX6QDL_CLK_IPU2_DI1_PRE]);
+#endif
+
+#ifdef CONFIG_MX6_CLK_FOR_BOOTUI_TRANS_LVDS_IPU2_DI1
+	imx_clk_set_parent(clk[IMX6QDL_CLK_IPU1_DI0_SEL], clk[IMX6QDL_CLK_IPU1_DI0_PRE]);
+	imx_clk_set_parent(clk[IMX6QDL_CLK_IPU1_DI1_SEL], clk[IMX6QDL_CLK_IPU1_DI1_PRE]);
+	imx_clk_set_parent(clk[IMX6QDL_CLK_IPU2_DI0_SEL], clk[IMX6QDL_CLK_IPU2_DI0_PRE]);
+	imx_clk_set_parent(clk[IMX6QDL_CLK_IPU2_DI1_SEL], clk[IMX6QDL_CLK_LDB_DI1]);
+#endif
+#else
 	imx_clk_set_parent(clk[IMX6QDL_CLK_IPU1_DI0_SEL], clk[IMX6QDL_CLK_IPU1_DI0_PRE]);
 	imx_clk_set_parent(clk[IMX6QDL_CLK_IPU1_DI1_SEL], clk[IMX6QDL_CLK_IPU1_DI1_PRE]);
 	imx_clk_set_parent(clk[IMX6QDL_CLK_IPU2_DI0_SEL], clk[IMX6QDL_CLK_IPU2_DI0_PRE]);
 	imx_clk_set_parent(clk[IMX6QDL_CLK_IPU2_DI1_SEL], clk[IMX6QDL_CLK_IPU2_DI1_PRE]);
+#endif
 	if (cpu_is_imx6dl()) {
 		imx_clk_set_rate(clk[IMX6QDL_CLK_PLL3_PFD1_540M], 540000000);
 		imx_clk_set_parent(clk[IMX6QDL_CLK_IPU1_SEL], clk[IMX6QDL_CLK_PLL3_PFD1_540M]);
diff -ruNp kernel_imx/arch/arm/mach-imx/Kconfig kernel_imx-hdmi-lcd-lvds/arch/arm/mach-imx/Kconfig
--- kernel_imx/arch/arm/mach-imx/Kconfig	2017-05-23 11:00:12.000000000 +0800
+++ kernel_imx-hdmi-lcd-lvds/arch/arm/mach-imx/Kconfig	2018-03-27 14:07:12.359971432 +0800
@@ -588,6 +588,55 @@ config SOC_IMX6Q
 
 	help
 	  This enables support for Freescale i.MX6 Quad processor.
+config MX6_CLK_FOR_BOOTUI_TRANS
+	bool "MX6 clk setting for smooth UI transtion from bootloader to kernel"
+	depends on SOC_IMX6Q
+	default n
+	help
+	 This is choosed to keep enable IPU related clocks and PWM clocks and
+	 avoid setting IPU related clocks' parents when initializing clock tree
+	 so that bootloader splashimage can transition to kernel smoothly.
+
+choice
+	depends on MX6_CLK_FOR_BOOTUI_TRANS
+	prompt "Select Display Interface"
+
+config MX6_CLK_FOR_BOOTUI_TRANS_HDMI_IPU1_DI0
+	bool "Smooth UI transtion on HDMI, IPU1, DI0."
+	help
+	 This is choosed to keep enable IPU related setting on HDMI display which
+	 is connected on IPU1 DI0 port.
+
+config MX6_CLK_FOR_BOOTUI_TRANS_HDMI_IPU2_DI0
+	bool "Smooth UI transtion on HDMI, IPU2, DI0."
+	help
+	 This is choosed to keep enable IPU related setting on HDMI display which
+	 is connected on IPU2 DI0 port.
+
+config MX6_CLK_FOR_BOOTUI_TRANS_LCD_IPU1_DI0
+	bool "Smooth UI transtion on LCD, IPU1, DI0."
+	help
+	 This is choosed to keep enable IPU related setting on LCD panel which
+	 is connected on IPU1 DI0 port.
+
+config MX6_CLK_FOR_BOOTUI_TRANS_LVDS_IPU1_DI0
+	bool "Smooth UI transtion on LVDS, IPU1, DI0."
+	help
+	 This is choosed to keep enable IPU related setting on LVDS panel which
+	 is connected on IPU1 DI0 port.
+
+config MX6_CLK_FOR_BOOTUI_TRANS_LVDS_IPU1_DI1
+	bool "Smooth UI transtion on LVDS, IPU1, DI1."
+	help
+	 This is choosed to keep enable IPU related setting on LVDS panel which
+	 is connected on IPU1 DI1 port.
+
+config MX6_CLK_FOR_BOOTUI_TRANS_LVDS_IPU2_DI1
+	bool "Smooth UI transtion on LVDS, IPU2, DI1."
+	help
+	 This is choosed to keep enable IPU related setting on LVDS panel which
+	 is connected on IPU2 DI1 port.
+endchoice
 
 config SOC_IMX6SL
 	bool "i.MX6 SoloLite support"
diff -ruNp kernel_imx/arch/arm/mach-imx/mach-imx6q.c kernel_imx-hdmi-lcd-lvds/arch/arm/mach-imx/mach-imx6q.c
--- kernel_imx/arch/arm/mach-imx/mach-imx6q.c	2017-05-23 11:00:12.000000000 +0800
+++ kernel_imx-hdmi-lcd-lvds/arch/arm/mach-imx/mach-imx6q.c	2018-03-26 11:06:26.673712917 +0800
@@ -526,6 +526,26 @@ static void imx6q_reserve(void)
 	struct meminfo *mi;
 	struct membank *bank;
 
+#ifdef CONFIG_MX6_CLK_FOR_BOOTUI_TRANS
+	phys_addr_t base, size;
+
+	/*
+	 * Frame buffer base address.
+	 * It is same as CONFIG_FB_BASE in Uboot.
+	 */
+	base = 0x27800000;
+
+	/*
+	 * Reserved display memory size.
+	 * It should be bigger than 3 x framer buffer size.
+	 * For 1080P 32 bpp, 1920*1080*4*3 = 0x017BB000.
+	 */
+	size = 0x01800000;
+
+	memblock_reserve(base, size);
+	memblock_remove(base, size);
+#endif
+
 #ifdef CONFIG_PSTORE_RAM
 	max_phys = memblock_end_of_DRAM();
 	/* reserve 64M for uboot avoid ram console data is cleaned by uboot */
diff -ruNp kernel_imx/drivers/mfd/mxc-hdmi-core.c kernel_imx-hdmi-lcd-lvds/drivers/mfd/mxc-hdmi-core.c
--- kernel_imx/drivers/mfd/mxc-hdmi-core.c	2017-05-23 10:50:59.000000000 +0800
+++ kernel_imx-hdmi-lcd-lvds/drivers/mfd/mxc-hdmi-core.c	2018-03-26 13:16:02.337573670 +0800
@@ -47,7 +47,12 @@ static struct clk *mipi_core_clk;
 static spinlock_t irq_spinlock;
 static spinlock_t edid_spinlock;
 static unsigned int sample_rate;
+#if defined(CONFIG_MX6_CLK_FOR_BOOTUI_TRANS_HDMI_IPU1_DI0) || \
+	defined(CONFIG_MX6_CLK_FOR_BOOTUI_TRANS_HDMI_IPU2_DI0)
+static unsigned long pixel_clk_rate = 148500000;
+#else
 static unsigned long pixel_clk_rate;
+#endif
 static struct clk *pixel_clk;
 static int hdmi_ratio;
 int mxc_hdmi_ipu_id;
@@ -648,7 +653,12 @@ static int mxc_hdmi_core_probe(struct pl
 
 	pixel_clk = NULL;
 	sample_rate = 48000;
+#if defined(CONFIG_MX6_CLK_FOR_BOOTUI_TRANS_HDMI_IPU1_DI0) || \
+	defined(CONFIG_MX6_CLK_FOR_BOOTUI_TRANS_HDMI_IPU2_DI0)
+	/* Skip pixel_clk_rate set */
+#else
 	pixel_clk_rate = 0;
+#endif
 	hdmi_ratio = 100;
 
 	spin_lock_init(&irq_spinlock);
@@ -792,6 +802,20 @@ static struct platform_driver mxc_hdmi_c
 	.remove = __exit_p(mxc_hdmi_core_remove),
 };
 
+#if defined(CONFIG_MX6_CLK_FOR_BOOTUI_TRANS_HDMI_IPU1_DI0) || \
+	defined(CONFIG_MX6_CLK_FOR_BOOTUI_TRANS_HDMI_IPU2_DI0)
+static int __init mxc_hdmi_audio_clock_setup(char *options)
+{
+	if (!strcmp(options, "74250000"))
+		pixel_clk_rate = 74250000;
+	else if (!strcmp(options, "148500000"))
+		pixel_clk_rate = 148500000;
+
+	return 1;
+}
+__setup("hdmi_audio_clk=", mxc_hdmi_audio_clock_setup);
+#endif
+
 static int __init mxc_hdmi_core_init(void)
 {
 	return platform_driver_probe(&mxc_hdmi_core_driver,
diff -ruNp kernel_imx/drivers/mxc/ipu3/ipu_common.c kernel_imx-hdmi-lcd-lvds/drivers/mxc/ipu3/ipu_common.c
--- kernel_imx/drivers/mxc/ipu3/ipu_common.c	2017-05-23 10:51:00.000000000 +0800
+++ kernel_imx-hdmi-lcd-lvds/drivers/mxc/ipu3/ipu_common.c	2018-03-28 14:03:51.286427773 +0800
@@ -141,111 +141,104 @@ static inline bool idma_is_set(struct ip
 
 static int ipu_clk_setup_enable(struct ipu_soc *ipu)
 {
-	char pixel_clk_0[] = "ipu1_pclk_0";
-	char pixel_clk_1[] = "ipu1_pclk_1";
-	char pixel_clk_0_sel[] = "ipu1_pclk0_sel";
-	char pixel_clk_1_sel[] = "ipu1_pclk1_sel";
-	char pixel_clk_0_div[] = "ipu1_pclk0_div";
-	char pixel_clk_1_div[] = "ipu1_pclk1_div";
-	char *ipu_pixel_clk_sel[] = { "ipu1", "ipu1_di0", "ipu1_di1", };
-	char *pclk_sel;
+	char pixel_clk[11];
+	char pixel_clk_sel[15];
+	char pixel_clk_div[15];
+	char pixel_clk_parent0[5];
+	char pixel_clk_parent1[9];
+	char *pixel_clk_parents[2];
+	char di_clk[4];
+	char di_clk_sel[8];
 	struct clk *clk;
+	unsigned int di;
+	unsigned int ipu_id;	/* for clk naming */
 	int ret;
-	int i;
-
-	pixel_clk_0[3] += ipu->id;
-	pixel_clk_1[3] += ipu->id;
-	pixel_clk_0_sel[3] += ipu->id;
-	pixel_clk_1_sel[3] += ipu->id;
-	pixel_clk_0_div[3] += ipu->id;
-	pixel_clk_1_div[3] += ipu->id;
-	for (i = 0; i < ARRAY_SIZE(ipu_pixel_clk_sel); i++) {
-		pclk_sel = ipu_pixel_clk_sel[i];
-		pclk_sel[3] += ipu->id;
-	}
+	
 	dev_dbg(ipu->dev, "ipu_clk = %lu\n", clk_get_rate(ipu->ipu_clk));
 
-	clk = clk_register_mux_pix_clk(ipu->dev, pixel_clk_0_sel,
-			(const char **)ipu_pixel_clk_sel,
-			ARRAY_SIZE(ipu_pixel_clk_sel),
-			0, ipu->id, 0, 0);
-	if (IS_ERR(clk)) {
-		dev_err(ipu->dev, "clk_register mux di0 failed");
-		return PTR_ERR(clk);
-	}
-	ipu->pixel_clk_sel[0] = clk;
-	clk = clk_register_mux_pix_clk(ipu->dev, pixel_clk_1_sel,
-			(const char **)ipu_pixel_clk_sel,
-			ARRAY_SIZE(ipu_pixel_clk_sel),
-			0, ipu->id, 1, 0);
-	if (IS_ERR(clk)) {
-		dev_err(ipu->dev, "clk_register mux di1 failed");
-		return PTR_ERR(clk);
-	}
-	ipu->pixel_clk_sel[1] = clk;
-
-	clk = clk_register_div_pix_clk(ipu->dev, pixel_clk_0_div,
-				pixel_clk_0_sel, 0, ipu->id, 0, 0);
-	if (IS_ERR(clk)) {
-		dev_err(ipu->dev, "clk register di0 div failed");
-		return PTR_ERR(clk);
-	}
-	clk = clk_register_div_pix_clk(ipu->dev, pixel_clk_1_div,
-			pixel_clk_1_sel, CLK_SET_RATE_PARENT, ipu->id, 1, 0);
-	if (IS_ERR(clk)) {
-		dev_err(ipu->dev, "clk register di1 div failed");
-		return PTR_ERR(clk);
-	}
-
-	ipu->pixel_clk[0] = clk_register_gate_pix_clk(ipu->dev, pixel_clk_0,
-				pixel_clk_0_div, CLK_SET_RATE_PARENT,
-				ipu->id, 0, 0);
-	if (IS_ERR(ipu->pixel_clk[0])) {
-		dev_err(ipu->dev, "clk register di0 gate failed");
-		return PTR_ERR(ipu->pixel_clk[0]);
-	}
-	ipu->pixel_clk[1] = clk_register_gate_pix_clk(ipu->dev, pixel_clk_1,
-				pixel_clk_1_div, CLK_SET_RATE_PARENT,
-				ipu->id, 1, 0);
-	if (IS_ERR(ipu->pixel_clk[1])) {
-		dev_err(ipu->dev, "clk register di1 gate failed");
-		return PTR_ERR(ipu->pixel_clk[1]);
-	}
+	ipu_id = ipu->id + 1;
 
-	ret = clk_set_parent(ipu->pixel_clk_sel[0], ipu->ipu_clk);
-	if (ret) {
-		dev_err(ipu->dev, "clk set parent failed");
-		return ret;
-	}
+	pixel_clk_parents[0] = pixel_clk_parent0;
+	pixel_clk_parents[1] = pixel_clk_parent1;
 
-	ret = clk_set_parent(ipu->pixel_clk_sel[1], ipu->ipu_clk);
-	if (ret) {
-		dev_err(ipu->dev, "clk set parent failed");
-		return ret;
+	for (di = 0; di < 2; di++) {
+		snprintf(pixel_clk_sel, sizeof(pixel_clk_sel),
+				"ipu%u_pclk%u_sel", ipu_id, di);
+		snprintf(pixel_clk_parent0, sizeof(pixel_clk_parent0),
+				"ipu%u", ipu_id);
+		snprintf(pixel_clk_parent1, sizeof(pixel_clk_parent1),
+				"ipu%u_di%u", ipu_id, di);
+		clk = clk_register_mux_pix_clk(ipu->dev, pixel_clk_sel,
+				(const char **)pixel_clk_parents,
+				ARRAY_SIZE(pixel_clk_parents),
+				0, ipu->id, di, 0);
+		if (IS_ERR(clk)) {
+			dev_err(ipu->dev, "di%u mux clk register failed\n", di);
+			return PTR_ERR(clk);
+		}
+		ipu->pixel_clk_sel[di] = clk;
+
+		snprintf(pixel_clk_div, sizeof(pixel_clk_div),
+				"ipu%u_pclk%u_div", ipu_id, di);
+		clk = clk_register_div_pix_clk(ipu->dev, pixel_clk_div,
+					pixel_clk_sel, 0, ipu->id, di, 0);
+		if (IS_ERR(clk)) {
+			dev_err(ipu->dev, "di%u div clk register failed\n", di);
+			return PTR_ERR(clk);
+		}
+		snprintf(pixel_clk, sizeof(pixel_clk),
+				"ipu%u_pclk%u", ipu_id, di);
+		ipu->pixel_clk[di] = clk_register_gate_pix_clk(ipu->dev,
+					pixel_clk, pixel_clk_div,
+					CLK_SET_RATE_PARENT, ipu->id, di, 0);
+		if (IS_ERR(ipu->pixel_clk[di])) {
+			dev_err(ipu->dev,
+					"di%u gate clk register failed\n", di);
+			return PTR_ERR(ipu->pixel_clk[di]);
+		}
+		ret = clk_set_parent(ipu->pixel_clk_sel[di], ipu->ipu_clk);
+		if (ret) {
+			dev_err(ipu->dev, "pixel clk set parent failed\n");
+			return ret;
+		}
+		snprintf(di_clk, sizeof(di_clk), "di%u", di);
+		ipu->di_clk[di] = devm_clk_get(ipu->dev, di_clk);
+		if (IS_ERR(ipu->di_clk[di])) {
+			dev_err(ipu->dev, "di%u clk get failed\n", di);
+			return PTR_ERR(ipu->di_clk[di]);
+		}
+
+		snprintf(di_clk_sel, sizeof(di_clk_sel), "di%u_sel", di);
+		ipu->di_clk_sel[di] = devm_clk_get(ipu->dev, di_clk_sel);
+		if (IS_ERR(ipu->di_clk_sel[di])) {
+			dev_err(ipu->dev, "di%u sel clk get failed\n", di);
+			return PTR_ERR(ipu->di_clk_sel[di]);
+		}
 	}
 
-	ipu->di_clk[0] = devm_clk_get(ipu->dev, "di0");
-	if (IS_ERR(ipu->di_clk[0])) {
-		dev_err(ipu->dev, "clk_get di0 failed");
-		return PTR_ERR(ipu->di_clk[0]);
-	}
-	ipu->di_clk[1] = devm_clk_get(ipu->dev, "di1");
-	if (IS_ERR(ipu->di_clk[1])) {
-		dev_err(ipu->dev, "clk_get di1 failed");
-		return PTR_ERR(ipu->di_clk[1]);
-	}
-
-	ipu->di_clk_sel[0] = devm_clk_get(ipu->dev, "di0_sel");
-	if (IS_ERR(ipu->di_clk_sel[0])) {
-		dev_err(ipu->dev, "clk_get di0_sel failed");
-		return PTR_ERR(ipu->di_clk_sel[0]);
-	}
-	ipu->di_clk_sel[1] = devm_clk_get(ipu->dev, "di1_sel");
-	if (IS_ERR(ipu->di_clk_sel[1])) {
-		dev_err(ipu->dev, "clk_get di1_sel failed");
-		return PTR_ERR(ipu->di_clk_sel[1]);
-	}
+#ifdef CONFIG_MX6_CLK_FOR_BOOTUI_TRANS
+#if defined(CONFIG_MX6_CLK_FOR_BOOTUI_TRANS_LCD_IPU1_DI0) ||\
+	defined(CONFIG_MX6_CLK_FOR_BOOTUI_TRANS_HDMI_IPU1_DI0) ||\
+	defined(CONFIG_MX6_CLK_FOR_BOOTUI_TRANS_LVDS_IPU1_DI0)
+	if (ipu->id == 0)
+		clk_set_parent(ipu->pixel_clk_sel[0], ipu->di_clk[0]);
+#endif
+#ifdef CONFIG_MX6_CLK_FOR_BOOTUI_TRANS_HDMI_IPU2_DI0
+	if (ipu->id == 1)
+		clk_set_parent(ipu->pixel_clk_sel[0], ipu->di_clk[0]);
+#endif
+
+#ifdef CONFIG_MX6_CLK_FOR_BOOTUI_TRANS_LVDS_IPU1_DI1
+	if (ipu->id == 0)
+		clk_set_parent(ipu->pixel_clk_sel[1], ipu->di_clk[1]);
+#endif
+
+#ifdef CONFIG_MX6_CLK_FOR_BOOTUI_TRANS_LVDS_IPU2_DI1
+	if (ipu->id == 1)
+		clk_set_parent(ipu->pixel_clk_sel[1], ipu->di_clk[1]);
+#endif
 
+#endif
 	return 0;
 }
 
@@ -637,7 +630,12 @@ static int ipu_probe(struct platform_dev
 		ipu_cm_write(ipu, 0x00400000L | (IPU_MCU_T_DEFAULT << 18),
 			     IPU_DISP_GEN);
 	}
-
+#ifdef CONFIG_MX6_CLK_FOR_BOOTUI_TRANS
+	else {
+		ipu->fg_csc_type = ipu->bg_csc_type = CSC_NONE;
+		ipu->color_key_4rgb = true;
+	}
+#endif
 	/* setup ipu clk tree after ipu reset  */
 	ret = ipu_clk_setup_enable(ipu);
 	if (ret < 0) {
@@ -3519,3 +3517,528 @@ static void __exit ipu_gen_uninit(void)
 }
 
 module_exit(ipu_gen_uninit);
+#ifdef CONFIG_MX6_CLK_FOR_BOOTUI_TRANS
+/*!
+ * This function is called to initialize a logical IPU channel.
+ *
+ * @param	ipu	ipu handler
+ * @param       channel Input parameter for the logical channel ID to init.
+ *
+ * @param       params  Input parameter containing union of channel
+ *                      initialization parameters.
+ *
+ * @return      Returns 0 on success or negative error code on fail
+ */
+int32_t ipu_init_channel_late_init(struct ipu_soc *ipu, ipu_channel_t channel, ipu_channel_params_t *params)
+{
+	int ret = 0;
+	uint32_t ipu_conf;
+
+	dev_dbg(ipu->dev, "init channel = %d\n", IPU_CHAN_ID(channel));
+
+	ret = pm_runtime_get_sync(ipu->dev);
+	if (ret < 0) {
+		dev_err(ipu->dev, "ch = %d, pm_runtime_get failed:%d!\n",
+				IPU_CHAN_ID(channel), ret);
+		dump_stack();
+		return ret;
+	}
+	/*
+	 * Here, ret could be 1 if the device's runtime PM status was
+	 * already 'active', so clear it to be 0.
+	 */
+	ret = 0;
+
+	//_ipu_get(ipu);
+
+	mutex_lock(&ipu->mutex_lock);
+
+	/* Re-enable error interrupts every time a channel is initialized */
+	ipu_cm_write(ipu, 0xFFFFFFFF, IPU_INT_CTRL(5));
+	ipu_cm_write(ipu, 0xFFFFFFFF, IPU_INT_CTRL(6));
+	ipu_cm_write(ipu, 0xFFFFFFFF, IPU_INT_CTRL(9));
+	ipu_cm_write(ipu, 0xFFFFFFFF, IPU_INT_CTRL(10));
+
+	if (ipu->channel_init_mask & (1L << IPU_CHAN_ID(channel))) {
+		dev_warn(ipu->dev, "Warning: channel already initialized %d\n",
+			IPU_CHAN_ID(channel));
+	}
+
+	ipu_conf = ipu_cm_read(ipu, IPU_CONF);
+
+	switch (channel) {
+	case MEM_DC_SYNC:
+		if (params->mem_dc_sync.di > 1) {
+			ret = -EINVAL;
+			goto err;
+		}
+
+		ipu->dc_di_assignment[1] = params->mem_dc_sync.di;
+//		_ipu_dc_init(ipu, 1, params->mem_dc_sync.di,
+//			     params->mem_dc_sync.interlaced,
+//			     params->mem_dc_sync.out_pixel_fmt);
+		ipu->di_use_count[params->mem_dc_sync.di]++;
+		ipu->dc_use_count++;
+		ipu->dmfc_use_count++;
+		break;
+	case MEM_BG_SYNC:
+		if (params->mem_dp_bg_sync.di > 1) {
+			ret = -EINVAL;
+			goto err;
+		}
+
+		if (params->mem_dp_bg_sync.alpha_chan_en)
+			ipu->thrd_chan_en[IPU_CHAN_ID(channel)] = true;
+
+		ipu->dc_di_assignment[5] = params->mem_dp_bg_sync.di;
+//		_ipu_dp_init(ipu, channel, params->mem_dp_bg_sync.in_pixel_fmt,
+//			     params->mem_dp_bg_sync.out_pixel_fmt);
+//		_ipu_dc_init(ipu, 5, params->mem_dp_bg_sync.di,
+//			     params->mem_dp_bg_sync.interlaced,
+//			     params->mem_dp_bg_sync.out_pixel_fmt);
+		ipu->di_use_count[params->mem_dp_bg_sync.di]++;
+		ipu->dc_use_count++;
+		ipu->dp_use_count++;
+		ipu->dmfc_use_count++;
+		break;
+	case MEM_FG_SYNC:
+		_ipu_dp_init(ipu, channel, params->mem_dp_fg_sync.in_pixel_fmt,
+			     params->mem_dp_fg_sync.out_pixel_fmt);
+
+		if (params->mem_dp_fg_sync.alpha_chan_en)
+			ipu->thrd_chan_en[IPU_CHAN_ID(channel)] = true;
+
+		ipu->dc_use_count++;
+		ipu->dp_use_count++;
+		ipu->dmfc_use_count++;
+		break;
+	default:
+		dev_err(ipu->dev, "Missing channel initialization\n");
+		break;
+	}
+
+	ipu->channel_init_mask |= 1L << IPU_CHAN_ID(channel);
+
+	ipu_cm_write(ipu, ipu_conf, IPU_CONF);
+
+err:
+	mutex_unlock(&ipu->mutex_lock);
+	return ret;
+}
+EXPORT_SYMBOL(ipu_init_channel_late_init);
+
+/*!
+ * This function is called to initialize buffer(s) for logical IPU channel.
+ *
+ * @param	ipu		ipu handler
+ *
+ * @param       channel         Input parameter for the logical channel ID.
+ *
+ * @param       type            Input parameter which buffer to initialize.
+ *
+ * @param       pixel_fmt       Input parameter for pixel format of buffer.
+ *                              Pixel format is a FOURCC ASCII code.
+ *
+ * @param       width           Input parameter for width of buffer in pixels.
+ *
+ * @param       height          Input parameter for height of buffer in pixels.
+ *
+ * @param       stride          Input parameter for stride length of buffer
+ *                              in pixels.
+ *
+ * @param       rot_mode        Input parameter for rotation setting of buffer.
+ *                              A rotation setting other than
+ *                              IPU_ROTATE_VERT_FLIP
+ *                              should only be used for input buffers of
+ *                              rotation channels.
+ *
+ * @param       phyaddr_0       Input parameter buffer 0 physical address.
+ *
+ * @param       phyaddr_1       Input parameter buffer 1 physical address.
+ *                              Setting this to a value other than NULL enables
+ *                              double buffering mode.
+ *
+ * @param       phyaddr_2       Input parameter buffer 2 physical address.
+ *                              Setting this to a value other than NULL enables
+ *                              triple buffering mode, phyaddr_1 should not be
+ *                              NULL then.
+ *
+ * @param       u		private u offset for additional cropping,
+ *				zero if not used.
+ *
+ * @param       v		private v offset for additional cropping,
+ *				zero if not used.
+ *
+ * @return      Returns 0 on success or negative error code on fail
+ */
+int32_t ipu_init_channel_buffer_late_init(struct ipu_soc *ipu, ipu_channel_t channel,
+				ipu_buffer_t type,
+				uint32_t pixel_fmt,
+				uint16_t width, uint16_t height,
+				uint32_t stride,
+				ipu_rotate_mode_t rot_mode,
+				dma_addr_t phyaddr_0, dma_addr_t phyaddr_1,
+				dma_addr_t phyaddr_2,
+				uint32_t u, uint32_t v)
+{
+	uint32_t reg;
+	uint32_t dma_chan;
+	uint32_t burst_size;
+
+	dma_chan = channel_2_dma(channel, type);
+	if (!idma_is_valid(dma_chan))
+		return -EINVAL;
+
+	if (stride < width * bytes_per_pixel(pixel_fmt))
+		stride = width * bytes_per_pixel(pixel_fmt);
+
+	if (stride % 4) {
+		dev_err(ipu->dev,
+			"Stride not 32-bit aligned, stride = %d\n", stride);
+		return -EINVAL;
+	}
+	/* IC & IRT channels' width must be multiple of 8 pixels */
+	if ((_ipu_is_ic_chan(dma_chan) || _ipu_is_irt_chan(dma_chan))
+		&& (width % 8)) {
+		dev_err(ipu->dev, "Width must be 8 pixel multiple\n");
+		return -EINVAL;
+	}
+
+	if (_ipu_is_vdi_out_chan(dma_chan) &&
+		((width < 16) || (height < 16) || (width % 2) || (height % 4))) {
+		dev_err(ipu->dev, "vdi width/height limited err\n");
+		return -EINVAL;
+	}
+
+	/* IPUv3EX and IPUv3M support triple buffer */
+	if ((!_ipu_is_trb_chan(ipu, dma_chan)) && phyaddr_2) {
+		dev_err(ipu->dev, "Chan%d doesn't support triple buffer "
+				   "mode\n", dma_chan);
+		return -EINVAL;
+	}
+	if (!phyaddr_1 && phyaddr_2) {
+		dev_err(ipu->dev, "Chan%d's buf1 physical addr is NULL for "
+				   "triple buffer mode\n", dma_chan);
+		return -EINVAL;
+	}
+
+	mutex_lock(&ipu->mutex_lock);
+
+	/* Build parameter memory data for DMA channel */
+	_ipu_ch_param_init(ipu, dma_chan, pixel_fmt, width, height, stride, u, v, 0,
+			   phyaddr_0, phyaddr_1, phyaddr_2);
+
+	/* Set correlative channel parameter of local alpha channel */
+	if ((_ipu_is_ic_graphic_chan(dma_chan) ||
+	     _ipu_is_dp_graphic_chan(dma_chan)) &&
+	    (ipu->thrd_chan_en[IPU_CHAN_ID(channel)] == true)) {
+		_ipu_ch_param_set_alpha_use_separate_channel(ipu, dma_chan, true);
+		_ipu_ch_param_set_alpha_buffer_memory(ipu, dma_chan);
+		_ipu_ch_param_set_alpha_condition_read(ipu, dma_chan);
+		/* fix alpha width as 8 and burst size as 16*/
+		_ipu_ch_params_set_alpha_width(ipu, dma_chan, 8);
+		_ipu_ch_param_set_burst_size(ipu, dma_chan, 16);
+	} else if (_ipu_is_ic_graphic_chan(dma_chan) &&
+		   ipu_pixel_format_has_alpha(pixel_fmt))
+		_ipu_ch_param_set_alpha_use_separate_channel(ipu, dma_chan, false);
+
+	if (rot_mode)
+		_ipu_ch_param_set_rotation(ipu, dma_chan, rot_mode);
+
+	/* IC and ROT channels have restriction of 8 or 16 pix burst length */
+	if (_ipu_is_ic_chan(dma_chan) || _ipu_is_vdi_out_chan(dma_chan)) {
+		if ((width % 16) == 0)
+			_ipu_ch_param_set_burst_size(ipu, dma_chan, 16);
+		else
+			_ipu_ch_param_set_burst_size(ipu, dma_chan, 8);
+	} else if (_ipu_is_irt_chan(dma_chan)) {
+		_ipu_ch_param_set_burst_size(ipu, dma_chan, 8);
+		_ipu_ch_param_set_block_mode(ipu, dma_chan);
+	} else if (_ipu_is_dmfc_chan(dma_chan)) {
+		burst_size = _ipu_ch_param_get_burst_size(ipu, dma_chan);
+//		_ipu_dmfc_set_wait4eot(ipu, dma_chan, width);
+		_ipu_dmfc_set_burst_size(ipu, dma_chan, burst_size);
+	}
+
+	if (_ipu_disp_chan_is_interlaced(ipu, channel) ||
+		ipu->chan_is_interlaced[dma_chan])
+		_ipu_ch_param_set_interlaced_scan(ipu, dma_chan);
+
+	if (_ipu_is_ic_chan(dma_chan) || _ipu_is_irt_chan(dma_chan) ||
+		_ipu_is_vdi_out_chan(dma_chan)) {
+		burst_size = _ipu_ch_param_get_burst_size(ipu, dma_chan);
+		_ipu_ic_idma_init(ipu, dma_chan, width, height, burst_size,
+			rot_mode);
+	} else if (_ipu_is_smfc_chan(dma_chan)) {
+		burst_size = _ipu_ch_param_get_burst_size(ipu, dma_chan);
+		/*
+		 * This is different from IPUv3 spec, but it is confirmed
+		 * in IPUforum that SMFC burst size should be NPB[6:3]
+		 * when IDMAC works in 16-bit generic data mode.
+		 */
+		if (pixel_fmt == IPU_PIX_FMT_GENERIC)
+			/* 8 bits per pixel */
+			burst_size = burst_size >> 4;
+		else if (pixel_fmt == IPU_PIX_FMT_GENERIC_16)
+			/* 16 bits per pixel */
+			burst_size = burst_size >> 3;
+		else
+			burst_size = burst_size >> 2;
+		_ipu_smfc_set_burst_size(ipu, channel, burst_size-1);
+	}
+
+	switch (dma_chan) {
+	case 0:
+	case 1:
+	case 2:
+	case 3:
+		_ipu_ch_param_set_axi_id(ipu, dma_chan, ipu->ch0123_axi);
+		break;
+	case 23:
+		_ipu_ch_param_set_axi_id(ipu, dma_chan, ipu->ch23_axi);
+		break;
+	case 27:
+		_ipu_ch_param_set_axi_id(ipu, dma_chan, ipu->ch27_axi);
+		break;
+	case 28:
+		_ipu_ch_param_set_axi_id(ipu, dma_chan, ipu->ch28_axi);
+		break;
+	default:
+		_ipu_ch_param_set_axi_id(ipu, dma_chan, ipu->normal_axi);
+		break;
+	}
+
+	if (idma_is_set(ipu, IDMAC_CHA_PRI(dma_chan), dma_chan) &&
+	    ipu->devtype == IPUv3H) {
+		uint32_t reg = IDMAC_CH_LOCK_EN_1(ipu->devtype);
+		uint32_t value = 0;
+
+		switch (dma_chan) {
+		case 5:
+			value = 0x3;
+			break;
+		case 11:
+			value = 0x3 << 2;
+			break;
+		case 12:
+			value = 0x3 << 4;
+			break;
+		case 14:
+			value = 0x3 << 6;
+			break;
+		case 15:
+			value = 0x3 << 8;
+			break;
+		case 20:
+			value = 0x3 << 10;
+			break;
+		case 21:
+			value = 0x3 << 12;
+			break;
+		case 22:
+			value = 0x3 << 14;
+			break;
+		case 23:
+			value = 0x3 << 16;
+			break;
+		case 27:
+			value = 0x3 << 18;
+			break;
+		case 28:
+			value = 0x3 << 20;
+			break;
+		case 45:
+			reg = IDMAC_CH_LOCK_EN_2(ipu->devtype);
+			value = 0x3 << 0;
+			break;
+		case 46:
+			reg = IDMAC_CH_LOCK_EN_2(ipu->devtype);
+			value = 0x3 << 2;
+			break;
+		case 47:
+			reg = IDMAC_CH_LOCK_EN_2(ipu->devtype);
+			value = 0x3 << 4;
+			break;
+		case 48:
+			reg = IDMAC_CH_LOCK_EN_2(ipu->devtype);
+			value = 0x3 << 6;
+			break;
+		case 49:
+			reg = IDMAC_CH_LOCK_EN_2(ipu->devtype);
+			value = 0x3 << 8;
+			break;
+		case 50:
+			reg = IDMAC_CH_LOCK_EN_2(ipu->devtype);
+			value = 0x3 << 10;
+			break;
+		default:
+			break;
+		}
+		value |= ipu_idmac_read(ipu, reg);
+		ipu_idmac_write(ipu, value, reg);
+	}
+
+	_ipu_ch_param_dump(ipu, dma_chan);
+
+	if (phyaddr_2 && ipu->devtype >= IPUv3EX) {
+		reg = ipu_cm_read(ipu, IPU_CHA_DB_MODE_SEL(dma_chan));
+		reg &= ~idma_mask(dma_chan);
+		ipu_cm_write(ipu, reg, IPU_CHA_DB_MODE_SEL(dma_chan));
+
+		reg = ipu_cm_read(ipu,
+				IPU_CHA_TRB_MODE_SEL(ipu->devtype, dma_chan));
+		reg |= idma_mask(dma_chan);
+		ipu_cm_write(ipu, reg,
+				IPU_CHA_TRB_MODE_SEL(ipu->devtype, dma_chan));
+
+		/* Set IDMAC third buffer's cpmem number */
+		/* See __ipu_ch_get_third_buf_cpmem_num() for mapping */
+		ipu_idmac_write(ipu, 0x00444047L,
+				IDMAC_SUB_ADDR_4(ipu->devtype));
+		ipu_idmac_write(ipu, 0x46004241L,
+				IDMAC_SUB_ADDR_3(ipu->devtype));
+		ipu_idmac_write(ipu, 0x00000045L,
+				IDMAC_SUB_ADDR_1(ipu->devtype));
+
+		/* Reset to buffer 0 */
+		ipu_cm_write(ipu, tri_cur_buf_mask(dma_chan),
+				IPU_CHA_TRIPLE_CUR_BUF(ipu->devtype, dma_chan));
+	} else {
+		reg = ipu_cm_read(ipu,
+				IPU_CHA_TRB_MODE_SEL(ipu->devtype, dma_chan));
+		reg &= ~idma_mask(dma_chan);
+		ipu_cm_write(ipu, reg,
+				IPU_CHA_TRB_MODE_SEL(ipu->devtype, dma_chan));
+
+		reg = ipu_cm_read(ipu, IPU_CHA_DB_MODE_SEL(dma_chan));
+		if (phyaddr_1)
+			reg |= idma_mask(dma_chan);
+		else
+			reg &= ~idma_mask(dma_chan);
+		ipu_cm_write(ipu, reg, IPU_CHA_DB_MODE_SEL(dma_chan));
+
+		/* Reset to buffer 0 */
+		ipu_cm_write(ipu, idma_mask(dma_chan),
+				IPU_CHA_CUR_BUF(ipu->devtype, dma_chan));
+
+	}
+
+	mutex_unlock(&ipu->mutex_lock);
+
+	return 0;
+}
+EXPORT_SYMBOL(ipu_init_channel_buffer_late_init);
+
+/*!
+ * This function disables the interrupt for the specified interrupt line.
+ * The interrupt lines are defined in \b ipu_irq_line enum.
+ *
+ * @param	ipu		ipu handler
+ * @param       irq             Interrupt line to disable interrupt for.
+ *
+ */
+void ipu_disable_irq_late_init(struct ipu_soc *ipu, uint32_t irq)
+{
+	uint32_t reg;
+	unsigned long lock_flags;
+
+	spin_lock_irqsave(&ipu->int_reg_spin_lock, lock_flags);
+
+	reg = ipu_cm_read(ipu, IPUIRQ_2_CTRLREG(irq));
+	reg &= ~IPUIRQ_2_MASK(irq);
+	ipu_cm_write(ipu, reg, IPUIRQ_2_CTRLREG(irq));
+
+	spin_unlock_irqrestore(&ipu->int_reg_spin_lock, lock_flags);
+}
+EXPORT_SYMBOL(ipu_disable_irq_late_init);
+
+/*!
+ * This function clears the interrupt for the specified interrupt line.
+ * The interrupt lines are defined in \b ipu_irq_line enum.
+ *
+ * @param	ipu		ipu handler
+ * @param       irq             Interrupt line to clear interrupt for.
+ *
+ */
+void ipu_clear_irq_late_init(struct ipu_soc *ipu, uint32_t irq)
+{
+	unsigned long lock_flags;
+
+	spin_lock_irqsave(&ipu->int_reg_spin_lock, lock_flags);
+
+	ipu_cm_write(ipu, IPUIRQ_2_MASK(irq),
+			IPUIRQ_2_STATREG(ipu->devtype, irq));
+
+	spin_unlock_irqrestore(&ipu->int_reg_spin_lock, lock_flags);
+}
+EXPORT_SYMBOL(ipu_clear_irq_late_init);
+
+/*!
+ * This function registers an interrupt handler function for the specified
+ * interrupt line. The interrupt lines are defined in \b ipu_irq_line enum.
+ *
+ * @param	ipu		ipu handler
+ * @param       irq             Interrupt line to get status for.
+ *
+ * @param       handler         Input parameter for address of the handler
+ *                              function.
+ *
+ * @param       irq_flags       Flags for interrupt mode. Currently not used.
+ *
+ * @param       devname         Input parameter for string name of driver
+ *                              registering the handler.
+ *
+ * @param       dev_id          Input parameter for pointer of data to be
+ *                              passed to the handler.
+ *
+ * @return      This function returns 0 on success or negative error code on
+ *              fail.
+ */
+int ipu_request_irq_late_init(struct ipu_soc *ipu, uint32_t irq,
+		    irqreturn_t(*handler) (int, void *),
+		    uint32_t irq_flags, const char *devname, void *dev_id)
+{
+	uint32_t reg;
+	unsigned long lock_flags;
+	int ret = 0;
+
+	BUG_ON(irq >= IPU_IRQ_COUNT);
+
+	spin_lock_irqsave(&ipu->int_reg_spin_lock, lock_flags);
+
+	if (ipu->irq_list[irq].handler != NULL) {
+		dev_err(ipu->dev,
+			"handler already installed on irq %d\n", irq);
+		ret = -EINVAL;
+		goto out;
+	}
+
+	/*
+	 * Check sync interrupt handler only, since we do nothing for
+	 * error interrupts but than print out register values in the
+	 * error interrupt source handler.
+	 */
+	if (_ipu_is_sync_irq(irq) && (handler == NULL)) {
+		dev_err(ipu->dev, "handler is NULL for sync irq %d\n", irq);
+		ret = -EINVAL;
+		goto out;
+	}
+
+	ipu->irq_list[irq].handler = handler;
+	ipu->irq_list[irq].flags = irq_flags;
+	ipu->irq_list[irq].dev_id = dev_id;
+	ipu->irq_list[irq].name = devname;
+	/* clear irq stat for previous use */
+	ipu_cm_write(ipu, IPUIRQ_2_MASK(irq),
+			IPUIRQ_2_STATREG(ipu->devtype, irq));
+	/* enable the interrupt */
+	reg = ipu_cm_read(ipu, IPUIRQ_2_CTRLREG(irq));
+	reg |= IPUIRQ_2_MASK(irq);
+	ipu_cm_write(ipu, reg, IPUIRQ_2_CTRLREG(irq));
+out:
+	spin_unlock_irqrestore(&ipu->int_reg_spin_lock, lock_flags);
+
+	return ret;
+}
+EXPORT_SYMBOL(ipu_request_irq_late_init);
+#endif
diff -ruNp kernel_imx/drivers/mxc/ipu3/ipu_disp.c kernel_imx-hdmi-lcd-lvds/drivers/mxc/ipu3/ipu_disp.c
--- kernel_imx/drivers/mxc/ipu3/ipu_disp.c	2017-05-23 10:51:00.000000000 +0800
+++ kernel_imx-hdmi-lcd-lvds/drivers/mxc/ipu3/ipu_disp.c	2018-03-26 13:44:23.317543209 +0800
@@ -1979,3 +1979,159 @@ void ipu_disp_init(struct ipu_soc *ipu)
 	_ipu_init_dc_mappings(ipu);
 	_ipu_dmfc_init(ipu, DMFC_NORMAL, 1);
 }
+
+#ifdef CONFIG_MX6_CLK_FOR_BOOTUI_TRANS
+
+/*!
+ * This function sets the foreground and background plane global alpha blending
+ * modes. This function also sets the DP graphic plane according to the
+ * parameter of IPUv3 DP channel.
+ *
+ * @param	ipu		ipu handler
+ * @param	channel		IPUv3 DP channel
+ *
+ * @param       enable          Boolean to enable or disable global alpha
+ *                              blending. If disabled, local blending is used.
+ *
+ * @param       alpha           Global alpha value.
+ *
+ * @return      Returns 0 on success or negative error code on fail
+ */
+int32_t ipu_disp_set_global_alpha_late_init(struct ipu_soc *ipu, ipu_channel_t channel,
+				bool enable, uint8_t alpha)
+{
+	uint32_t reg;
+	uint32_t flow;
+	bool bg_chan;
+
+	if (channel == MEM_BG_SYNC || channel == MEM_FG_SYNC)
+		flow = DP_SYNC;
+	else if (channel == MEM_BG_ASYNC0 || channel == MEM_FG_ASYNC0)
+		flow = DP_ASYNC0;
+	else if (channel == MEM_BG_ASYNC1 || channel == MEM_FG_ASYNC1)
+		flow = DP_ASYNC1;
+	else
+		return -EINVAL;
+
+	if (channel == MEM_BG_SYNC || channel == MEM_BG_ASYNC0 ||
+	    channel == MEM_BG_ASYNC1)
+		bg_chan = true;
+	else
+		bg_chan = false;
+
+	mutex_lock(&ipu->mutex_lock);
+
+	if (bg_chan) {
+		reg = ipu_dp_read(ipu, DP_COM_CONF(flow));
+		ipu_dp_write(ipu, reg & ~DP_COM_CONF_GWSEL, DP_COM_CONF(flow));
+	} else {
+		reg = ipu_dp_read(ipu, DP_COM_CONF(flow));
+		ipu_dp_write(ipu, reg | DP_COM_CONF_GWSEL, DP_COM_CONF(flow));
+	}
+
+	if (enable) {
+		reg = ipu_dp_read(ipu, DP_GRAPH_WIND_CTRL(flow)) & 0x00FFFFFFL;
+		ipu_dp_write(ipu, reg | ((uint32_t) alpha << 24),
+			     DP_GRAPH_WIND_CTRL(flow));
+
+		reg = ipu_dp_read(ipu, DP_COM_CONF(flow));
+		ipu_dp_write(ipu, reg | DP_COM_CONF_GWAM, DP_COM_CONF(flow));
+	} else {
+		reg = ipu_dp_read(ipu, DP_COM_CONF(flow));
+		ipu_dp_write(ipu, reg & ~DP_COM_CONF_GWAM, DP_COM_CONF(flow));
+	}
+
+	reg = ipu_cm_read(ipu, IPU_SRM_PRI2) | 0x8;
+	ipu_cm_write(ipu, reg, IPU_SRM_PRI2);
+
+	mutex_unlock(&ipu->mutex_lock);
+
+	return 0;
+}
+EXPORT_SYMBOL(ipu_disp_set_global_alpha_late_init);
+
+/*!
+ * This function sets the transparent color key for SDC graphic plane.
+ *
+ * @param	ipu		ipu handler
+ * @param       channel         Input parameter for the logical channel ID.
+ *
+ * @param       enable          Boolean to enable or disable color key
+ *
+ * @param       colorKey        24-bit RGB color for transparent color key.
+ *
+ * @return      Returns 0 on success or negative error code on fail
+ */
+int32_t ipu_disp_set_color_key_late_init(struct ipu_soc *ipu, ipu_channel_t channel,
+				bool enable, uint32_t color_key)
+{
+	uint32_t reg, flow;
+	int y, u, v;
+	int red, green, blue;
+
+	if (channel == MEM_BG_SYNC || channel == MEM_FG_SYNC)
+		flow = DP_SYNC;
+	else if (channel == MEM_BG_ASYNC0 || channel == MEM_FG_ASYNC0)
+		flow = DP_ASYNC0;
+	else if (channel == MEM_BG_ASYNC1 || channel == MEM_FG_ASYNC1)
+		flow = DP_ASYNC1;
+	else
+		return -EINVAL;
+
+	mutex_lock(&ipu->mutex_lock);
+
+	ipu->color_key_4rgb = true;
+	/* Transform color key from rgb to yuv if CSC is enabled */
+	if (((ipu->fg_csc_type == RGB2YUV) && (ipu->bg_csc_type == YUV2YUV)) ||
+			((ipu->fg_csc_type == YUV2YUV) && (ipu->bg_csc_type == RGB2YUV)) ||
+			((ipu->fg_csc_type == YUV2YUV) && (ipu->bg_csc_type == YUV2YUV)) ||
+			((ipu->fg_csc_type == YUV2RGB) && (ipu->bg_csc_type == YUV2RGB))) {
+
+		dev_dbg(ipu->dev, "color key 0x%x need change to yuv fmt\n", color_key);
+
+		red = (color_key >> 16) & 0xFF;
+		green = (color_key >> 8) & 0xFF;
+		blue = color_key & 0xFF;
+
+		y = _rgb_to_yuv(0, red, green, blue);
+		u = _rgb_to_yuv(1, red, green, blue);
+		v = _rgb_to_yuv(2, red, green, blue);
+		color_key = (y << 16) | (u << 8) | v;
+
+		ipu->color_key_4rgb = false;
+
+		dev_dbg(ipu->dev, "color key change to yuv fmt 0x%x\n", color_key);
+	}
+
+	if (enable) {
+		reg = ipu_dp_read(ipu, DP_GRAPH_WIND_CTRL(flow)) & 0xFF000000L;
+		ipu_dp_write(ipu, reg | color_key, DP_GRAPH_WIND_CTRL(flow));
+
+		reg = ipu_dp_read(ipu, DP_COM_CONF(flow));
+		ipu_dp_write(ipu, reg | DP_COM_CONF_GWCKE, DP_COM_CONF(flow));
+	} else {
+		reg = ipu_dp_read(ipu, DP_COM_CONF(flow));
+		ipu_dp_write(ipu, reg & ~DP_COM_CONF_GWCKE, DP_COM_CONF(flow));
+	}
+
+	reg = ipu_cm_read(ipu, IPU_SRM_PRI2) | 0x8;
+	ipu_cm_write(ipu, reg, IPU_SRM_PRI2);
+
+	mutex_unlock(&ipu->mutex_lock);
+
+	return 0;
+}
+EXPORT_SYMBOL(ipu_disp_set_color_key_late_init);
+
+int32_t ipu_disp_get_window_pos_late_init(struct ipu_soc *ipu, ipu_channel_t channel,
+				int16_t *x_pos, int16_t *y_pos)
+{
+	int ret;
+
+	mutex_lock(&ipu->mutex_lock);
+	ret = _ipu_disp_get_window_pos(ipu, channel, x_pos, y_pos);
+	mutex_unlock(&ipu->mutex_lock);
+	return ret;
+}
+EXPORT_SYMBOL(ipu_disp_get_window_pos_late_init);
+#endif
diff -ruNp kernel_imx/drivers/video/backlight/backlight.c kernel_imx-hdmi-lcd-lvds/drivers/video/backlight/backlight.c
--- kernel_imx/drivers/video/backlight/backlight.c	2017-05-23 10:51:02.000000000 +0800
+++ kernel_imx-hdmi-lcd-lvds/drivers/video/backlight/backlight.c	2018-03-28 14:04:18.314427289 +0800
@@ -32,9 +32,11 @@ static const char *const backlight_types
 };
 
 #if defined(CONFIG_OF) && defined(CONFIG_ARCH_ADVANTECH)
+#ifndef CONFIG_MX6_CLK_FOR_BOOTUI_TRANS
 extern int first_power_on;
 extern void enable_ldb_bkl_pwm(void);
 #endif
+#endif
 
 #if defined(CONFIG_FB) || (defined(CONFIG_FB_MODULE) && \
 			   defined(CONFIG_BACKLIGHT_CLASS_DEVICE_MODULE))
@@ -68,6 +70,7 @@ static int fb_notifier_callback(struct n
 					bd->props.fb_blank = FB_BLANK_UNBLANK;
 
 #if defined(CONFIG_OF) && defined(CONFIG_ARCH_ADVANTECH)
+#ifndef CONFIG_MX6_CLK_FOR_BOOTUI_TRANS
 					if(first_power_on)
 						printk(KERN_INFO "[LVDS Sequence] 3 Start to enable LVDS pwm.\n");
 
@@ -82,6 +85,9 @@ static int fb_notifier_callback(struct n
 #else
 					backlight_update_status(bd);
 #endif
+#else
+                   backlight_update_status(bd);
+#endif	
 
 				}
 			} else if (fb_blank != FB_BLANK_UNBLANK &&
diff -ruNp kernel_imx/drivers/video/backlight/pwm_bl.c kernel_imx-hdmi-lcd-lvds/drivers/video/backlight/pwm_bl.c
--- kernel_imx/drivers/video/backlight/pwm_bl.c	2017-05-23 10:51:02.000000000 +0800
+++ kernel_imx-hdmi-lcd-lvds/drivers/video/backlight/pwm_bl.c	2018-03-28 14:04:41.206426879 +0800
@@ -24,10 +24,11 @@
 #include <linux/regulator/consumer.h>
 #include <linux/slab.h>
 #ifdef CONFIG_ARCH_ADVANTECH
+#ifndef CONFIG_MX6_CLK_FOR_BOOTUI_TRANS
 #include <linux/of_gpio.h>
 #include <linux/delay.h>
 #endif
-
+#endif
 struct pwm_bl_data {
 	struct pwm_device	*pwm;
 	struct device		*dev;
@@ -45,6 +46,7 @@ struct pwm_bl_data {
 					int brightness);
 	int			(*check_fb)(struct device *, struct fb_info *);
 	void			(*exit)(struct device *);
+	char			fb_id[16];
 };
 
 static void pwm_backlight_power_on(struct pwm_bl_data *pb, int brightness)
@@ -134,12 +136,20 @@ static const struct backlight_ops pwm_backlight_ops = {
 };
 
 #ifdef CONFIG_OF
+static int pwm_backlight_check_fb_name(struct device *dev, struct fb_info *info)
+{
+	struct backlight_device *bl = dev_get_drvdata(dev);
+	struct pwm_bl_data *pb = bl_get_data(bl);
+ 
+	if (strcmp(info->fix.id, pb->fb_id) == 0)
+		return true;
 
+	return false;
+}
 #ifdef CONFIG_ARCH_ADVANTECH
 int lvds_vcc_enable;
+#ifndef CONFIG_MX6_CLK_FOR_BOOTUI_TRANS
 int lvds_bkl_enable;
-int lvds_vcc_delay_value;
-int lvds_bkl_delay_value;
 enum of_gpio_flags lvds_vcc_flag;
 enum of_gpio_flags lvds_bkl_flag;
 
@@ -158,14 +168,14 @@ void enable_lcd_vdd_en(void)
 			gpio_direction_output(lvds_vcc_enable, lvds_vcc_flag);
 	}
 
-	mdelay(lvds_vcc_delay_value);
+	mdelay(250);
 }
 
 void enable_ldb_bkl_pwm(void)
 {
 	int ret;
 
-	mdelay(lvds_bkl_delay_value);
+	mdelay(20);
 	
         if (lvds_bkl_enable > 0)
         {
@@ -179,6 +189,7 @@ void enable_ldb_bkl_pwm(void)
 	}
 }
 #endif
+#endif
 
 static int pwm_backlight_parse_dt(struct device *dev,
 				  struct platform_pwm_backlight_data *data)
@@ -188,6 +199,7 @@ static int pwm_backlight_parse_dt(struct device *dev,
 	int length;
 	u32 value;
 	int ret;
+	const char *names;
 
 	if (!node)
 		return -ENODEV;
@@ -223,6 +235,10 @@ static int pwm_backlight_parse_dt(struct device *dev,
 		data->dft_brightness = value;
 		data->max_brightness--;
 	}
+	if (!of_property_read_string(node, "fb-names", &names)){
+		strcpy(data->fb_id, names);
+		data->check_fb = &pwm_backlight_check_fb_name;
+	}
 
 	data->enable_gpio = -EINVAL;
 
@@ -232,20 +248,11 @@ static int pwm_backlight_parse_dt(struct device *dev,
 	 *       added.
 	 */
 #ifdef CONFIG_ARCH_ADVANTECH
+#ifndef CONFIG_MX6_CLK_FOR_BOOTUI_TRANS
 	lvds_vcc_enable = of_get_named_gpio_flags(node, "lvds-vcc-enable", 0, &lvds_vcc_flag);
 	lvds_bkl_enable = of_get_named_gpio_flags(node, "lvds-bkl-enable", 0, &lvds_bkl_flag);
-	ret = of_property_read_u32(node,"lvds-vcc-delay-time",&lvds_vcc_delay_value);
-	if (ret < 0)
-	{
-		lvds_vcc_delay_value = 250;
-	}
-	ret = of_property_read_u32(node,"lvds-bkl-delay-time",&lvds_bkl_delay_value);
-	if (ret < 0)
-	{
-		lvds_bkl_delay_value = 20;
-	}
 #endif
-
+#endif
 	return 0;
 }
 
@@ -311,6 +318,7 @@ static int pwm_backlight_probe(struct platform_device *pdev)
 	pb->exit = data->exit;
 	pb->dev = &pdev->dev;
 	pb->enabled = false;
+	strcpy(pb->fb_id, data->fb_id);
 
 	pb->enable_gpio = devm_gpiod_get_optional(&pdev->dev, "enable");
 	if (IS_ERR(pb->enable_gpio)) {
@@ -396,11 +404,13 @@ static int pwm_backlight_probe(struct platform_device *pdev)
 	bl->props.brightness = data->dft_brightness;
 
 #if defined(CONFIG_OF) && defined(CONFIG_ARCH_ADVANTECH)
+#ifndef CONFIG_MX6_CLK_FOR_BOOTUI_TRANS
 	/* Inorder to power off pwm backlight for SI test */
 	bl->props.fb_blank = FB_BLANK_NORMAL;
 
 	printk(KERN_INFO "[LVDS Sequence] 0 Set to power off pwm backlight at first.\n");
 #endif
+#endif
 
 	backlight_update_status(bl);
 
 static void pwm_backlight_power_on(struct pwm_bl_data *pb, int brightness)
@@ -134,9 +136,19 @@ static const struct backlight_ops pwm_ba
 };
 
 #ifdef CONFIG_OF
+static int pwm_backlight_check_fb_name(struct device *dev, struct fb_info *info)
+{
+	struct backlight_device *bl = dev_get_drvdata(dev);
+	struct pwm_bl_data *pb = bl_get_data(bl);
+ 
+	if (strcmp(info->fix.id, pb->fb_id) == 0)
+		return true;
 
+	return false;
+}
 #ifdef CONFIG_ARCH_ADVANTECH
 int lvds_vcc_enable;
+#ifndef CONFIG_MX6_CLK_FOR_BOOTUI_TRANS
 int lvds_bkl_enable;
 enum of_gpio_flags lvds_vcc_flag;
 enum of_gpio_flags lvds_bkl_flag;
@@ -177,6 +189,7 @@ void enable_ldb_bkl_pwm(void)
 	}
 }
 #endif
+#endif
 
 static int pwm_backlight_parse_dt(struct device *dev,
 				  struct platform_pwm_backlight_data *data)
@@ -186,6 +199,7 @@ static int pwm_backlight_parse_dt(struct
 	int length;
 	u32 value;
 	int ret;
+	const char *names;
 
 	if (!node)
 		return -ENODEV;
@@ -221,6 +235,10 @@ static int pwm_backlight_parse_dt(struct
 		data->dft_brightness = value;
 		data->max_brightness--;
 	}
+	if (!of_property_read_string(node, "fb-names", &names)){
+		strcpy(data->fb_id, names);
+		data->check_fb = &pwm_backlight_check_fb_name;
+	}
 
 	data->enable_gpio = -EINVAL;
 
@@ -230,10 +248,11 @@ static int pwm_backlight_parse_dt(struct
 	 *       added.
 	 */
 #ifdef CONFIG_ARCH_ADVANTECH
+#ifndef CONFIG_MX6_CLK_FOR_BOOTUI_TRANS
 	lvds_vcc_enable = of_get_named_gpio_flags(node, "lvds-vcc-enable", 0, &lvds_vcc_flag);
 	lvds_bkl_enable = of_get_named_gpio_flags(node, "lvds-bkl-enable", 0, &lvds_bkl_flag);
 #endif
-
+#endif
 	return 0;
 }
 
@@ -299,6 +318,7 @@ static int pwm_backlight_probe(struct pl
 	pb->exit = data->exit;
 	pb->dev = &pdev->dev;
 	pb->enabled = false;
+	strcpy(pb->fb_id, data->fb_id);
 
 	pb->enable_gpio = devm_gpiod_get_optional(&pdev->dev, "enable");
 	if (IS_ERR(pb->enable_gpio)) {
@@ -384,11 +404,13 @@ static int pwm_backlight_probe(struct pl
 	bl->props.brightness = data->dft_brightness;
 
 #if defined(CONFIG_OF) && defined(CONFIG_ARCH_ADVANTECH)
+#ifndef CONFIG_MX6_CLK_FOR_BOOTUI_TRANS
 	/* Inorder to power off pwm backlight for SI test */
 	bl->props.fb_blank = FB_BLANK_NORMAL;
 
 	printk(KERN_INFO "[LVDS Sequence] 0 Set to power off pwm backlight at first.\n");
 #endif
+#endif
 
 	backlight_update_status(bl);
 
diff -ruNp kernel_imx/drivers/video/fbdev/mxc/ldb.c kernel_imx-hdmi-lcd-lvds/drivers/video/fbdev/mxc/ldb.c
--- kernel_imx/drivers/video/fbdev/mxc/ldb.c	2017-05-23 10:51:02.000000000 +0800
+++ kernel_imx-hdmi-lcd-lvds/drivers/video/fbdev/mxc/ldb.c	2018-03-27 14:24:46.863952548 +0800
@@ -102,6 +102,11 @@ struct ldb_data {
 	struct clk *div_3_5_clk[2];
 	struct clk *div_7_clk[2];
 	struct clk *div_sel_clk[2];
+#if defined(CONFIG_MX6_CLK_FOR_BOOTUI_TRANS_LVDS_IPU1_DI0) || \
+	defined(CONFIG_MX6_CLK_FOR_BOOTUI_TRANS_LVDS_IPU1_DI1)  || \
+	defined(CONFIG_MX6_CLK_FOR_BOOTUI_TRANS_LVDS_IPU2_DI1)
+	bool fb_reg;
+#endif
 };
 
 static const struct crtc_mux imx6q_lvds0_crtc_mux[] = {
@@ -429,7 +434,13 @@ static int ldb_setup(struct mxc_dispdrv_
 #ifdef CONFIG_ARCH_ADVANTECH
 	ldb_di_parent = ldb->spl_mode ? ldb->div_3_5_clk[chno] : ldb->div_7_clk[chno];
 #endif
-
+#if defined(CONFIG_MX6_CLK_FOR_BOOTUI_TRANS_LVDS_IPU1_DI0) || \
+	defined(CONFIG_MX6_CLK_FOR_BOOTUI_TRANS_LVDS_IPU1_DI1) || \
+	defined(CONFIG_MX6_CLK_FOR_BOOTUI_TRANS_LVDS_IPU2_DI1)
+	if (ldb->fb_reg == false) {
+		return 0;
+	}
+#endif
 	if (ldb->clk_fixup) {
 		/*
 		 * ldb_di_sel_parent(plls) -> ldb_di_sel -> ldb_di[chno] ->
@@ -531,6 +542,13 @@ static int ldb_enable(struct mxc_dispdrv
 	chan = ldb->chan[chno];
 
 	bus_mux = ldb->buses[chno];
+#if defined(CONFIG_MX6_CLK_FOR_BOOTUI_TRANS_LVDS_IPU1_DI0) || \
+	defined(CONFIG_MX6_CLK_FOR_BOOTUI_TRANS_LVDS_IPU1_DI1) || \
+	defined(CONFIG_MX6_CLK_FOR_BOOTUI_TRANS_LVDS_IPU2_DI1)
+	if (ldb->fb_reg == false) {
+		return 0;
+	}
+#endif
 
 	if (ldb->spl_mode || ldb->dual_mode) {
 		other_chno = chno ? 0 : 1;
@@ -573,6 +591,13 @@ static void ldb_disable(struct mxc_dispd
 	if (ret < 0)
 		return;
 
+#if defined(CONFIG_MX6_CLK_FOR_BOOTUI_TRANS_LVDS_IPU1_DI0) || \
+	defined(CONFIG_MX6_CLK_FOR_BOOTUI_TRANS_LVDS_IPU1_DI1) || \
+	defined(CONFIG_MX6_CLK_FOR_BOOTUI_TRANS_LVDS_IPU2_DI1)
+	if (ldb->fb_reg == false) {
+		return;
+	}
+#endif
 	if (ldb->spl_mode || ldb->dual_mode) {
 		ldb->ctrl &= ~(LDB_CH1_MODE_MASK | LDB_CH0_MODE_MASK);
 		other_chno = chno ? 0 : 1;
@@ -586,12 +611,30 @@ static void ldb_disable(struct mxc_dispd
 	return;
 }
 
+#if defined(CONFIG_MX6_CLK_FOR_BOOTUI_TRANS_LVDS_IPU1_DI0) || \
+	defined(CONFIG_MX6_CLK_FOR_BOOTUI_TRANS_LVDS_IPU1_DI1) || \
+	defined(CONFIG_MX6_CLK_FOR_BOOTUI_TRANS_LVDS_IPU2_DI1)
+void ldb_disp_late_init_done(struct mxc_dispdrv_handle *disp)
+{
+	struct ldb_data *ldb = mxc_dispdrv_getdata(disp);
+
+	ldb->fb_reg = true;
+}
+#endif
+
 static struct mxc_dispdrv_driver ldb_drv = {
 	.name		= DRIVER_NAME,
 	.init		= ldb_init,
 	.setup		= ldb_setup,
 	.enable		= ldb_enable,
-	.disable	= ldb_disable
+#if defined(CONFIG_MX6_CLK_FOR_BOOTUI_TRANS_LVDS_IPU1_DI0) || \
+	defined(CONFIG_MX6_CLK_FOR_BOOTUI_TRANS_LVDS_IPU1_DI1) || \
+	defined(CONFIG_MX6_CLK_FOR_BOOTUI_TRANS_LVDS_IPU2_DI1)
+	.disable        = ldb_disable,
+	.late_init_done = ldb_disp_late_init_done
+#else
+	.disable        = ldb_disable
+#endif
 };
 
 enum {
diff -ruNp kernel_imx/drivers/video/fbdev/mxc/mxc_dispdrv.h kernel_imx-hdmi-lcd-lvds/drivers/video/fbdev/mxc/mxc_dispdrv.h
--- kernel_imx/drivers/video/fbdev/mxc/mxc_dispdrv.h	2017-05-23 11:00:13.000000000 +0800
+++ kernel_imx-hdmi-lcd-lvds/drivers/video/fbdev/mxc/mxc_dispdrv.h	2018-03-26 11:16:34.161702038 +0800
@@ -40,6 +40,10 @@ struct mxc_dispdrv_driver {
 	void (*disable) (struct mxc_dispdrv_handle *, struct fb_info *);
 	/* display driver setup function, called at early part of fb_set_par */
 	int (*setup) (struct mxc_dispdrv_handle *, struct fb_info *fbi);
+#ifdef CONFIG_MX6_CLK_FOR_BOOTUI_TRANS
+	/* display driver late init done. */
+	void (*late_init_done) (struct mxc_dispdrv_handle *);
+#endif
 };
 
 struct mxc_dispdrv_handle *mxc_dispdrv_register(struct mxc_dispdrv_driver *drv);
diff -ruNp kernel_imx/drivers/video/fbdev/mxc/mxc_hdmi.c kernel_imx-hdmi-lcd-lvds/drivers/video/fbdev/mxc/mxc_hdmi.c
--- kernel_imx/drivers/video/fbdev/mxc/mxc_hdmi.c	2017-05-23 11:00:13.000000000 +0800
+++ kernel_imx-hdmi-lcd-lvds/drivers/video/fbdev/mxc/mxc_hdmi.c	2018-03-26 13:23:06.549566073 +0800
@@ -1756,8 +1756,13 @@ static void mxc_hdmi_clear_overflow(stru
 static void hdmi_enable_overflow_interrupts(void)
 {
 	pr_debug("%s\n", __func__);
+#if defined(CONFIG_MX6_CLK_FOR_BOOTUI_TRANS_HDMI_IPU1_DI0) || \
+	defined(CONFIG_MX6_CLK_FOR_BOOTUI_TRANS_HDMI_IPU2_DI0)
+	/* Skip */
+#else
 	hdmi_writeb(0, HDMI_FC_MASK2);
 	hdmi_writeb(0, HDMI_IH_MUTE_FC_STAT2);
+#endif
 }
 
 static void hdmi_disable_overflow_interrupts(void)
@@ -2015,6 +2020,10 @@ static void hotplug_worker(struct work_s
 	unsigned long flags;
 	char event_string[32];
 	char *envp[] = { event_string, NULL };
+#if defined(CONFIG_MX6_CLK_FOR_BOOTUI_TRANS_HDMI_IPU1_DI0) || \
+	defined(CONFIG_MX6_CLK_FOR_BOOTUI_TRANS_HDMI_IPU2_DI0)
+	int edid_status = HDMI_EDID_FAIL;
+#endif
 
 	phy_int_stat = hdmi->latest_intr_stat;
 	phy_int_pol = hdmi_readb(HDMI_PHY_POL0);
@@ -2028,7 +2037,27 @@ static void hotplug_worker(struct work_s
 		if (phy_int_pol & HDMI_PHY_HPD) {
 			/* Plugin event */
 			dev_dbg(&hdmi->pdev->dev, "EVENT=plugin\n");
+#if defined(CONFIG_MX6_CLK_FOR_BOOTUI_TRANS_HDMI_IPU1_DI0) || \
+	defined(CONFIG_MX6_CLK_FOR_BOOTUI_TRANS_HDMI_IPU2_DI0)
+			if (hdmi->fb_reg)
+				mxc_hdmi_cable_connected(hdmi);
+			else {
+				hdmi->cable_plugin = true;
+				hdmi_set_blank_state(1);
+				/* Plugin event */
+				dev_dbg(&hdmi->pdev->dev, "cable plugin\n");
+				edid_status = mxc_hdmi_read_edid(hdmi);
+
+				/* Read EDID again if first EDID read failed */
+				if (edid_status == HDMI_EDID_NO_MODES ||
+					edid_status == HDMI_EDID_FAIL) {
+					dev_info(&hdmi->pdev->dev, "Read EDID again\n");
+					edid_status = mxc_hdmi_read_edid(hdmi);
+				}
+			}
+#else
 			mxc_hdmi_cable_connected(hdmi);
+#endif
 
 			/* Make HPD intr active low to capture unplug event */
 			val = hdmi_readb(HDMI_PHY_POL0);
@@ -2067,6 +2096,10 @@ static void hotplug_worker(struct work_s
 #ifdef CONFIG_MXC_HDMI_CEC
 			mxc_hdmi_cec_handle(0x100);
 #endif
+#if defined(CONFIG_MX6_CLK_FOR_BOOTUI_TRANS_HDMI_IPU1_DI0) || \
+        defined(CONFIG_MX6_CLK_FOR_BOOTUI_TRANS_HDMI_IPU2_DI0)
+			hdmi->fb_reg = true;
+#endif
 
 		} else
 			dev_dbg(&hdmi->pdev->dev, "EVENT=none?\n");
@@ -2280,6 +2313,19 @@ static void mxc_hdmi_setup(struct mxc_hd
 
 }
 
+#if defined(CONFIG_MX6_CLK_FOR_BOOTUI_TRANS_HDMI_IPU1_DI0) || \
+	defined(CONFIG_MX6_CLK_FOR_BOOTUI_TRANS_HDMI_IPU2_DI0)
+void mxc_hdmi_late_init_done(struct mxc_dispdrv_handle *disp)
+{
+	struct mxc_hdmi *hdmi = mxc_dispdrv_getdata(disp);
+
+	dev_dbg(&hdmi->pdev->dev, "%s\n", __func__);
+
+	hdmi->fb_reg = true;
+	hdmi->dft_mode_set = false;
+}
+#endif
+
 /* Wait until we are registered to enable interrupts */
 static void mxc_hdmi_fb_registered(struct mxc_hdmi *hdmi)
 {
@@ -2307,8 +2353,14 @@ static void mxc_hdmi_fb_registered(struc
 
 	/* Unmute interrupts */
 	hdmi_writeb(~HDMI_IH_MUTE_PHY_STAT0_HPD, HDMI_IH_MUTE_PHY_STAT0);
-
+#if defined(CONFIG_MX6_CLK_FOR_BOOTUI_TRANS_HDMI_IPU1_DI0) || \
+	defined(CONFIG_MX6_CLK_FOR_BOOTUI_TRANS_HDMI_IPU2_DI0)
+	hdmi->phy_enabled = true;
+	hdmi->blank = FB_BLANK_UNBLANK;
+	/* Skip hdmi->fb_reg. */
+#else
 	hdmi->fb_reg = true;
+#endif
 
 	spin_unlock_irqrestore(&hdmi->irq_lock, flags);
 
@@ -2339,6 +2391,22 @@ static int mxc_hdmi_fb_event(struct noti
 
 	case FB_EVENT_MODE_CHANGE:
 		dev_dbg(&hdmi->pdev->dev, "event=FB_EVENT_MODE_CHANGE\n");
+#if defined(CONFIG_MX6_CLK_FOR_BOOTUI_TRANS_HDMI_IPU1_DI0) || \
+	defined(CONFIG_MX6_CLK_FOR_BOOTUI_TRANS_HDMI_IPU2_DI0)
+		if (!hdmi->fb_reg) {
+			struct fb_videomode m;
+
+			fb_var_to_videomode(&m, &hdmi->fbi->var);
+			hdmi->blank = FB_BLANK_UNBLANK;
+
+			if (!hdmi->requesting_vga_for_initialization) {
+				/* Save mode if this isn't the result of requesting
+				 * vga default. */
+				memcpy(&hdmi->previous_non_vga_mode, &m,
+						sizeof(struct fb_videomode));
+			}
+		}
+#endif
 		mode = (struct fb_videomode *)event->data;
 		if (hdmi->fbi != NULL)
 			hdmi->yres_virtual = hdmi->fbi->var.yres_virtual;
@@ -2394,7 +2462,12 @@ static int mxc_hdmi_fb_event(struct noti
 			clk_enable(hdmi->mipi_core_clk);
 			clk_enable(hdmi->hdmi_iahb_clk);
 			clk_enable(hdmi->hdmi_isfr_clk);
+#if defined(CONFIG_MX6_CLK_FOR_BOOTUI_TRANS_HDMI_IPU1_DI0) || \
+	defined(CONFIG_MX6_CLK_FOR_BOOTUI_TRANS_HDMI_IPU2_DI0)
+			mxc_hdmi_setup(hdmi, val);
+#else
 			mxc_hdmi_phy_init(hdmi);
+#endif
 		}
 		break;
 
@@ -2741,6 +2814,10 @@ static struct mxc_dispdrv_driver mxc_hdm
 	.deinit	= mxc_hdmi_disp_deinit,
 	.enable = mxc_hdmi_power_on,
 	.disable = mxc_hdmi_power_off,
+#if defined(CONFIG_MX6_CLK_FOR_BOOTUI_TRANS_HDMI_IPU1_DI0) || \
+	defined(CONFIG_MX6_CLK_FOR_BOOTUI_TRANS_HDMI_IPU2_DI0)
+	.late_init_done = mxc_hdmi_late_init_done,
+#endif
 };
 
 
diff -ruNp kernel_imx/drivers/video/fbdev/mxc/mxc_ipuv3_fb.c kernel_imx-hdmi-lcd-lvds/drivers/video/fbdev/mxc/mxc_ipuv3_fb.c
--- kernel_imx/drivers/video/fbdev/mxc/mxc_ipuv3_fb.c	2017-05-23 11:00:13.000000000 +0800
+++ kernel_imx-hdmi-lcd-lvds/drivers/video/fbdev/mxc/mxc_ipuv3_fb.c	2018-03-28 14:05:04.990426453 +0800
@@ -64,13 +64,14 @@
 
 #ifdef CONFIG_ARCH_ADVANTECH
 char fb_vga_fix_id[30];
+#ifndef CONFIG_MX6_CLK_FOR_BOOTUI_TRANS
 
 #if defined(CONFIG_OF)
 int first_power_on = 1;
 extern void enable_lcd_vdd_en(void);
 extern void enable_ldb_bkl_pwm(void);
 #endif
-
+#endif
 #endif
 
 /*!
@@ -89,6 +90,9 @@ struct mxcfb_info {
 	bool overlay;
 	bool alpha_chan_en;
 	bool late_init;
+#ifdef CONFIG_MX6_CLK_FOR_BOOTUI_TRANS
+	bool late_init_idmac_done;
+#endif
 	bool first_set_par;
 	bool resolve;
 	bool prefetch;
@@ -131,7 +135,6 @@ struct mxcfb_info {
 	bool cur_prefetch;
 	spinlock_t spin_lock;	/* for PRE small yres cases */
 	struct ipu_pre_context *pre_config;
-	ktime_t vsync_nf_timestamp;
 };
 
 struct mxcfb_pfmt {
@@ -483,7 +486,14 @@ static int _setup_disp_channel1(struct f
 		if (mxc_fbi->alpha_chan_en)
 			params.mem_dp_bg_sync.alpha_chan_en = true;
 	}
+#ifdef CONFIG_MX6_CLK_FOR_BOOTUI_TRANS
+	if (mxc_fbi->late_init)
+		ipu_init_channel_late_init(mxc_fbi->ipu, mxc_fbi->ipu_ch, &params);
+	else
+		ipu_init_channel(mxc_fbi->ipu, mxc_fbi->ipu_ch, &params);
+#else
 	ipu_init_channel(mxc_fbi->ipu, mxc_fbi->ipu_ch, &params);
+#endif
 
 	return 0;
 }
@@ -906,6 +916,29 @@ static int _setup_disp_channel2(struct f
 							       IPU_INPUT_BUFFER, 2));
 		}
 	} else if (!mxc_fbi->on_the_fly && !mxc_fbi->prefetch) {
+#ifdef CONFIG_MX6_CLK_FOR_BOOTUI_TRANS
+		if (mxc_fbi->late_init) {
+			mxc_fbi->cur_ipu_buf = 0;
+			retval = ipu_init_channel_buffer_late_init(mxc_fbi->ipu,
+						 mxc_fbi->ipu_ch, IPU_INPUT_BUFFER,
+						 fbi_to_pixfmt(fbi, false),
+						 fbi->var.xres, fbi->var.yres,
+						 ipu_stride,
+						 fbi->var.rotate,
+						 ipu_base,
+						 ipu_base,
+						 fbi->var.accel_flags &
+						FB_ACCEL_DOUBLE_FLAG ? 0 : ipu_base,
+						 0, 0);
+			if (retval) {
+				dev_err(fbi->device,
+					"ipu_init_channel_buffer error %d\n", retval);
+				return retval;
+			}
+
+			mxc_fbi->late_init_idmac_done = true;
+		} else {
+#endif
 		retval = ipu_init_channel_buffer(mxc_fbi->ipu,
 						 mxc_fbi->ipu_ch, IPU_INPUT_BUFFER,
 						 mxc_fbi->on_the_fly ? mxc_fbi->final_pfmt :
@@ -923,6 +956,9 @@ static int _setup_disp_channel2(struct f
 				"ipu_init_channel_buffer error %d\n", retval);
 			return retval;
 		}
+#ifdef CONFIG_MX6_CLK_FOR_BOOTUI_TRANS
+		}
+#endif
 		/* update u/v offset */
 		if (!mxc_fbi->prefetch)
 			ipu_update_channel_offset(mxc_fbi->ipu, mxc_fbi->ipu_ch,
@@ -967,7 +1003,22 @@ static int _setup_disp_channel2(struct f
 static bool mxcfb_need_to_set_par(struct fb_info *fbi)
 {
 	struct mxcfb_info *mxc_fbi = fbi->par;
+#ifdef CONFIG_MX6_CLK_FOR_BOOTUI_TRANS
+	if (mxc_fbi->late_init) {
+		if ((mxc_fbi->cur_var.xres != fbi->var.xres) ||
+			(mxc_fbi->cur_var.yres != fbi->var.yres) ||
+			(mxc_fbi->cur_var.bits_per_pixel != fbi->var.bits_per_pixel)) {
+			mxc_fbi->late_init = false;
+
+			if (mxc_fbi->dispdrv && mxc_fbi->dispdrv->drv->late_init_done)
+				mxc_fbi->dispdrv->drv->late_init_done(mxc_fbi->dispdrv);
+			return true;
+		}
 
+		if (mxc_fbi->late_init_idmac_done)
+			return false;
+	}
+#endif
 	if ((fbi->var.activate & FB_ACTIVATE_FORCE) &&
 	    (fbi->var.activate & FB_ACTIVATE_MASK) == FB_ACTIVATE_NOW)
 		return true;
@@ -1165,6 +1216,42 @@ static int mxcfb_set_par(struct fb_info
 
 	if (on_the_fly)
 		dev_dbg(fbi->device, "Reconfiguring framebuffer on the fly\n");
+#ifdef CONFIG_MX6_CLK_FOR_BOOTUI_TRANS
+	if (mxc_fbi->late_init) {
+		if (ovfbi_enable) {
+			ov_pos_ret = ipu_disp_get_window_pos_late_init(
+							mxc_fbi_fg->ipu, mxc_fbi_fg->ipu_ch,
+							&ov_pos_x, &ov_pos_y);
+			if (ov_pos_ret < 0)
+				dev_err(fbi->device, "Get overlay pos failed, dispdrv:%s.\n",
+							mxc_fbi->dispdrv->drv->name);
+
+			if (!on_the_fly) {
+				ipu_clear_irq_late_init(mxc_fbi_fg->ipu, mxc_fbi_fg->ipu_ch_irq);
+				ipu_disable_irq_late_init(mxc_fbi_fg->ipu, mxc_fbi_fg->ipu_ch_irq);
+				ipu_clear_irq_late_init(mxc_fbi_fg->ipu, mxc_fbi_fg->ipu_ch_nf_irq);
+				ipu_disable_irq_late_init(mxc_fbi_fg->ipu, mxc_fbi_fg->ipu_ch_nf_irq);
+				if (mxc_fbi_fg->cur_prefetch) {
+					ipu_prg_disable(mxc_fbi_fg->ipu_id, mxc_fbi_fg->pre_num);
+					ipu_pre_disable(mxc_fbi_fg->pre_num);
+					ipu_pre_free(&mxc_fbi_fg->pre_num);
+				}
+			}
+		}
+
+		if (!on_the_fly) {
+			ipu_clear_irq_late_init(mxc_fbi->ipu, mxc_fbi->ipu_ch_irq);
+			ipu_disable_irq_late_init(mxc_fbi->ipu, mxc_fbi->ipu_ch_irq);
+			ipu_clear_irq_late_init(mxc_fbi->ipu, mxc_fbi->ipu_ch_nf_irq);
+			ipu_disable_irq_late_init(mxc_fbi->ipu, mxc_fbi->ipu_ch_nf_irq);
+			if (mxc_fbi->cur_prefetch) {
+				ipu_prg_disable(mxc_fbi->ipu_id, mxc_fbi->pre_num);
+				ipu_pre_disable(mxc_fbi->pre_num);
+				ipu_pre_free(&mxc_fbi->pre_num);
+			}
+                }
+	} else {
+#endif
 
 	if (ovfbi_enable) {
 		ov_pos_ret = ipu_disp_get_window_pos(
@@ -1209,6 +1296,9 @@ static int mxcfb_set_par(struct fb_info
 	 */
 	if (mxc_fbi->first_set_par && mxc_fbi->late_init)
 		ipu_disable_hsp_clk(mxc_fbi->ipu);
+#ifdef CONFIG_MX6_CLK_FOR_BOOTUI_TRANS
+	}
+#endif
 
 	mem_len = fbi->var.yres_virtual * fbi->fix.line_length;
 	if (mxc_fbi->resolve && mxc_fbi->gpu_sec_buf_off) {
@@ -1227,12 +1317,14 @@ static int mxcfb_set_par(struct fb_info
 	}
 
 	if (mxc_fbi->first_set_par) {
+#ifndef CONFIG_MX6_CLK_FOR_BOOTUI_TRANS
 		/*
 		 * Clear the screen in case uboot fb pixel format is not
 		 * the same to kernel fb pixel format.
 		 */
 		if (mxc_fbi->late_init)
 			memset((char *)fbi->screen_base, 0, fbi->fix.smem_len);
+#endif
 
 		mxc_fbi->first_set_par = false;
 	}
@@ -1312,6 +1404,9 @@ static int mxcfb_set_par(struct fb_info
 	}
 
 	if (!mxc_fbi->overlay && !on_the_fly) {
+#ifdef CONFIG_MX6_CLK_FOR_BOOTUI_TRANS
+		if (!mxc_fbi->late_init) {
+#endif
 		uint32_t out_pixel_fmt;
 
 		memset(&sig_cfg, 0, sizeof(sig_cfg));
@@ -1353,6 +1448,9 @@ static int mxcfb_set_par(struct fb_info
 				"mxcfb: Error initializing panel.\n");
 			return -EINVAL;
 		}
+#ifdef CONFIG_MX6_CLK_FOR_BOOTUI_TRANS
+		}
+#endif
 
 		fbi->mode =
 		    (struct fb_videomode *)fb_match_mode(&fbi->var,
@@ -1597,6 +1695,11 @@ static int mxcfb_check_var(struct fb_var
 
 		bg_xres = fbi_tmp->var.xres;
 		bg_yres = fbi_tmp->var.yres;
+#ifdef CONFIG_MX6_CLK_FOR_BOOTUI_TRANS
+		if (mxc_fbi->late_init)
+			ipu_disp_get_window_pos_late_init(mxc_fbi->ipu, mxc_fbi->ipu_ch, &pos_x, &pos_y);
+		else
+#endif
 
 		ipu_disp_get_window_pos(mxc_fbi->ipu, mxc_fbi->ipu_ch, &pos_x, &pos_y);
 
@@ -2100,7 +2203,6 @@ static int mxcfb_ioctl(struct fb_info *f
 		}
 	case MXCFB_WAIT_FOR_VSYNC:
 		{
-			unsigned long long timestamp;
 			if (mxc_fbi->ipu_ch == MEM_FG_SYNC) {
 				/* BG should poweron */
 				struct mxcfb_info *bg_mxcfbi = NULL;
@@ -2129,12 +2231,6 @@ static int mxcfb_ioctl(struct fb_info *f
 			ipu_enable_irq(mxc_fbi->ipu, mxc_fbi->ipu_ch_nf_irq);
 			retval = wait_for_completion_interruptible_timeout(
 				&mxc_fbi->vsync_complete, 1 * HZ);
-			timestamp = ktime_to_ns(mxc_fbi->vsync_nf_timestamp);
-			dev_vdbg(fbi->device, "ts = %llu", timestamp);
-			if (copy_to_user((void *)arg, &timestamp, sizeof(timestamp))) {
-				retval = -EFAULT;
-				break;
-			}
 			if (retval == 0) {
 				dev_err(fbi->device,
 					"MXCFB_WAIT_FOR_VSYNC: timeout %d\n",
@@ -2356,6 +2452,12 @@ static int mxcfb_blank(int blank, struct
 				FB_ACTIVATE_NOW | FB_ACTIVATE_FORCE;
 		ret = fb_set_var(info, &info->var);
 	} else {
+#ifdef CONFIG_MX6_CLK_FOR_BOOTUI_TRANS
+		if (mxc_fbi->late_init) {
+			if (mxc_fbi->dispdrv && mxc_fbi->dispdrv->drv->late_init_done)
+				mxc_fbi->dispdrv->drv->late_init_done(mxc_fbi->dispdrv);
+		}
+#endif
 		if (mxc_fbi->dispdrv && mxc_fbi->dispdrv->drv->disable)
 			mxc_fbi->dispdrv->drv->disable(mxc_fbi->dispdrv, info);
 		ipu_disable_channel(mxc_fbi->ipu, mxc_fbi->ipu_ch, true);
@@ -2367,6 +2469,10 @@ static int mxcfb_blank(int blank, struct
 			ipu_pre_disable(mxc_fbi->pre_num);
 			ipu_pre_free(&mxc_fbi->pre_num);
 		}
+#ifdef CONFIG_MX6_CLK_FOR_BOOTUI_TRANS
+		if (mxc_fbi->late_init)
+			mxc_fbi->late_init = false;
+#endif
 	}
 	if (!ret)
 		mxc_fbi->cur_blank = blank;
@@ -2409,10 +2515,12 @@ mxcfb_pan_display(struct fb_var_screenin
 			return -EINVAL;
 
 #ifdef CONFIG_ARCH_ADVANTECH
+#ifndef CONFIG_MX6_CLK_FOR_BOOTUI_TRANS
 		/* overlay should be smaller than BG */
 		if ((info->var.xres > fbi_tmp->var.xres) || (info->var.yres > fbi_tmp->var.yres))
 			return -EINVAL;			
 #endif
+#endif
 	}
 	if (mxc_fbi->cur_blank != FB_BLANK_UNBLANK)
 		return -EINVAL;
@@ -2754,7 +2862,6 @@ static irqreturn_t mxcfb_nf_irq_handler(
 	struct fb_info *fbi = dev_id;
 	struct mxcfb_info *mxc_fbi = fbi->par;
 
-	mxc_fbi->vsync_nf_timestamp = ktime_get();
 	complete(&mxc_fbi->vsync_complete);
 	return IRQ_HANDLED;
 }
@@ -3221,6 +3328,36 @@ static int mxcfb_register(struct fb_info
 		INIT_LIST_HEAD(&fbi->modelist);
 	fb_var_to_videomode(&m, &fbi->var);
 	fb_add_videomode(&m, &fbi->modelist);
+#ifdef CONFIG_MX6_CLK_FOR_BOOTUI_TRANS
+		if (mxcfbi->late_init) {
+			if (ipu_request_irq_late_init(mxcfbi->ipu, mxcfbi->ipu_ch_irq,
+				mxcfb_irq_handler, IPU_IRQF_ONESHOT, MXCFB_NAME, fbi) != 0) {
+				dev_err(fbi->device, "Error registering EOF irq handler.\n");
+				ret = -EBUSY;
+				goto err0;
+			}
+			ipu_disable_irq_late_init(mxcfbi->ipu, mxcfbi->ipu_ch_irq);
+
+			if (ipu_request_irq_late_init(mxcfbi->ipu, mxcfbi->ipu_ch_nf_irq,
+				mxcfb_nf_irq_handler, IPU_IRQF_ONESHOT, MXCFB_NAME, fbi) != 0) {
+				dev_err(fbi->device, "Error registering NFACK irq handler.\n");
+				ret = -EBUSY;
+				goto err1;
+			}
+			ipu_disable_irq_late_init(mxcfbi->ipu, mxcfbi->ipu_ch_nf_irq);
+
+			if (mxcfbi->ipu_alp_ch_irq != -1) {
+				if (ipu_request_irq_late_init(mxcfbi->ipu, mxcfbi->ipu_alp_ch_irq,
+							mxcfb_alpha_irq_handler, IPU_IRQF_ONESHOT,
+							MXCFB_NAME, fbi) != 0) {
+					dev_err(fbi->device, "Error registering alpha irq "
+							"handler.\n");
+					ret = -EBUSY;
+					goto err3;
+				}
+			}
+		} else {
+#endif
 
 	if (ipu_request_irq(mxcfbi->ipu, mxcfbi->ipu_ch_irq,
 		mxcfb_irq_handler, IPU_IRQF_ONESHOT, MXCFB_NAME, fbi) != 0) {
@@ -3246,7 +3383,9 @@ static int mxcfb_register(struct fb_info
 			ret = -EBUSY;
 			goto err2;
 		}
-
+#ifdef CONFIG_MX6_CLK_FOR_BOOTUI_TRANS
+	}
+#endif
 	if (!mxcfbi->late_init) {
 		fbi->var.activate |= FB_ACTIVATE_FORCE;
 		console_lock();
@@ -3287,6 +3426,12 @@ static int mxcfb_register(struct fb_info
 	ret = register_framebuffer(fbi);
 	if (ret < 0)
 		goto err5;
+#ifdef CONFIG_MX6_CLK_FOR_BOOTUI_TRANS
+	if (mxcfbi->late_init && (mxcfbi->next_blank == FB_BLANK_UNBLANK)) {
+		mxcfbi->cur_var = fbi->var;
+		fbi->mode =(struct fb_videomode *)fb_match_mode(&fbi->var, &fbi->modelist);
+	}
+#endif
 
 	return ret;
 err5:
@@ -3331,6 +3476,9 @@ static int mxcfb_setup_overlay(struct pl
 		struct fb_info *fbi_bg, struct resource *res)
 {
 	struct fb_info *ovfbi;
+#ifdef CONFIG_MX6_CLK_FOR_BOOTUI_TRANS
+	struct ipuv3_fb_platform_data *plat_data = pdev->dev.platform_data;
+#endif
 	struct mxcfb_info *mxcfbi_bg = (struct mxcfb_info *)fbi_bg->par;
 	struct mxcfb_info *mxcfbi_fg;
 	int ret = 0;
@@ -3359,7 +3507,9 @@ static int mxcfb_setup_overlay(struct pl
 	mxcfbi_fg->prefetch = false;
 	mxcfbi_fg->resolve = false;
 	mxcfbi_fg->pre_num = -1;
-
+#ifdef CONFIG_MX6_CLK_FOR_BOOTUI_TRANS
+	mxcfbi_fg->late_init = plat_data->late_init;
+#endif
 	/* Need dummy values until real panel is configured */
 	ovfbi->var.xres = 240;
 	ovfbi->var.yres = 320;
@@ -3426,6 +3576,9 @@ static int mxcfb_get_of_property(struct
 	int len;
 	u32 bpp, int_clk;
 	u32 late_init;
+#ifdef CONFIG_MX6_CLK_FOR_BOOTUI_TRANS
+	u32 fb_base, fb_size;
+#endif
 
 	err = of_property_read_string(np, "disp_dev", &disp_dev);
 	if (err < 0) {
@@ -3455,7 +3608,17 @@ static int mxcfb_get_of_property(struct
 		dev_dbg(&pdev->dev, "get of property late_init fail\n");
 		return err;
 	}
+#ifdef CONFIG_MX6_CLK_FOR_BOOTUI_TRANS
+	err = of_property_read_u32(np, "fb_base", &fb_base);
+	if (err) {
+		fb_base = 0;
+	}
 
+	err = of_property_read_u32(np, "fb_size", &fb_size);
+	if (err) {
+		fb_size = 0;
+	}
+#endif
 	plat_data->prefetch = of_property_read_bool(np, "prefetch");
 
 	if (!strncmp(pixfmt, "RGB24", 5))
@@ -3492,6 +3655,10 @@ static int mxcfb_get_of_property(struct
 	plat_data->default_bpp = bpp;
 	plat_data->int_clk = (bool)int_clk;
 	plat_data->late_init = (bool)late_init;
+#ifdef CONFIG_MX6_CLK_FOR_BOOTUI_TRANS
+	plat_data->res_base[0] = fb_base;
+	plat_data->res_size[0] = fb_size;
+#endif
 	return err;
 }
 
@@ -3508,7 +3675,6 @@ static int mxcfb_probe(struct platform_d
 	struct ipuv3_fb_platform_data *plat_data;
 	struct fb_info *fbi;
 	struct mxcfb_info *mxcfbi;
-	struct device *disp_dev;
 	struct resource *res;
 	int ret = 0;
 
@@ -3532,6 +3698,7 @@ static int mxcfb_probe(struct platform_d
 	}
 
 #if defined(CONFIG_OF) && defined(CONFIG_ARCH_ADVANTECH)
+#ifndef CONFIG_MX6_CLK_FOR_BOOTUI_TRANS
 	if(first_power_on) {
 		printk(KERN_INFO "[LVDS Sequence] 1 Start to enable LVDS VDD.\n");
 
@@ -3540,6 +3707,7 @@ static int mxcfb_probe(struct platform_d
 		printk(KERN_INFO "[LVDS Sequence] 2 Start to enable LVDS signal.\n");
 	}
 #endif
+#endif
 
 	/* Initialize FB structures */
 	fbi = mxcfb_init_fbinfo(&pdev->dev, &mxcfb_ops);
@@ -3558,6 +3726,10 @@ static int mxcfb_probe(struct platform_d
 	mxcfbi->first_set_par = true;
 	mxcfbi->prefetch = plat_data->prefetch;
 	mxcfbi->pre_num = -1;
+#ifdef CONFIG_MX6_CLK_FOR_BOOTUI_TRANS
+	mxcfbi->late_init = plat_data->late_init;
+	mxcfbi->late_init_idmac_done = false;
+#endif
 	spin_lock_init(&mxcfbi->spin_lock);
 
 	ret = mxcfb_dispdrv_init(pdev, fbi);
@@ -3570,6 +3742,16 @@ static int mxcfb_probe(struct platform_d
 				mxcfbi->ipu_id, mxcfbi->ipu_di);
 		goto ipu_in_busy;
 	}
+#ifdef CONFIG_MX6_CLK_FOR_BOOTUI_TRANS
+	if (plat_data->res_base[0] && plat_data->res_size[0]) {
+		fbi->fix.smem_len = plat_data->res_size[0];
+		fbi->fix.smem_start = plat_data->res_base[0];
+		fbi->screen_base = ioremap(fbi->fix.smem_start, fbi->fix.smem_len);
+		/* Do not clear the fb content drawn in bootloader. */
+		if (!mxcfbi->late_init)
+			memset(fbi->screen_base, 0, fbi->fix.smem_len);
+	}
+#else
 
 	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
 	if (res && res->start && res->end) {
@@ -3580,7 +3762,7 @@ static int mxcfb_probe(struct platform_d
 		if (!mxcfbi->late_init)
 			memset(fbi->screen_base, 0, fbi->fix.smem_len);
 	}
-
+#endif
 	mxcfbi->ipu = ipu_get_soc(mxcfbi->ipu_id);
 	if (IS_ERR(mxcfbi->ipu)) {
 		ret = -ENODEV;
@@ -3595,6 +3777,7 @@ static int mxcfb_probe(struct platform_d
 		mxcfbi->ipu_ch = MEM_BG_SYNC;
 
 #ifdef CONFIG_ARCH_ADVANTECH
+#ifndef CONFIG_MX6_CLK_FOR_BOOTUI_TRANS
 		/* Unblank all the fb by default */
 		mxcfbi->cur_blank = mxcfbi->next_blank = FB_BLANK_UNBLANK;
 #else
@@ -3604,14 +3787,31 @@ static int mxcfb_probe(struct platform_d
 		else
 			mxcfbi->cur_blank = mxcfbi->next_blank = FB_BLANK_POWERDOWN;
 #endif
+#else
+		/* Unblank the primary fb only by default */
+		if (pdev->id == 0)
+			mxcfbi->cur_blank = mxcfbi->next_blank = FB_BLANK_UNBLANK;
+		else
+			mxcfbi->cur_blank = mxcfbi->next_blank = FB_BLANK_POWERDOWN;
+#endif
 
 		ret = mxcfb_register(fbi);
 		if (ret < 0)
 			goto mxcfb_register_failed;
+#ifdef CONFIG_MX6_CLK_FOR_BOOTUI_TRANS
+		if (mxcfbi->late_init) {
+			ipu_disp_set_global_alpha_late_init(mxcfbi->ipu, mxcfbi->ipu_ch,
+						  true, 0x80);
+			ipu_disp_set_color_key_late_init(mxcfbi->ipu, mxcfbi->ipu_ch, false, 0);
+		} else {
+#endif
 
 		ipu_disp_set_global_alpha(mxcfbi->ipu, mxcfbi->ipu_ch,
 					  true, 0x80);
 		ipu_disp_set_color_key(mxcfbi->ipu, mxcfbi->ipu_ch, false, 0);
+#ifdef CONFIG_MX6_CLK_FOR_BOOTUI_TRANS
+		}
+#endif
 
 		res = platform_get_resource(pdev, IORESOURCE_MEM, 1);
 		ret = mxcfb_setup_overlay(pdev, fbi, res);
@@ -3660,15 +3860,6 @@ static int mxcfb_probe(struct platform_d
 		dev_err(&pdev->dev, "Error %d on creating file for disp "
 				    " device propety\n", ret);
 
-	disp_dev = mxc_dispdrv_getdev(mxcfbi->dispdrv);
-	if (disp_dev) {
-		ret = sysfs_create_link(&fbi->dev->kobj,
-					&disp_dev->kobj, "disp_dev");
-		if (ret)
-			dev_err(&pdev->dev,
-					"Error %d on creating file\n", ret);
-	}
-
 	return 0;
 
 mxcfb_setupoverlay_failed:
diff -ruNp kernel_imx/include/linux/ipu-v3.h kernel_imx-hdmi-lcd-lvds/include/linux/ipu-v3.h
--- kernel_imx/include/linux/ipu-v3.h	2017-05-23 10:51:02.000000000 +0800
+++ kernel_imx-hdmi-lcd-lvds/include/linux/ipu-v3.h	2018-03-26 11:28:40.125689038 +0800
@@ -767,4 +767,27 @@ struct ipuv3_fb_platform_data {
 	bool				resolve;
 };
 
+#ifdef CONFIG_MX6_CLK_FOR_BOOTUI_TRANS
+void ipu_disable_irq_late_init(struct ipu_soc *ipu, uint32_t irq);
+void ipu_clear_irq_late_init(struct ipu_soc *ipu, uint32_t irq);
+int ipu_request_irq_late_init(struct ipu_soc *ipu, uint32_t irq,
+                                irqreturn_t(*handler) (int, void *),
+                                uint32_t irq_flags, const char *devname, void *dev_id);
+int32_t ipu_disp_get_window_pos_late_init(struct ipu_soc *ipu, ipu_channel_t channel, int16_t *x_pos,
+                                int16_t *y_pos);
+int32_t ipu_disp_set_global_alpha_late_init(struct ipu_soc *ipu, ipu_channel_t channel, bool enable,
+                                  uint8_t alpha);
+int32_t ipu_disp_set_color_key_late_init(struct ipu_soc *ipu, ipu_channel_t channel, bool enable,
+                               uint32_t colorKey);
+int32_t ipu_init_channel_late_init(struct ipu_soc *ipu, ipu_channel_t channel, ipu_channel_params_t *params);
+int32_t ipu_init_channel_buffer_late_init(struct ipu_soc *ipu, ipu_channel_t channel, ipu_buffer_t type,
+                                uint32_t pixel_fmt,
+                                uint16_t width, uint16_t height,
+                                uint32_t stride,
+                                ipu_rotate_mode_t rot_mode,
+                                dma_addr_t phyaddr_0, dma_addr_t phyaddr_1,
+                                dma_addr_t phyaddr_2,
+                                uint32_t u, uint32_t v);
+#endif
+
 #endif /* __LINUX_IPU_V3_H_ */
diff -ruNp kernel_imx/include/linux/pwm_backlight.h kernel_imx-hdmi-lcd-lvds/include/linux/pwm_backlight.h
--- kernel_imx/include/linux/pwm_backlight.h	2017-05-23 10:51:03.000000000 +0800
+++ kernel_imx-hdmi-lcd-lvds/include/linux/pwm_backlight.h	2018-03-28 14:05:33.502425943 +0800
@@ -20,6 +20,7 @@ struct platform_pwm_backlight_data {
 	void (*notify_after)(struct device *dev, int brightness);
 	void (*exit)(struct device *dev);
 	int (*check_fb)(struct device *dev, struct fb_info *info);
+	char fb_id[16];
 };
 
 #endif

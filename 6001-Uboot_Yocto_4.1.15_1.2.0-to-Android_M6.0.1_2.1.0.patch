From c017fd60491a0477359618addf59e6520d374171 Mon Sep 17 00:00:00 2001
From: clayderhua <clayderhua@gmail.com>
Date: Sat, 22 Oct 2016 23:08:56 +0800
Subject: [PATCH] android patch

---
 .checkpatch.conf                                   |   23 +
 .travis.yml                                        |  220 ++++
 arch/arm/cpu/armv7/mx6/Kconfig                     |   10 +
 arch/arm/cpu/armv7/mx6/clock.c                     |   20 +-
 arch/arm/cpu/armv7/mx6/soc.c                       |   26 +-
 arch/arm/imx-common/cpu.c                          |    4 +-
 arch/arm/imx-common/timer.c                        |    9 +-
 arch/arm/include/asm/arch-imx/cpu.h                |    3 +-
 arch/arm/include/asm/arch-mx6/crm_regs.h           |  102 +-
 arch/arm/include/asm/arch-mx6/imx-regs.h           |   18 +-
 arch/arm/include/asm/arch-mx6/mx6-pins.h           |    4 +-
 arch/arm/include/asm/arch-mx6/mx6ull_pins.h        | 1062 ++++++++++++++++++++
 arch/arm/include/asm/arch-mx7/mx7d_pins.h          |    8 +-
 arch/arm/include/asm/imx-common/regs-bch.h         |    6 +-
 board/freescale/common/recovery.c                  |    7 +-
 board/freescale/mx6qarm2/mt128x64mx32.cfg          |    4 +-
 board/freescale/mx6qarm2/mx6qarm2.c                |    9 +
 board/freescale/mx6sabresd/mx6sabresd.c            |   10 -
 board/freescale/mx6ul_14x14_evk/mx6ul_14x14_evk.c  |    2 +-
 board/freescale/mx6ull_ddr3_arm2/Kconfig           |   12 +
 board/freescale/mx6ull_ddr3_arm2/Makefile          |   10 +
 board/freescale/mx6ull_ddr3_arm2/imximage.cfg      |  114 +++
 .../freescale/mx6ull_ddr3_arm2/mx6ull_ddr3_arm2.c  |  949 +++++++++++++++++
 board/freescale/mx6ull_ddr3_arm2/plugin.S          |  136 +++
 common/cmd_read.c                                  |    4 +-
 common/image-android.c                             |   13 +
 common/usb_storage.c                               |    4 +-
 configs/mx6qarm2_pop_lpddr2_revb_defconfig         |    2 +-
 configs/mx6ul_14x14_evk_brillo_defconfig           |    5 +
 configs/mx6ull_ddr3_arm2_defconfig                 |    9 +
 drivers/misc/mxc_ocotp.c                           |   43 +-
 drivers/misc/mxc_ocotp.c.orig                      |  339 +++++++
 drivers/mtd/nand/mxs_nand.c                        |   64 +-
 drivers/usb/gadget/Makefile                        |    2 +
 drivers/usb/gadget/bcb.c                           |  177 ++++
 drivers/usb/gadget/bcb.h                           |   38 +
 drivers/usb/gadget/bootctrl.c                      |  346 +++++++
 drivers/usb/gadget/bootctrl.h                      |   37 +
 drivers/usb/gadget/command.c                       |  105 ++
 drivers/usb/gadget/f_fastboot.c                    |  147 ++-
 include/common.h                                   |    4 +
 include/configs/mx6qarm2.h                         |   14 +-
 include/configs/mx6sabre_common.h                  |    6 +-
 include/configs/mx6sabreandroid_common.h           |   10 +-
 include/configs/mx6slevkandroid.h                  |   10 +-
 include/configs/mx6sx_arm2.h                       |    4 +-
 include/configs/mx6sxsabreauto.h                   |    4 +-
 include/configs/mx6sxsabreautoandroid.h            |   10 +-
 include/configs/mx6sxsabresdandroid.h              |   10 +-
 include/configs/mx6ul_14x14_evk.h                  |    9 +-
 include/configs/mx6ul_14x14_evk_android.h          |    3 +-
 include/configs/mx6ul_14x14_evk_brillo.h           |   10 +-
 include/configs/mx6ul_arm2.h                       |    6 +-
 include/configs/mx6ull_ddr3_arm2.h                 |   70 ++
 include/configs/mx7d_arm2.h                        |    4 +-
 include/configs/mx7dsabresd.h                      |    4 +-
 include/configs/mx7dsabresdandroid.h               |   10 +-
 include/configs/picosom-imx6ul.h                   |    2 +-
 include/fsl_fastboot.h                             |   16 +-
 include/recovery.h                                 |    3 +-
 60 files changed, 4105 insertions(+), 207 deletions(-)
 create mode 100644 .checkpatch.conf
 create mode 100644 .travis.yml
 create mode 100644 arch/arm/include/asm/arch-mx6/mx6ull_pins.h
 create mode 100644 board/freescale/mx6ull_ddr3_arm2/Kconfig
 create mode 100644 board/freescale/mx6ull_ddr3_arm2/Makefile
 create mode 100644 board/freescale/mx6ull_ddr3_arm2/imximage.cfg
 create mode 100644 board/freescale/mx6ull_ddr3_arm2/mx6ull_ddr3_arm2.c
 create mode 100644 board/freescale/mx6ull_ddr3_arm2/plugin.S
 create mode 100644 configs/mx6ul_14x14_evk_brillo_defconfig
 create mode 100644 configs/mx6ull_ddr3_arm2_defconfig
 create mode 100644 drivers/misc/mxc_ocotp.c.orig
 create mode 100644 drivers/usb/gadget/bcb.c
 create mode 100644 drivers/usb/gadget/bcb.h
 create mode 100644 drivers/usb/gadget/bootctrl.c
 create mode 100644 drivers/usb/gadget/bootctrl.h
 create mode 100644 drivers/usb/gadget/command.c
 create mode 100644 include/configs/mx6ull_ddr3_arm2.h

diff --git a/.checkpatch.conf b/.checkpatch.conf
new file mode 100644
index 0000000..35167e1
--- /dev/null
+++ b/.checkpatch.conf
@@ -0,0 +1,23 @@
+# Not Linux, so don't expect a Linux tree.
+--no-tree
+
+# Temporary for false positive in checkpatch
+--ignore COMPLEX_MACRO
+
+# For CONFIG_SYS_I2C_NOPROBES
+--ignore MULTISTATEMENT_MACRO_USE_DO_WHILE
+
+# For simple_strtoul
+--ignore CONSIDER_KSTRTO
+
+# For min/max
+--ignore MINMAX
+
+# enable more tests
+--strict
+
+# Not Linux, so we don't recommend usleep_range() over udelay()
+--ignore USLEEP_RANGE
+
+# Ignore networking block comment style
+--ignore NETWORKING_BLOCK_COMMENT_STYLE
diff --git a/.travis.yml b/.travis.yml
new file mode 100644
index 0000000..4e20e09
--- /dev/null
+++ b/.travis.yml
@@ -0,0 +1,220 @@
+# Copyright Roger Meier <r.meier@siemens.com>
+# SPDX-License-Identifier:	GPL-2.0+
+
+# build U-Boot on Travis CI - https://travis-ci.org/
+
+language: c
+
+cache:
+ - apt
+
+install:
+ # install U-Boot build dependencies
+ - sudo apt-get install -qq cppcheck sloccount sparse bc libsdl-dev build-essential
+ # install latest device tree compiler
+ - git clone --depth=1 https://git.kernel.org/pub/scm/utils/dtc/dtc.git /tmp/dtc
+ - make -j4 -C /tmp/dtc
+ # prepare buildman environment
+ - export BUILDMAN_ROOT="root:"
+ - export BUILDMAN_MIPS="mips:"
+ - export BUILDMAN_PPC="ppc:"
+ - export BUILDMAN_ARM="arm:"
+ - export BUILDMAN_SANDBOX="sandbox:"
+ - echo -e "[toolchain]\n${BUILDMAN_ROOT} /\n" > ~/.buildman
+ - echo -e "${BUILDMAN_MIPS} /opt/eldk-5.4/mips/sysroots/i686-eldk-linux/usr/bin/mips32-linux/\n" >> ~/.buildman
+ - echo -e "${BUILDMAN_PPC} /opt/eldk-5.4/powerpc/sysroots/i686-eldk-linux/usr/bin/powerpc-linux/\n" >> ~/.buildman
+ - echo -e "${BUILDMAN_ARM} /opt/eldk-5.4/armv5te/sysroots/i686-eldk-linux/usr/bin/armv5te-linux-gnueabi/\n" >> ~/.buildman
+ - echo -e "${BUILDMAN_SANDBOX} /usr/bin/gcc\n" >> ~/.buildman
+ - export BUILDMAN_ALIAS="x86:"
+ - export BUILDMAN_ALIAS_ARM="arm:"
+ - echo -e "\n\n[toolchain-alias]\n${BUILDMAN_ALIAS} i386\n" >> ~/.buildman
+ - echo -e "${BUILDMAN_ALIAS_ARM} armv5te\n" >> ~/.buildman
+ - cat ~/.buildman
+
+env:
+  global:
+    - PATH=/tmp/dtc:$PATH
+    - BUILD_DIR=build
+    - CROSS_COMPILE=""
+    - HOSTCC="cc"
+    - HOSTCXX="c++"
+    - TEST_CONFIG_CMD=""
+
+before_script:
+  # install toolchains based on INSTALL_TOOLCHAIN} variable
+  - if [[ "${INSTALL_TOOLCHAIN}" == *arm* ]]; then wget ftp://ftp.denx.de/pub/eldk/5.4/targets/armv5te/eldk-eglibc-i686-arm-toolchain-gmae-5.4.sh ; fi
+  - if [[ "${INSTALL_TOOLCHAIN}" == *arm* ]]; then sh eldk-eglibc-i686-arm-toolchain-gmae-5.4.sh -y ; fi
+  - if [[ "${INSTALL_TOOLCHAIN}" == *arm* ]]; then ls -al /opt/eldk-5.4/armv5te/sysroots/i686-eldk-linux/usr/bin/armv5te-linux-gnueabi ; fi
+  - if [[ "${INSTALL_TOOLCHAIN}" == *avr32* ]]; then ./tools/buildman/buildman --fetch-arch avr32 ; fi
+  - if [[ "${INSTALL_TOOLCHAIN}" == *i386* ]]; then ./tools/buildman/buildman sandbox --fetch-arch i386 ; fi
+  - if [[ "${INSTALL_TOOLCHAIN}" == *m68k* ]]; then ./tools/buildman/buildman --fetch-arch m68k ; fi
+  - if [[ "${INSTALL_TOOLCHAIN}" == *mips* ]]; then wget ftp://ftp.denx.de/pub/eldk/5.4/targets/mips/eldk-eglibc-i686-mips-toolchain-gmae-5.4.sh ; fi
+  - if [[ "${INSTALL_TOOLCHAIN}" == *mips* ]]; then sh eldk-eglibc-i686-mips-toolchain-gmae-5.4.sh -y ; fi
+  - if [[ "${INSTALL_TOOLCHAIN}" == *ppc* ]]; then wget ftp://ftp.denx.de/pub/eldk/5.4/targets/powerpc/eldk-eglibc-i686-powerpc-toolchain-gmae-5.4.sh ; fi
+  - if [[ "${INSTALL_TOOLCHAIN}" == *ppc* ]]; then sh eldk-eglibc-i686-powerpc-toolchain-gmae-5.4.sh -y ; fi
+
+script:
+ # the execution sequence for each test
+ - echo ${TEST_CONFIG_CMD}
+ - ${TEST_CONFIG_CMD}
+ - echo ${TEST_CMD}
+ - ${TEST_CMD}
+
+matrix:
+  include:
+  # we need to build by vendor due to 50min time limit for builds
+  # each env setting here is a dedicated build
+    - env:
+        - TEST_CMD="./MAKEALL -a arm -v atmel"
+          INSTALL_TOOLCHAIN="arm"
+          CROSS_COMPILE="/opt/eldk-5.4/armv5te/sysroots/i686-eldk-linux/usr/bin/armv5te-linux-gnueabi/arm-linux-gnueabi-"
+    - env:
+        - TEST_CMD="./MAKEALL -a arm -v denx"
+          INSTALL_TOOLCHAIN="arm"
+          CROSS_COMPILE="/opt/eldk-5.4/armv5te/sysroots/i686-eldk-linux/usr/bin/armv5te-linux-gnueabi/arm-linux-gnueabi-"
+    - env:
+        - TEST_CMD="./MAKEALL -a arm -v freescale"
+          INSTALL_TOOLCHAIN="arm"
+          CROSS_COMPILE="/opt/eldk-5.4/armv5te/sysroots/i686-eldk-linux/usr/bin/armv5te-linux-gnueabi/arm-linux-gnueabi-"
+    - env:
+        - TEST_CMD="./MAKEALL -a arm -v siemens"
+          INSTALL_TOOLCHAIN="arm"
+          CROSS_COMPILE="/opt/eldk-5.4/armv5te/sysroots/i686-eldk-linux/usr/bin/armv5te-linux-gnueabi/arm-linux-gnueabi-"
+    - env:
+        - TEST_CMD="./MAKEALL -a arm -v ti"
+          INSTALL_TOOLCHAIN="arm"
+          CROSS_COMPILE="/opt/eldk-5.4/armv5te/sysroots/i686-eldk-linux/usr/bin/armv5te-linux-gnueabi/arm-linux-gnueabi-"
+    - env:
+        - TEST_CONFIG_CMD="make sandbox_defconfig"
+          TEST_CMD="make -j4"
+          HOSTCC  = "gcc"
+          HOSTCXX  = "g++"
+    - env:
+        - TEST_CONFIG_CMD="make sandbox_defconfig"
+          TEST_CMD="make -j4"
+          HOSTCC  = "clang"
+          HOSTCXX  = "clang++"
+    - env:
+        - TEST_CMD="./MAKEALL -a mips"
+          INSTALL_TOOLCHAIN="mips"
+          CROSS_COMPILE="/opt/eldk-5.4/mips/sysroots/i686-eldk-linux/usr/bin/mips32-linux/mips-linux-"
+    - env:
+        - TEST_CONFIG_CMD="tools/buildman/buildman --list-tool-chains"
+          TEST_CMD="tools/buildman/buildman --list-error-boards arm1136"
+          INSTALL_TOOLCHAIN="arm"
+    - env:
+        - TEST_CONFIG_CMD="tools/buildman/buildman --list-tool-chains"
+          TEST_CMD="tools/buildman/buildman --list-error-boards arm1176"
+          INSTALL_TOOLCHAIN="arm"
+    - env:
+        - TEST_CONFIG_CMD="tools/buildman/buildman --list-tool-chains"
+          TEST_CMD="tools/buildman/buildman --list-error-boards arm720t"
+          INSTALL_TOOLCHAIN="arm"
+    - env:
+        - TEST_CONFIG_CMD="tools/buildman/buildman --list-tool-chains"
+          TEST_CMD="tools/buildman/buildman --list-error-boards arm920t"
+          INSTALL_TOOLCHAIN="arm"
+    - env:
+        - TEST_CONFIG_CMD="tools/buildman/buildman --list-tool-chains"
+          TEST_CMD="tools/buildman/buildman --list-error-boards atmel -x avr32"
+          INSTALL_TOOLCHAIN="arm"
+    - env:
+        - TEST_CONFIG_CMD="tools/buildman/buildman --list-tool-chains"
+          TEST_CMD="tools/buildman/buildman --list-error-boards avr32"
+          INSTALL_TOOLCHAIN="avr32"
+    - env:
+        - TEST_CONFIG_CMD="tools/buildman/buildman --list-tool-chains"
+          TEST_CMD="tools/buildman/buildman --list-error-boards davinci"
+          INSTALL_TOOLCHAIN="arm"
+    - env:
+        - TEST_CONFIG_CMD="tools/buildman/buildman --list-tool-chains"
+          TEST_CMD="tools/buildman/buildman --list-error-boards denx"
+          INSTALL_TOOLCHAIN="arm"
+    - env:
+        - TEST_CONFIG_CMD="tools/buildman/buildman --list-tool-chains"
+          TEST_CMD="tools/buildman/buildman --list-error-boards freescale -x powerpc,m68k,aarch64"
+          INSTALL_TOOLCHAIN="arm"
+    - env:
+        - TEST_CONFIG_CMD="tools/buildman/buildman --list-tool-chains"
+          TEST_CMD="tools/buildman/buildman --list-error-boards freescale -x arm,m68k,aarch64"
+          INSTALL_TOOLCHAIN="ppc"
+    - env:
+        - TEST_CONFIG_CMD="tools/buildman/buildman --list-tool-chains"
+          TEST_CMD="tools/buildman/buildman --list-error-boards sandbox x86"
+          INSTALL_TOOLCHAIN="i386"
+    - env:
+        - TEST_CONFIG_CMD="tools/buildman/buildman --list-tool-chains"
+          TEST_CMD="tools/buildman/buildman --list-error-boards kirkwood"
+          INSTALL_TOOLCHAIN="arm"
+    - env:
+        - TEST_CONFIG_CMD="tools/buildman/buildman --list-tool-chains"
+          TEST_CMD="tools/buildman/buildman --list-error-boards m68k"
+          INSTALL_TOOLCHAIN="m68k"
+    - env:
+        - TEST_CONFIG_CMD="tools/buildman/buildman --list-tool-chains"
+          TEST_CMD="tools/buildman/buildman mips"
+          INSTALL_TOOLCHAIN="mips"
+    - env:
+        - TEST_CONFIG_CMD="tools/buildman/buildman --list-tool-chains"
+          TEST_CMD="tools/buildman/buildman mpc512x"
+          INSTALL_TOOLCHAIN="ppc"
+    - env:
+        - TEST_CONFIG_CMD="tools/buildman/buildman --list-tool-chains"
+          TEST_CMD="tools/buildman/buildman mpc5xx"
+          INSTALL_TOOLCHAIN="ppc"
+    - env:
+        - TEST_CONFIG_CMD="tools/buildman/buildman --list-tool-chains"
+          TEST_CMD="tools/buildman/buildman mpc5xxx"
+          INSTALL_TOOLCHAIN="ppc"
+    - env:
+        - TEST_CONFIG_CMD="tools/buildman/buildman --list-tool-chains"
+          TEST_CMD="tools/buildman/buildman mpc8260"
+          INSTALL_TOOLCHAIN="ppc"
+    - env:
+        - TEST_CONFIG_CMD="tools/buildman/buildman --list-tool-chains"
+          TEST_CMD="tools/buildman/buildman mpc83xx"
+          INSTALL_TOOLCHAIN="ppc"
+    - env:
+        - TEST_CONFIG_CMD="tools/buildman/buildman --list-tool-chains"
+          TEST_CMD="tools/buildman/buildman mpc85xx"
+          INSTALL_TOOLCHAIN="ppc"
+    - env:
+        - TEST_CONFIG_CMD="tools/buildman/buildman --list-tool-chains"
+          TEST_CMD="tools/buildman/buildman mpc86xx"
+          INSTALL_TOOLCHAIN="ppc"
+    - env:
+        - TEST_CONFIG_CMD="tools/buildman/buildman --list-tool-chains"
+          TEST_CMD="tools/buildman/buildman mpc8xx"
+          INSTALL_TOOLCHAIN="ppc"
+    - env:
+        - TEST_CONFIG_CMD="tools/buildman/buildman --list-tool-chains"
+          TEST_CMD="tools/buildman/buildman --list-error-boards siemens"
+          INSTALL_TOOLCHAIN="arm"
+    - env:
+        - TEST_CONFIG_CMD="tools/buildman/buildman --list-tool-chains"
+          TEST_CMD="tools/buildman/buildman --list-error-boards ti"
+          INSTALL_TOOLCHAIN="arm"
+
+    # QA jobs for code analytics
+    # static code analysis with cppcheck (we can add --enable=all later)
+    - env:
+        - TEST_CMD="cppcheck --force --quiet --inline-suppr ."
+    # search for TODO within source tree
+    - env:
+        - TEST_CMD="grep -r TODO ."
+    # search for FIXME within source tree
+    - env:
+        - TEST_CMD="grep -r FIXME ."
+    # search for HACK within source tree and ignore HACKKIT board
+    - env:
+        - TEST_CMD="grep -r HACK . | grep -v HACKKIT"
+      script:
+        - grep -r HACK . | grep -v HACKKIT
+    # some statistics about the code base
+    - env:
+        - TEST_CMD="sloccount ."
+
+notifications:
+  email: false
+
+# TODO make it perfect ;-r
diff --git a/arch/arm/cpu/armv7/mx6/Kconfig b/arch/arm/cpu/armv7/mx6/Kconfig
index 2161a5e..5e82078 100644
--- a/arch/arm/cpu/armv7/mx6/Kconfig
+++ b/arch/arm/cpu/armv7/mx6/Kconfig
@@ -28,9 +28,18 @@ config MX6SX
 config MX6UL
 	bool
 
+config MX6ULL
+	bool
+	select MX6UL
+
 choice
 	prompt "MX6 board select"
 
+config TARGET_MX6ULL_DDR3_ARM2
+	bool "Support mx6ull_ddr3_arm2"
+	select CPU_V7
+	select MX6ULL
+
 config TARGET_SECOMX6
 	bool "Support secomx6 boards"
 	select CPU_V7
@@ -41,5 +50,6 @@ config SYS_SOC
 	default "mx6"
 
 source "board/seco/Kconfig"
+source "board/freescale/mx6ull_ddr3_arm2/Kconfig"
 
 endif
diff --git a/arch/arm/cpu/armv7/mx6/clock.c b/arch/arm/cpu/armv7/mx6/clock.c
index 5f0037a..1cc910b 100644
--- a/arch/arm/cpu/armv7/mx6/clock.c
+++ b/arch/arm/cpu/armv7/mx6/clock.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2010-2015 Freescale Semiconductor, Inc.
+ * Copyright (C) 2010-2016 Freescale Semiconductor, Inc.
  *
  * SPDX-License-Identifier:	GPL-2.0+
  */
@@ -96,7 +96,13 @@ void enable_usboh3_clk(unsigned char enable)
 #if defined(CONFIG_FEC_MXC) && !defined(CONFIG_MX6SX)
 void enable_enet_clk(unsigned char enable)
 {
-#ifdef CONFIG_MX6UL
+#ifdef CONFIG_MX6ULL
+	u32 mask = MXC_CCM_CCGR0_ENET_CLK_ENABLE_MASK;
+	if (enable)
+		setbits_le32(&imx_ccm->CCGR0, mask);
+	else
+		clrbits_le32(&imx_ccm->CCGR0, mask);
+#elif defined(CONFIG_MX6UL)
 	u32 mask = MXC_CCM_CCGR3_ENET_CLK_ENABLE_MASK;
 	/* Set AHB clk, since enet clock is sourced from AHB and IPG */
 	/* ROM has set AHB, just leave here empty */
@@ -1164,6 +1170,15 @@ void hab_caam_clock_enable(unsigned char enable)
 {
 	u32 reg;
 
+#if defined(CONFIG_MX6ULL)
+	/* CG5, DCP clock */
+	reg = __raw_readl(&imx_ccm->CCGR0);
+	if (enable)
+		reg |= MXC_CCM_CCGR0_DCP_CLK_MASK;
+	else
+		reg &= ~MXC_CCM_CCGR0_DCP_CLK_MASK;
+	__raw_writel(reg, &imx_ccm->CCGR0);
+#else
 	/* CG4 ~ CG6, CAAM clocks */
 	reg = __raw_readl(&imx_ccm->CCGR0);
 	if (enable)
@@ -1175,6 +1190,7 @@ void hab_caam_clock_enable(unsigned char enable)
 			MXC_CCM_CCGR0_CAAM_WRAPPER_ACLK_MASK |
 			MXC_CCM_CCGR0_CAAM_SECURE_MEM_MASK);
 	__raw_writel(reg, &imx_ccm->CCGR0);
+#endif
 
 	/* EMI slow clk */
 	reg = __raw_readl(&imx_ccm->CCGR6);
diff --git a/arch/arm/cpu/armv7/mx6/soc.c b/arch/arm/cpu/armv7/mx6/soc.c
index c725fca..29e1043 100644
--- a/arch/arm/cpu/armv7/mx6/soc.c
+++ b/arch/arm/cpu/armv7/mx6/soc.c
@@ -2,7 +2,7 @@
  * (C) Copyright 2007
  * Sascha Hauer, Pengutronix
  *
- * (C) Copyright 2009-2015 Freescale Semiconductor, Inc.
+ * (C) Copyright 2009-2016 Freescale Semiconductor, Inc.
  *
  * SPDX-License-Identifier:	GPL-2.0+
  */
@@ -110,13 +110,13 @@ u32 __weak get_board_rev(void)
 void init_aips(void)
 {
 	struct aipstz_regs *aips1, *aips2;
-#ifdef CONFIG_MX6SX
+#if defined(CONFIG_MX6SX) || defined(CONFIG_MX6ULL)
 	struct aipstz_regs *aips3;
 #endif
 
 	aips1 = (struct aipstz_regs *)AIPS1_BASE_ADDR;
 	aips2 = (struct aipstz_regs *)AIPS2_BASE_ADDR;
-#ifdef CONFIG_MX6SX
+#if defined(CONFIG_MX6SX) || defined(CONFIG_MX6ULL)
 	aips3 = (struct aipstz_regs *)AIPS3_CONFIG_BASE_ADDR;
 #endif
 
@@ -145,7 +145,7 @@ void init_aips(void)
 	writel(0x00000000, &aips2->opacr3);
 	writel(0x00000000, &aips2->opacr4);
 
-#ifdef CONFIG_MX6SX
+#if defined(CONFIG_MX6SX) || defined(CONFIG_MX6ULL)
 	/*
 	 * Set all MPROTx to be non-bufferable, trusted for R/W,
 	 * not forced to user-mode.
@@ -469,7 +469,7 @@ int arch_cpu_init(void)
 		set_ahb_rate(132000000);
 #endif
 
-#if defined(CONFIG_MX6UL)
+#if !defined(CONFIG_MX6ULL) && defined(CONFIG_MX6UL)
 	if (is_soc_rev(CHIP_REV_1_0) == 0) {
 		/*
 		 * According to the design team's requirement on i.MX6UL,
@@ -489,6 +489,19 @@ int arch_cpu_init(void)
 	}
 #endif
 
+#ifdef CONFIG_MX6ULL
+	/*
+	 * GPBIT[1:0] is suggested to set to 2'b11:
+	 * 2'b00 : always PUP100K
+	 * 2'b01 : PUP100K when PMIC_ON_REQ or SOC_NOT_FAIL
+	 * 2'b10 : always disable PUP100K
+	 * 2'b11 : PDN100K when SOC_FAIL, PUP100K when SOC_NOT_FAIL
+	 * register offset is different from i.MX6UL, since
+	 * i.MX6UL is fixed by ECO.
+	 */
+	writel(readl(SNVS_LP_BASE_ADDR) | 0x3, SNVS_LP_BASE_ADDR);
+#endif
+
 	/* Set perclk to source from OSC 24MHz */
 #if defined(CONFIG_MX6SL)
 	set_preclk_from_osc();
@@ -741,7 +754,8 @@ void s_init(void)
 	u32 mask528;
 	u32 reg, periph1, periph2;
 
-	if (is_cpu_type(MXC_CPU_MX6SX) || is_cpu_type(MXC_CPU_MX6UL))
+	if (is_cpu_type(MXC_CPU_MX6SX) || is_cpu_type(MXC_CPU_MX6UL) ||
+	    is_cpu_type(MXC_CPU_MX6ULL))
 		return;
 
 	/* Due to hardware limitation, on MX6Q we need to gate/ungate all PFDs
diff --git a/arch/arm/imx-common/cpu.c b/arch/arm/imx-common/cpu.c
index 8eb6a5a..0afa93f 100644
--- a/arch/arm/imx-common/cpu.c
+++ b/arch/arm/imx-common/cpu.c
@@ -2,7 +2,7 @@
  * (C) Copyright 2007
  * Sascha Hauer, Pengutronix
  *
- * (C) Copyright 2009-2015 Freescale Semiconductor, Inc.
+ * (C) Copyright 2009-2016 Freescale Semiconductor, Inc.
  *
  * SPDX-License-Identifier:	GPL-2.0+
  */
@@ -153,6 +153,8 @@ const char *get_imx_type(u32 imxtype)
 		return "6SX";   /* SoloX version of the mx6 */
 	case MXC_CPU_MX6UL:
 		return "6UL";	/* UL version of the mx6 */
+	case MXC_CPU_MX6ULL:
+		return "6ULL";	/* ULL version of the mx6 */
 	case MXC_CPU_MX51:
 		return "51";
 	case MXC_CPU_MX53:
diff --git a/arch/arm/imx-common/timer.c b/arch/arm/imx-common/timer.c
index 6fea6fe..e1b6f01 100644
--- a/arch/arm/imx-common/timer.c
+++ b/arch/arm/imx-common/timer.c
@@ -2,7 +2,7 @@
  * (C) Copyright 2007
  * Sascha Hauer, Pengutronix
  *
- * (C) Copyright 2009-2015 Freescale Semiconductor, Inc.
+ * (C) Copyright 2009-2016 Freescale Semiconductor, Inc.
  *
  * SPDX-License-Identifier:	GPL-2.0+
  */
@@ -46,7 +46,7 @@ static inline int gpt_has_clk_source_osc(void)
 	if (((is_cpu_type(MXC_CPU_MX6Q) || is_cpu_type(MXC_CPU_MX6D)) &&
 	     (is_soc_rev(CHIP_REV_1_0) > 0)) || is_cpu_type(MXC_CPU_MX6DL) ||
 	      is_cpu_type(MXC_CPU_MX6SOLO) || is_cpu_type(MXC_CPU_MX6SX) ||
-	      is_cpu_type(MXC_CPU_MX6UL))
+	      is_cpu_type(MXC_CPU_MX6UL) || is_cpu_type(MXC_CPU_MX6ULL))
 		return 1;
 
 	return 0;
@@ -110,12 +110,13 @@ int timer_init(void)
 	if (gpt_has_clk_source_osc()) {
 		i |= GPTCR_CLKSOURCE_OSC | GPTCR_TEN;
 
-		/* For DL/S, SX, UL, set 24Mhz OSC Enable bit and prescaler */
+		/* For DL/S, SX, UL, ULL set 24Mhz OSC Enable bit and prescaler */
 		if (is_cpu_type(MXC_CPU_MX6DL) ||
 		    is_cpu_type(MXC_CPU_MX6SOLO) ||
 		    is_cpu_type(MXC_CPU_MX6SX) ||
 		    is_cpu_type(MXC_CPU_MX7D) ||
-		    is_cpu_type(MXC_CPU_MX6UL)) {
+		    is_cpu_type(MXC_CPU_MX6UL) ||
+		    is_cpu_type(MXC_CPU_MX6ULL)) {
 			i |= GPTCR_24MEN;
 
 			/* Produce 3Mhz clock */
diff --git a/arch/arm/include/asm/arch-imx/cpu.h b/arch/arm/include/asm/arch-imx/cpu.h
index d198906..4ea743b 100644
--- a/arch/arm/include/asm/arch-imx/cpu.h
+++ b/arch/arm/include/asm/arch-imx/cpu.h
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2014-2015 Freescale Semiconductor, Inc.
+ * Copyright (C) 2014-2016 Freescale Semiconductor, Inc.
  *
  * SPDX-License-Identifier:	GPL-2.0+
  */
@@ -11,6 +11,7 @@
 #define MXC_CPU_MX6SX		0x62
 #define MXC_CPU_MX6Q		0x63
 #define MXC_CPU_MX6UL		0x64
+#define MXC_CPU_MX6ULL		0x65
 #define MXC_CPU_MX6SOLO		0x66 /* dummy */
 #define MXC_CPU_MX6D		0x67
 #define MXC_CPU_MX7D		0x72
diff --git a/arch/arm/include/asm/arch-mx6/crm_regs.h b/arch/arm/include/asm/arch-mx6/crm_regs.h
index 0c79842..724ee62 100644
--- a/arch/arm/include/asm/arch-mx6/crm_regs.h
+++ b/arch/arm/include/asm/arch-mx6/crm_regs.h
@@ -1,5 +1,5 @@
 /*
- * Copyright 2011-2015 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2011-2016 Freescale Semiconductor, Inc. All Rights Reserved.
  *
  * SPDX-License-Identifier:	GPL-2.0+
  */
@@ -430,7 +430,16 @@ struct mxc_ccm_reg {
 #define MXC_CCM_CSCDR1_UART_CLK_PODF_OFFSET		0
 
 /* Define the bits in register CS1CDR */
-#ifndef CONFIG_MX6UL
+#if defined(CONFIG_MX6UL) && !defined(CONFIG_MX6ULL)
+#define MXC_CCM_CS1CDR_SAI3_CLK_PRED_MASK		(0x7 << 22)
+#define MXC_CCM_CS1CDR_SAI3_CLK_PRED_OFFSET		22
+#define MXC_CCM_CS1CDR_SAI3_CLK_PODF_MASK		(0x3F << 16)
+#define MXC_CCM_CS1CDR_SAI3_CLK_PODF_OFFSET		16
+#define MXC_CCM_CS1CDR_SAI1_CLK_PRED_MASK		(0x7 << 6)
+#define MXC_CCM_CS1CDR_SAI1_CLK_PRED_OFFSET		6
+#define MXC_CCM_CS1CDR_SAI1_CLK_PODF_MASK		0x3F
+#define MXC_CCM_CS1CDR_SAI1_CLK_PODF_OFFSET		0
+#else
 #define MXC_CCM_CS1CDR_ESAI_CLK_PODF_MASK		(0x3F << 25)
 #define MXC_CCM_CS1CDR_ESAI_CLK_PODF_OFFSET		25
 #define MXC_CCM_CS1CDR_ESAI_CLK_PRED_MASK		(0x3 << 9)
@@ -443,15 +452,6 @@ struct mxc_ccm_reg {
 #define MXC_CCM_CS1CDR_SSI1_CLK_PRED_OFFSET		6
 #define MXC_CCM_CS1CDR_SSI1_CLK_PODF_MASK		0x3F
 #define MXC_CCM_CS1CDR_SSI1_CLK_PODF_OFFSET		0
-#else
-#define MXC_CCM_CS1CDR_SAI3_CLK_PRED_MASK		(0x7 << 22)
-#define MXC_CCM_CS1CDR_SAI3_CLK_PRED_OFFSET		22
-#define MXC_CCM_CS1CDR_SAI3_CLK_PODF_MASK		(0x3F << 16)
-#define MXC_CCM_CS1CDR_SAI3_CLK_PODF_OFFSET		16
-#define MXC_CCM_CS1CDR_SAI1_CLK_PRED_MASK		(0x7 << 6)
-#define MXC_CCM_CS1CDR_SAI1_CLK_PRED_OFFSET		6
-#define MXC_CCM_CS1CDR_SAI1_CLK_PODF_MASK		0x3F
-#define MXC_CCM_CS1CDR_SAI1_CLK_PODF_OFFSET		0
 #endif
 
 /* Define the bits in register CS2CDR */
@@ -530,7 +530,14 @@ struct mxc_ccm_reg {
 #endif
 
 /* Define the bits in register CHSCCDR */
-#ifdef CONFIG_MX6UL
+#ifdef CONFIG_MX6ULL
+#define MXC_CCM_CHSCCDR_EPDC_PRE_CLK_SEL_MASK		(0x7 << 15)
+#define MXC_CCM_CHSCCDR_EPDC_PRE_CLK_SEL_OFFSET		15
+#define MXC_CCM_CHSCCDR_EPDC_PODF_MASK			(0x7 << 12)
+#define MXC_CCM_CHSCCDR_EPDC_PODF_OFFSET			12
+#define MXC_CCM_CHSCCDR_EPDC_CLK_SEL_MASK		(0x7 << 9)
+#define MXC_CCM_CHSCCDR_EPDC_CLK_SEL_OFFSET		9
+#elif defined(CONFIG_MX6UL)
 #define MXC_CCM_CHSCCDR_SIM_PRE_CLK_SEL_MASK		(0x7 << 15)
 #define MXC_CCM_CHSCCDR_SIM_PRE_CLK_SEL_OFFSET		15
 #define MXC_CCM_CHSCCDR_SIM_PODF_MASK			(0x7 << 12)
@@ -733,12 +740,20 @@ struct mxc_ccm_reg {
 #define MXC_CCM_CCGR0_APBHDMA_MASK			(3 << MXC_CCM_CCGR0_APBHDMA_OFFSET)
 #define MXC_CCM_CCGR0_ASRC_OFFSET			6
 #define MXC_CCM_CCGR0_ASRC_MASK				(3 << MXC_CCM_CCGR0_ASRC_OFFSET)
+
+#ifdef CONFIG_MX6ULL
+#define MXC_CCM_CCGR0_DCP_CLK_OFFSET		10
+#define MXC_CCM_CCGR0_DCP_CLK_MASK		(3 << MXC_CCM_CCGR0_DCP_CLK_OFFSET)
+#define MXC_CCM_CCGR0_ENET_CLK_ENABLE_OFFSET		12
+#define MXC_CCM_CCGR0_ENET_CLK_ENABLE_MASK		(3 << MXC_CCM_CCGR0_ENET_CLK_ENABLE_OFFSET)
+#else
 #define MXC_CCM_CCGR0_CAAM_SECURE_MEM_OFFSET		8
 #define MXC_CCM_CCGR0_CAAM_SECURE_MEM_MASK		(3 << MXC_CCM_CCGR0_CAAM_SECURE_MEM_OFFSET)
 #define MXC_CCM_CCGR0_CAAM_WRAPPER_ACLK_OFFSET		10
 #define MXC_CCM_CCGR0_CAAM_WRAPPER_ACLK_MASK		(3 << MXC_CCM_CCGR0_CAAM_WRAPPER_ACLK_OFFSET)
 #define MXC_CCM_CCGR0_CAAM_WRAPPER_IPG_OFFSET		12
 #define MXC_CCM_CCGR0_CAAM_WRAPPER_IPG_MASK		(3 << MXC_CCM_CCGR0_CAAM_WRAPPER_IPG_OFFSET)
+#endif
 #define MXC_CCM_CCGR0_CAN1_OFFSET			14
 #define MXC_CCM_CCGR0_CAN1_MASK				(3 << MXC_CCM_CCGR0_CAN1_OFFSET)
 #define MXC_CCM_CCGR0_CAN1_SERIAL_OFFSET		16
@@ -839,17 +854,24 @@ struct mxc_ccm_reg {
 #define MXC_CCM_CCGR1_GPIO5_CLK_ENABLE_MASK		3 << (MXC_CCM_CCGR1_GPIO5_CLK_ENABLE_OFFSET)
 #endif
 
-#ifndef CONFIG_MX6SX
+#if !defined(CONFIG_MX6SX) && !defined(CONFIG_MX6UL)
 #define MXC_CCM_CCGR2_HDMI_TX_IAHBCLK_OFFSET		0
 #define MXC_CCM_CCGR2_HDMI_TX_IAHBCLK_MASK		(3 << MXC_CCM_CCGR2_HDMI_TX_IAHBCLK_OFFSET)
-#else
-#define MXC_CCM_CCGR2_CSI_OFFSET			2
-#define MXC_CCM_CCGR2_CSI_MASK				(3 << MXC_CCM_CCGR2_CSI_OFFSET)
-#endif
-#if !defined(CONFIG_MX6SX) && !defined(CONFIG_MX6UL)
 #define MXC_CCM_CCGR2_HDMI_TX_ISFRCLK_OFFSET		4
 #define MXC_CCM_CCGR2_HDMI_TX_ISFRCLK_MASK		(3 << MXC_CCM_CCGR2_HDMI_TX_ISFRCLK_OFFSET)
 #endif
+#if defined(CONFIG_MX6ULL)
+#define MXC_CCM_CCGR2_ESAI_CLK_OFFSET		0
+#define MXC_CCM_CCGR2_ESAI_CLK_MASK		(3 << MXC_CCM_CCGR2_ESAI_CLK_OFFSET)
+#define MXC_CCM_CCGR2_IOMUXC_SNVS_CLK_OFFSET		4
+#define MXC_CCM_CCGR2_IOMUXC_SNVS_CLK_MASK		(3 << MXC_CCM_CCGR2_IOMUXC_SNVS_CLK_OFFSET)
+#endif
+
+#if defined(CONFIG_MX6SX) || defined(CONFIG_MX6UL)
+#define MXC_CCM_CCGR2_CSI_OFFSET			2
+#define MXC_CCM_CCGR2_CSI_MASK				(3 << MXC_CCM_CCGR2_CSI_OFFSET)
+#endif
+
 #define MXC_CCM_CCGR2_I2C1_SERIAL_OFFSET		6
 #define MXC_CCM_CCGR2_I2C1_SERIAL_MASK			(3 << MXC_CCM_CCGR2_I2C1_SERIAL_OFFSET)
 #define MXC_CCM_CCGR2_I2C2_SERIAL_OFFSET		8
@@ -887,8 +909,13 @@ struct mxc_ccm_reg {
 #ifdef CONFIG_MX6UL
 #define MXC_CCM_CCGR3_UART5_CLK_ENABLE_OFFSET			2
 #define MXC_CCM_CCGR3_UART5_CLK_ENABLE_MASK			(3 << MXC_CCM_CCGR3_UART5_CLK_ENABLE_OFFSET)
+#ifdef CONFIG_MX6ULL
+#define MXC_CCM_CCGR3_EPDC_CLK_ENABLE_OFFSET			4
+#define MXC_CCM_CCGR3_EPDC_CLK_ENABLE_MASK			(3 << MXC_CCM_CCGR3_EPDC_CLK_ENABLE_OFFSET)
+#else
 #define MXC_CCM_CCGR3_ENET_CLK_ENABLE_OFFSET			4
 #define MXC_CCM_CCGR3_ENET_CLK_ENABLE_MASK			(3 << MXC_CCM_CCGR3_ENET_CLK_ENABLE_OFFSET)
+#endif
 #define MXC_CCM_CCGR3_UART6_CLK_ENABLE_OFFSET			6
 #define MXC_CCM_CCGR3_UART6_CLK_ENABLE_MASK			(3 << MXC_CCM_CCGR3_UART6_CLK_ENABLE_OFFSET)
 #define MXC_CCM_CCGR3_UART6_CLK_ENABLE_OFFSET			6
@@ -924,17 +951,19 @@ struct mxc_ccm_reg {
 #define MXC_CCM_CCGR3_IPU2_IPU_DI1_OFFSET			10
 #define MXC_CCM_CCGR3_IPU2_IPU_DI1_MASK				(3 << MXC_CCM_CCGR3_IPU2_IPU_DI1_OFFSET)
 #endif
-#define MXC_CCM_CCGR3_LDB_DI0_OFFSET				12
-#define MXC_CCM_CCGR3_LDB_DI0_MASK				(3 << MXC_CCM_CCGR3_LDB_DI0_OFFSET)
-#if defined(CONFIG_MX6SX) || defined(CONFIG_MX6UL)
+
+#define MXC_CCM_CCGR3_GPIO4_CLK_OFFSET				12
+#define MXC_CCM_CCGR3_GPIO4_CLK_MASK				(3 << MXC_CCM_CCGR3_GPIO4_CLK_OFFSET)
 #define MXC_CCM_CCGR3_QSPI1_OFFSET				14
 #define MXC_CCM_CCGR3_QSPI1_MASK				(3 << MXC_CCM_CCGR3_QSPI1_OFFSET)
-#else
+
+#define MXC_CCM_CCGR3_LDB_DI0_OFFSET				12
+#define MXC_CCM_CCGR3_LDB_DI0_MASK				(3 << MXC_CCM_CCGR3_LDB_DI0_OFFSET)
 #define MXC_CCM_CCGR3_LDB_DI1_OFFSET				14
 #define MXC_CCM_CCGR3_LDB_DI1_MASK				(3 << MXC_CCM_CCGR3_LDB_DI1_OFFSET)
 #define MXC_CCM_CCGR3_MIPI_CORE_CFG_OFFSET			16
 #define MXC_CCM_CCGR3_MIPI_CORE_CFG_MASK			(3 << MXC_CCM_CCGR3_MIPI_CORE_CFG_OFFSET)
-#endif
+
 #ifdef CONFIG_MX6UL
 #define MXC_CCM_CCGR3_WDOG1_CLK_ENABLE_OFFSET			16
 #define MXC_CCM_CCGR3_WDOG1_CLK_ENABLE_MASK			(3 << MXC_CCM_CCGR3_WDOG1_CLK_ENABLE_OFFSET)
@@ -963,14 +992,12 @@ struct mxc_ccm_reg {
 #define MXC_CCM_CCGR3_OCRAM_OFFSET				28
 #define MXC_CCM_CCGR3_OCRAM_MASK				(3 << MXC_CCM_CCGR3_OCRAM_OFFSET)
 #endif
-#ifndef CONFIG_MX6SX
-#ifdef CONFIG_MX6UL
-#define MXC_CCM_CCGR3_GPIO4_CLK_OFFSET				30
-#define MXC_CCM_CCGR3_GPIO4_CLK_MASK				(3 << MXC_CCM_CCGR3_GPIO4_CLK_OFFSET)
-#else
+#if !defined(CONFIG_MX6SX) && !defined(CONFIG_MX6UL)
 #define MXC_CCM_CCGR3_OPENVGAXICLK_OFFSET			30
 #define MXC_CCM_CCGR3_OPENVGAXICLK_MASK				(3 << MXC_CCM_CCGR3_OPENVGAXICLK_OFFSET)
-#endif
+#elif defined(CONFIG_MX6ULL)
+#define MXC_CCM_CCGR3_IOMUXC_SNVS_GPR_CLK_OFFSET			30
+#define MXC_CCM_CCGR3_IOMUXC_SNVS_GPR_CLK_MASK				(3 << MXC_CCM_CCGR3_IOMUXC_SNVS_GPR_CLK_OFFSET)
 #endif
 
 #define MXC_CCM_CCGR4_PCIE_OFFSET				0
@@ -1079,10 +1106,15 @@ struct mxc_ccm_reg {
 #define MXC_CCM_CCGR6_USDHC2_OFFSET		4
 #define MXC_CCM_CCGR6_USDHC2_MASK		(3 << MXC_CCM_CCGR6_USDHC2_OFFSET)
 #ifdef CONFIG_MX6UL
-#define MXC_CCM_CCGR6_BCH_OFFSET		6
-#define MXC_CCM_CCGR6_BCH_MASK			(3 << MXC_CCM_CCGR6_BCH_OFFSET)
-#define MXC_CCM_CCGR6_GPMI_OFFSET		8
-#define MXC_CCM_CCGR6_GPMI_MASK			(3 << MXC_CCM_CCGR6_GPMI_OFFSET)
+#ifdef CONFIG_MX6ULL
+#define MXC_CCM_CCGR6_IPMUX4_CLK_OFFSET		8
+#define MXC_CCM_CCGR6_IPMUX4_CLK_MASK			(3 << MXC_CCM_CCGR6_IPMUX4_CLK_OFFSET)
+#else
+#define MXC_CCM_CCGR6_SIM1_CLK_OFFSET		6
+#define MXC_CCM_CCGR6_SIM1_CLK_MASK			(3 << MXC_CCM_CCGR6_SIM1_CLK_OFFSET)
+#define MXC_CCM_CCGR6_SIM2_CLK_OFFSET		8
+#define MXC_CCM_CCGR6_SIM2_CLK_MASK			(3 << MXC_CCM_CCGR6_SIM2_CLK_OFFSET)
+#endif
 #else
 #define MXC_CCM_CCGR6_USDHC3_OFFSET		6
 #define MXC_CCM_CCGR6_USDHC3_MASK		(3 << MXC_CCM_CCGR6_USDHC3_OFFSET)
@@ -1094,6 +1126,10 @@ struct mxc_ccm_reg {
 #ifdef CONFIG_MX6UL
 #define MXC_CCM_CCGR6_PWM8_OFFSET		16
 #define MXC_CCM_CCGR6_PWM8_MASK			(3 << MXC_CCM_CCGR6_PWM8_OFFSET)
+#ifdef CONFIG_MX6ULL
+#define MXC_CCM_CCGR6_AIPS_TZ3_CLK_OFFSET		18
+#define MXC_CCM_CCGR6_AIPS_TZ3_CLK_MASK			(3 << MXC_CCM_CCGR6_AIPS_TZ3_CLK_OFFSET)
+#endif
 #define MXC_CCM_CCGR6_WDOG3_OFFSET		20
 #define MXC_CCM_CCGR6_WDOG3_MASK		(3 << MXC_CCM_CCGR6_WDOG3_OFFSET)
 #define MXC_CCM_CCGR6_ANADIG_OFFSET		22
diff --git a/arch/arm/include/asm/arch-mx6/imx-regs.h b/arch/arm/include/asm/arch-mx6/imx-regs.h
index 9fbe3e4..3d0a79d 100644
--- a/arch/arm/include/asm/arch-mx6/imx-regs.h
+++ b/arch/arm/include/asm/arch-mx6/imx-regs.h
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2011-2015 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright (C) 2011-2016 Freescale Semiconductor, Inc. All Rights Reserved.
  *
  * SPDX-License-Identifier:	GPL-2.0+
  */
@@ -163,7 +163,11 @@
 
 #define UART1_BASE                  (ATZ1_BASE_ADDR + 0x20000)
 #if defined(CONFIG_MX6UL)
+#if defined(CONFIG_MX6ULL)
+#define ESAI1_BASE_ADDR             (ATZ1_BASE_ADDR + 0x24000)
+#else
 #define UART8_IPS_BASE_ADDR         (ATZ1_BASE_ADDR + 0x24000)
+#endif
 #define SAI1_BASE_ADDR              (ATZ1_BASE_ADDR + 0x28000)
 #define SAI2_BASE_ADDR              (ATZ1_BASE_ADDR + 0x2C000)
 #define SAI3_BASE_ADDR              (ATZ1_BASE_ADDR + 0x30000)
@@ -219,10 +223,12 @@
 #define GPC_BASE_ADDR               (AIPS1_OFF_BASE_ADDR + 0x5C000)
 #define IOMUXC_BASE_ADDR            (AIPS1_OFF_BASE_ADDR + 0x60000)
 #define IOMUXC_GPR_BASE_ADDR        (AIPS1_OFF_BASE_ADDR + 0x64000)
+
 #if defined(CONFIG_MX6SL)
 #define CSI_BASE_ADDR               (AIPS1_OFF_BASE_ADDR + 0x64000)
 #define SIPIX_BASE_ADDR             (AIPS1_OFF_BASE_ADDR + 0x68000)
 #define SDMA_PORT_HOST_BASE_ADDR    (AIPS1_OFF_BASE_ADDR + 0x6C000)
+#define EPDC_BASE_ADDR              (AIPS1_OFF_BASE_ADDR + 0x74000)
 
 #elif defined(CONFIG_MX6SX)
 #define CANFD1_BASE_ADDR            (AIPS1_OFF_BASE_ADDR + 0x68000)
@@ -243,8 +249,8 @@
 #define DCIC1_BASE_ADDR             (AIPS1_OFF_BASE_ADDR + 0x64000)
 #define DCIC2_BASE_ADDR             (AIPS1_OFF_BASE_ADDR + 0x68000)
 #define DMA_REQ_PORT_HOST_BASE_ADDR (AIPS1_OFF_BASE_ADDR + 0x6C000)
-#endif
 #define EPDC_BASE_ADDR              (AIPS1_OFF_BASE_ADDR + 0x74000)
+#endif
 
 #define AIPS2_ON_BASE_ADDR          (ATZ2_BASE_ADDR + 0x7C000)
 #define AIPS2_OFF_BASE_ADDR         (ATZ2_BASE_ADDR + 0x80000)
@@ -378,6 +384,14 @@
 #define PWM6_BASE_ADDR              (AIPS3_ARB_BASE_ADDR + 0xA8000)
 #define PWM7_BASE_ADDR              (AIPS3_ARB_BASE_ADDR + 0xAC000)
 #define PWM8_BASE_ADDR              (AIPS3_ARB_BASE_ADDR + 0xB0000)
+#elif defined(CONFIG_MX6ULL)
+#define AIPS3_CONFIG_BASE_ADDR      (AIPS3_ARB_BASE_ADDR + 0x7C000)
+#define DCP_BASE_ADDR      			(AIPS3_ARB_BASE_ADDR + 0x80000)
+#define RNGB_BASE_ADDR      		(AIPS3_ARB_BASE_ADDR + 0x84000)
+#define UART8_IPS_BASE_ADDR      	(AIPS3_ARB_BASE_ADDR + 0x88000)
+#define EPDC_BASE_ADDR              (AIPS3_ARB_BASE_ADDR + 0x8C000)
+#define IOMUXC_SNVS_BASE_ADDR       (AIPS3_ARB_BASE_ADDR + 0x90000)
+#define SNVS_GPR_BASE_ADDR       	(AIPS3_ARB_BASE_ADDR + 0x94000)
 #endif
 
 #define CHIP_REV_1_0                 0x10
diff --git a/arch/arm/include/asm/arch-mx6/mx6-pins.h b/arch/arm/include/asm/arch-mx6/mx6-pins.h
index 05b5b35..2363080 100644
--- a/arch/arm/include/asm/arch-mx6/mx6-pins.h
+++ b/arch/arm/include/asm/arch-mx6/mx6-pins.h
@@ -1,6 +1,6 @@
 /*
  * Copyright (C) 2013 Boundary Devices Inc.
- * Copyright (C) 2015 Freescale Semiconductor, Inc.
+ * Copyright (C) 2015-2016 Freescale Semiconductor, Inc.
  *
  * SPDX-License-Identifier:	GPL-2.0+
  */
@@ -38,6 +38,8 @@ enum {
 #include "mx6sl_pins.h"
 #elif defined(CONFIG_MX6SX)
 #include "mx6sx_pins.h"
+#elif defined(CONFIG_MX6ULL)
+#include "mx6ull_pins.h"
 #elif defined(CONFIG_MX6UL)
 #include "mx6ul_pins.h"
 #else
diff --git a/arch/arm/include/asm/arch-mx6/mx6ull_pins.h b/arch/arm/include/asm/arch-mx6/mx6ull_pins.h
new file mode 100644
index 0000000..8b62bd9
--- /dev/null
+++ b/arch/arm/include/asm/arch-mx6/mx6ull_pins.h
@@ -0,0 +1,1062 @@
+/*
+ * Copyright (C) 2014-2016 Freescale Semiconductor, Inc.
+ *
+ * SPDX-License-Identifier:     GPL-2.0+
+ */
+
+#ifndef __ASM_ARCH_IMX6ULL_PINS_H__
+#define __ASM_ARCH_IMX6ULL_PINS_H__
+
+#include <asm/imx-common/iomux-v3.h>
+
+enum {
+	/*
+	 * The TAMPER Pin can be used for GPIO, which depends on
+	 * TAMPER_PIN_DISABLE[1:0] settings.
+	 */
+	MX6_PAD_SNVS_TAMPER0__GPIO5_IO00                       = IOMUX_PAD(0x02A8, 0x001C, 5, 0x0000, 0, 0),
+	MX6_PAD_SNVS_TAMPER1__GPIO5_IO01                       = IOMUX_PAD(0x02AC, 0x0020, 5, 0x0000, 0, 0),
+	MX6_PAD_SNVS_TAMPER2__GPIO5_IO02                       = IOMUX_PAD(0x02B0, 0x0024, 5, 0x0000, 0, 0),
+	MX6_PAD_SNVS_TAMPER3__GPIO5_IO03                       = IOMUX_PAD(0x02B4, 0x0028, 5, 0x0000, 0, 0),
+	MX6_PAD_SNVS_TAMPER4__GPIO5_IO04                       = IOMUX_PAD(0x02B8, 0x002C, 5, 0x0000, 0, 0),
+	MX6_PAD_SNVS_TAMPER5__GPIO5_IO05                       = IOMUX_PAD(0x02BC, 0x0030, 5, 0x0000, 0, 0),
+	MX6_PAD_SNVS_TAMPER6__GPIO5_IO06                       = IOMUX_PAD(0x02C0, 0x0034, 5, 0x0000, 0, 0),
+	MX6_PAD_SNVS_TAMPER7__GPIO5_IO07                       = IOMUX_PAD(0x02C4, 0x0038, 5, 0x0000, 0, 0),
+	MX6_PAD_SNVS_TAMPER8__GPIO5_IO08                       = IOMUX_PAD(0x02C8, 0x003C, 5, 0x0000, 0, 0),
+	MX6_PAD_SNVS_TAMPER9__GPIO5_IO09                       = IOMUX_PAD(0x02CC, 0x0040, 5, 0x0000, 0, 0),
+
+	MX6_PAD_JTAG_MOD__SJC_MOD                             = IOMUX_PAD(0x02D0, 0x0044, 0, 0x0000, 0, 0),
+	MX6_PAD_JTAG_MOD__GPT2_CLK                            = IOMUX_PAD(0x02D0, 0x0044, 1, 0x05A0, 0, 0),
+	MX6_PAD_JTAG_MOD__SPDIF_OUT                           = IOMUX_PAD(0x02D0, 0x0044, 2, 0x0000, 0, 0),
+	MX6_PAD_JTAG_MOD__ENET1_REF_CLK_25M                   = IOMUX_PAD(0x02D0, 0x0044, 3, 0x0000, 0, 0),
+	MX6_PAD_JTAG_MOD__CCM_PMIC_RDY                        = IOMUX_PAD(0x02D0, 0x0044, 4, 0x04C0, 0, 0),
+	MX6_PAD_JTAG_MOD__GPIO1_IO10                          = IOMUX_PAD(0x02D0, 0x0044, 5, 0x0000, 0, 0),
+	MX6_PAD_JTAG_MOD__SDMA_EXT_EVENT00                    = IOMUX_PAD(0x02D0, 0x0044, 6, 0x0610, 0, 0),
+
+	MX6_PAD_JTAG_TMS__SJC_TMS                             = IOMUX_PAD(0x02D4, 0x0048, 0, 0x0000, 0, 0),
+	MX6_PAD_JTAG_TMS__GPT2_CAPTURE1                       = IOMUX_PAD(0x02D4, 0x0048, 1, 0x0598, 0, 0),
+	MX6_PAD_JTAG_TMS__SAI2_MCLK                           = IOMUX_PAD(0x02D4, 0x0048, 2, 0x05F0, 0, 0),
+	MX6_PAD_JTAG_TMS__CCM_CLKO1                           = IOMUX_PAD(0x02D4, 0x0048, 3, 0x0000, 0, 0),
+	MX6_PAD_JTAG_TMS__CCM_WAIT                            = IOMUX_PAD(0x02D4, 0x0048, 4, 0x0000, 0, 0),
+	MX6_PAD_JTAG_TMS__GPIO1_IO11                          = IOMUX_PAD(0x02D4, 0x0048, 5, 0x0000, 0, 0),
+	MX6_PAD_JTAG_TMS__SDMA_EXT_EVENT01                    = IOMUX_PAD(0x02D4, 0x0048, 6, 0x0614, 0, 0),
+	MX6_PAD_JTAG_TMS__EPIT1_OUT                           = IOMUX_PAD(0x02D4, 0x0048, 8, 0x0000, 0, 0),
+
+	MX6_PAD_JTAG_TDO__SJC_TDO                             = IOMUX_PAD(0x02D8, 0x004C, 0, 0x0000, 0, 0),
+	MX6_PAD_JTAG_TDO__GPT2_CAPTURE2                       = IOMUX_PAD(0x02D8, 0x004C, 1, 0x059C, 0, 0),
+	MX6_PAD_JTAG_TDO__SAI2_TX_SYNC                        = IOMUX_PAD(0x02D8, 0x004C, 2, 0x05FC, 0, 0),
+	MX6_PAD_JTAG_TDO__CCM_CLKO2                           = IOMUX_PAD(0x02D8, 0x004C, 3, 0x0000, 0, 0),
+	MX6_PAD_JTAG_TDO__CCM_STOP                            = IOMUX_PAD(0x02D8, 0x004C, 4, 0x0000, 0, 0),
+	MX6_PAD_JTAG_TDO__GPIO1_IO12                          = IOMUX_PAD(0x02D8, 0x004C, 5, 0x0000, 0, 0),
+	MX6_PAD_JTAG_TDO__MQS_RIGHT                           = IOMUX_PAD(0x02D8, 0x004C, 6, 0x0000, 0, 0),
+	MX6_PAD_JTAG_TDO__EPIT2_OUT                           = IOMUX_PAD(0x02D8, 0x004C, 8, 0x0000, 0, 0),
+
+	MX6_PAD_JTAG_TDI__SJC_TDI                             = IOMUX_PAD(0x02DC, 0x0050, 0, 0x0000, 0, 0),
+	MX6_PAD_JTAG_TDI__GPT2_COMPARE1                       = IOMUX_PAD(0x02DC, 0x0050, 1, 0x0000, 0, 0),
+	MX6_PAD_JTAG_TDI__SAI2_TX_BCLK                        = IOMUX_PAD(0x02DC, 0x0050, 2, 0x05F8, 0, 0),
+	MX6_PAD_JTAG_TDI__PWM6_OUT                            = IOMUX_PAD(0x02DC, 0x0050, 4, 0x0000, 0, 0),
+	MX6_PAD_JTAG_TDI__GPIO1_IO13                          = IOMUX_PAD(0x02DC, 0x0050, 5, 0x0000, 0, 0),
+	MX6_PAD_JTAG_TDI__MQS_LEFT                            = IOMUX_PAD(0x02DC, 0x0050, 6, 0x0000, 0, 0),
+	MX6_PAD_JTAG_TDI__SIM1_POWER_FAIL                     = IOMUX_PAD(0x02DC, 0x0050, 8, 0x0000, 0, 0),
+
+	MX6_PAD_JTAG_TCK__SJC_TCK                             = IOMUX_PAD(0x02E0, 0x0054, 0, 0x0000, 0, 0),
+	MX6_PAD_JTAG_TCK__GPT2_COMPARE2                       = IOMUX_PAD(0x02E0, 0x0054, 1, 0x0000, 0, 0),
+	MX6_PAD_JTAG_TCK__SAI2_RX_DATA                        = IOMUX_PAD(0x02E0, 0x0054, 2, 0x05F4, 0, 0),
+	MX6_PAD_JTAG_TCK__PWM7_OUT                            = IOMUX_PAD(0x02E0, 0x0054, 4, 0x0000, 0, 0),
+	MX6_PAD_JTAG_TCK__GPIO1_IO14                          = IOMUX_PAD(0x02E0, 0x0054, 5, 0x0000, 0, 0),
+	MX6_PAD_JTAG_TCK__SIM2_POWER_FAIL                     = IOMUX_PAD(0x02E0, 0x0054, 8, 0x0000, 0, 0),
+
+	MX6_PAD_JTAG_TRST_B__SJC_TRSTB                        = IOMUX_PAD(0x02E4, 0x0058, 0, 0x0000, 0, 0),
+	MX6_PAD_JTAG_TRST_B__GPT2_COMPARE3                    = IOMUX_PAD(0x02E4, 0x0058, 1, 0x0000, 0, 0),
+	MX6_PAD_JTAG_TRST_B__SAI2_TX_DATA                     = IOMUX_PAD(0x02E4, 0x0058, 2, 0x0000, 0, 0),
+	MX6_PAD_JTAG_TRST_B__PWM8_OUT                         = IOMUX_PAD(0x02E4, 0x0058, 4, 0x0000, 0, 0),
+	MX6_PAD_JTAG_TRST_B__GPIO1_IO15                       = IOMUX_PAD(0x02E4, 0x0058, 5, 0x0000, 0, 0),
+	MX6_PAD_JTAG_TRST_B__CAAM_RNG_OSC_OBS                 = IOMUX_PAD(0x02E4, 0x0058, 8, 0x0000, 0, 0),
+
+	MX6_PAD_GPIO1_IO00__I2C2_SCL                          = IOMUX_PAD(0x02E8, 0x005C, IOMUX_CONFIG_SION | 0, 0x05AC, 1, 0),
+	MX6_PAD_GPIO1_IO00__GPT1_CAPTURE1                     = IOMUX_PAD(0x02E8, 0x005C, 1, 0x058C, 0, 0),
+	MX6_PAD_GPIO1_IO00__ANATOP_OTG1_ID                    = IOMUX_PAD(0x02E8, 0x005C, 2, 0x04B8, 0, 0),
+	MX6_PAD_GPIO1_IO00__ENET1_REF_CLK1                    = IOMUX_PAD(0x02E8, 0x005C, 3, 0x0574, 0, 0),
+	MX6_PAD_GPIO1_IO00__MQS_RIGHT                         = IOMUX_PAD(0x02E8, 0x005C, 4, 0x0000, 0, 0),
+	MX6_PAD_GPIO1_IO00__GPIO1_IO00                        = IOMUX_PAD(0x02E8, 0x005C, 5, 0x0000, 0, 0),
+	MX6_PAD_GPIO1_IO00__ENET1_1588_EVENT0_IN              = IOMUX_PAD(0x02E8, 0x005C, 6, 0x0000, 0, 0),
+	MX6_PAD_GPIO1_IO00__SRC_SYSTEM_RESET                  = IOMUX_PAD(0x02E8, 0x005C, 7, 0x0000, 0, 0),
+	MX6_PAD_GPIO1_IO00__WDOG3_WDOG_B                      = IOMUX_PAD(0x02E8, 0x005C, 8, 0x0000, 0, 0),
+
+	MX6_PAD_GPIO1_IO01__I2C2_SDA                          = IOMUX_PAD(0x02EC, 0x0060, IOMUX_CONFIG_SION | 0, 0x05B0, 1, 0),
+	MX6_PAD_GPIO1_IO01__GPT1_COMPARE1                     = IOMUX_PAD(0x02EC, 0x0060, 1, 0x0000, 0, 0),
+	MX6_PAD_GPIO1_IO01__USB_OTG1_OC                       = IOMUX_PAD(0x02EC, 0x0060, 2, 0x0664, 0, 0),
+	MX6_PAD_GPIO1_IO01__ENET2_REF_CLK2                    = IOMUX_PAD(0x02EC, 0x0060, 3, 0x057C, 0, 0),
+	MX6_PAD_GPIO1_IO01__MQS_LEFT                          = IOMUX_PAD(0x02EC, 0x0060, 4, 0x0000, 0, 0),
+	MX6_PAD_GPIO1_IO01__GPIO1_IO01                        = IOMUX_PAD(0x02EC, 0x0060, 5, 0x0000, 0, 0),
+	MX6_PAD_GPIO1_IO01__ENET1_1588_EVENT0_OUT             = IOMUX_PAD(0x02EC, 0x0060, 6, 0x0000, 0, 0),
+	MX6_PAD_GPIO1_IO01__SRC_EARLY_RESET                   = IOMUX_PAD(0x02EC, 0x0060, 7, 0x0000, 0, 0),
+	MX6_PAD_GPIO1_IO01__WDOG1_WDOG_B                      = IOMUX_PAD(0x02EC, 0x0060, 8, 0x0000, 0, 0),
+
+	MX6_PAD_GPIO1_IO02__I2C1_SCL                          = IOMUX_PAD(0x02F0, 0x0064, IOMUX_CONFIG_SION | 0, 0x05A4, 0, 0),
+	MX6_PAD_GPIO1_IO02__GPT1_COMPARE2                     = IOMUX_PAD(0x02F0, 0x0064, 1, 0x0000, 0, 0),
+	MX6_PAD_GPIO1_IO02__USB_OTG2_PWR                      = IOMUX_PAD(0x02F0, 0x0064, 2, 0x0000, 0, 0),
+	MX6_PAD_GPIO1_IO02__ENET1_REF_CLK_25M                 = IOMUX_PAD(0x02F0, 0x0064, 3, 0x0000, 0, 0),
+	MX6_PAD_GPIO1_IO02__USDHC1_WP                         = IOMUX_PAD(0x02F0, 0x0064, 4, 0x066C, 0, 0),
+	MX6_PAD_GPIO1_IO02__GPIO1_IO02                        = IOMUX_PAD(0x02F0, 0x0064, 5, 0x0000, 0, 0),
+	MX6_PAD_GPIO1_IO02__SDMA_EXT_EVENT00                  = IOMUX_PAD(0x02F0, 0x0064, 6, 0x0610, 1, 0),
+	MX6_PAD_GPIO1_IO02__SRC_ANY_PU_RESET                  = IOMUX_PAD(0x02F0, 0x0064, 7, 0x0000, 0, 0),
+	MX6_PAD_GPIO1_IO02__UART1_DCE_TX                      = IOMUX_PAD(0x02F0, 0x0064, 8, 0x0000, 0, 0),
+	MX6_PAD_GPIO1_IO02__UART1_DTE_RX                      = IOMUX_PAD(0x02F0, 0x0064, 8, 0x0624, 0, 0),
+
+	MX6_PAD_GPIO1_IO03__I2C1_SDA                          = IOMUX_PAD(0x02F4, 0x0068, IOMUX_CONFIG_SION | 0, 0x05A8, 1, 0),
+	MX6_PAD_GPIO1_IO03__GPT1_COMPARE3                     = IOMUX_PAD(0x02F4, 0x0068, 1, 0x0000, 0, 0),
+	MX6_PAD_GPIO1_IO03__USB_OTG2_OC                       = IOMUX_PAD(0x02F4, 0x0068, 2, 0x0660, 0, 0),
+	MX6_PAD_GPIO1_IO03__USDHC1_CD_B                       = IOMUX_PAD(0x02F4, 0x0068, 4, 0x0668, 0, 0),
+	MX6_PAD_GPIO1_IO03__GPIO1_IO03                        = IOMUX_PAD(0x02F4, 0x0068, 5, 0x0000, 0, 0),
+	MX6_PAD_GPIO1_IO03__CCM_DI0_EXT_CLK                   = IOMUX_PAD(0x02F4, 0x0068, 6, 0x0000, 0, 0),
+	MX6_PAD_GPIO1_IO03__SRC_TESTER_ACK                    = IOMUX_PAD(0x02F4, 0x0068, 7, 0x0000, 0, 0),
+	MX6_PAD_GPIO1_IO03__UART1_DCE_RX                      = IOMUX_PAD(0x02F4, 0x0068, 8, 0x0624, 1, 0),
+	MX6_PAD_GPIO1_IO03__UART1_DTE_TX                      = IOMUX_PAD(0x02F4, 0x0068, 8, 0x0000, 0, 0),
+
+	MX6_PAD_GPIO1_IO04__ENET1_REF_CLK1                    = IOMUX_PAD(0x02F8, 0x006C, 0, 0x0574, 1, 0),
+	MX6_PAD_GPIO1_IO04__PWM3_OUT                          = IOMUX_PAD(0x02F8, 0x006C, 1, 0x0000, 0, 0),
+	MX6_PAD_GPIO1_IO04__USB_OTG1_PWR                      = IOMUX_PAD(0x02F8, 0x006C, 2, 0x0000, 0, 0),
+	MX6_PAD_GPIO1_IO04__USDHC1_RESET_B                    = IOMUX_PAD(0x02F8, 0x006C, 4, 0x0000, 0, 0),
+	MX6_PAD_GPIO1_IO04__GPIO1_IO04                        = IOMUX_PAD(0x02F8, 0x006C, 5, 0x0000, 0, 0),
+	MX6_PAD_GPIO1_IO04__ENET2_1588_EVENT0_IN              = IOMUX_PAD(0x02F8, 0x006C, 6, 0x0000, 0, 0),
+	MX6_PAD_GPIO1_IO04__UART5_DCE_TX                      = IOMUX_PAD(0x02F8, 0x006C, 8, 0x0000, 0, 0),
+	MX6_PAD_GPIO1_IO04__UART5_DTE_RX                      = IOMUX_PAD(0x02F8, 0x006C, 8, 0x0644, 2, 0),
+
+	MX6_PAD_GPIO1_IO05__ENET2_REF_CLK2                    = IOMUX_PAD(0x02FC, 0x0070, 0, 0x057C, 1, 0),
+	MX6_PAD_GPIO1_IO05__PWM4_OUT                          = IOMUX_PAD(0x02FC, 0x0070, 1, 0x0000, 0, 0),
+	MX6_PAD_GPIO1_IO05__ANATOP_OTG2_ID                    = IOMUX_PAD(0x02FC, 0x0070, 2, 0x04BC, 0, 0),
+	MX6_PAD_GPIO1_IO05__CSI_FIELD                         = IOMUX_PAD(0x02FC, 0x0070, 3, 0x0530, 0, 0),
+	MX6_PAD_GPIO1_IO05__USDHC1_VSELECT                    = IOMUX_PAD(0x02FC, 0x0070, 4, 0x0000, 0, 0),
+	MX6_PAD_GPIO1_IO05__GPIO1_IO05                        = IOMUX_PAD(0x02FC, 0x0070, 5, 0x0000, 0, 0),
+	MX6_PAD_GPIO1_IO05__ENET2_1588_EVENT0_OUT             = IOMUX_PAD(0x02FC, 0x0070, 6, 0x0000, 0, 0),
+	MX6_PAD_GPIO1_IO05__UART5_DCE_RX                      = IOMUX_PAD(0x02FC, 0x0070, 8, 0x0644, 3, 0),
+	MX6_PAD_GPIO1_IO05__UART5_DTE_TX                      = IOMUX_PAD(0x02FC, 0x0070, 8, 0x0000, 0, 0),
+
+	MX6_PAD_GPIO1_IO06__ENET1_MDIO                        = IOMUX_PAD(0x0300, 0x0074, 0, 0x0578, 0, 0),
+	MX6_PAD_GPIO1_IO06__ENET2_MDIO                        = IOMUX_PAD(0x0300, 0x0074, 1, 0x0580, 0, 0),
+	MX6_PAD_GPIO1_IO06__USB_OTG_PWR_WAKE                  = IOMUX_PAD(0x0300, 0x0074, 2, 0x0000, 0, 0),
+	MX6_PAD_GPIO1_IO06__CSI_MCLK                          = IOMUX_PAD(0x0300, 0x0074, 3, 0x0000, 0, 0),
+	MX6_PAD_GPIO1_IO06__USDHC2_WP                         = IOMUX_PAD(0x0300, 0x0074, 4, 0x069C, 0, 0),
+	MX6_PAD_GPIO1_IO06__GPIO1_IO06                        = IOMUX_PAD(0x0300, 0x0074, 5, 0x0000, 0, 0),
+	MX6_PAD_GPIO1_IO06__CCM_WAIT                          = IOMUX_PAD(0x0300, 0x0074, 6, 0x0000, 0, 0),
+	MX6_PAD_GPIO1_IO06__CCM_REF_EN_B                      = IOMUX_PAD(0x0300, 0x0074, 7, 0x0000, 0, 0),
+	MX6_PAD_GPIO1_IO06__UART1_DCE_CTS                     = IOMUX_PAD(0x0300, 0x0074, 8, 0x0000, 0, 0),
+	MX6_PAD_GPIO1_IO06__UART1_DTE_RTS                     = IOMUX_PAD(0x0300, 0x0074, 8, 0x0620, 0, 0),
+
+	MX6_PAD_GPIO1_IO07__ENET1_MDC                         = IOMUX_PAD(0x0304, 0x0078, 0, 0x0000, 0, 0),
+	MX6_PAD_GPIO1_IO07__ENET2_MDC                         = IOMUX_PAD(0x0304, 0x0078, 1, 0x0000, 0, 0),
+	MX6_PAD_GPIO1_IO07__USB_OTG_HOST_MODE                 = IOMUX_PAD(0x0304, 0x0078, 2, 0x0000, 0, 0),
+	MX6_PAD_GPIO1_IO07__CSI_PIXCLK                        = IOMUX_PAD(0x0304, 0x0078, 3, 0x0528, 0, 0),
+	MX6_PAD_GPIO1_IO07__USDHC2_CD_B                       = IOMUX_PAD(0x0304, 0x0078, 4, 0x0674, 1, 0),
+	MX6_PAD_GPIO1_IO07__GPIO1_IO07                        = IOMUX_PAD(0x0304, 0x0078, 5, 0x0000, 0, 0),
+	MX6_PAD_GPIO1_IO07__CCM_STOP                          = IOMUX_PAD(0x0304, 0x0078, 6, 0x0000, 0, 0),
+	MX6_PAD_GPIO1_IO07__UART1_DCE_RTS                     = IOMUX_PAD(0x0304, 0x0078, 8, 0x0620, 1, 0),
+	MX6_PAD_GPIO1_IO07__UART1_DTE_CTS                     = IOMUX_PAD(0x0304, 0x0078, 8, 0x0000, 0, 0),
+
+	MX6_PAD_GPIO1_IO08__PWM1_OUT                          = IOMUX_PAD(0x0308, 0x007C, 0, 0x0000, 0, 0),
+	MX6_PAD_GPIO1_IO08__WDOG1_WDOG_B                      = IOMUX_PAD(0x0308, 0x007C, 1, 0x0000, 0, 0),
+	MX6_PAD_GPIO1_IO08__SPDIF_OUT                         = IOMUX_PAD(0x0308, 0x007C, 2, 0x0000, 0, 0),
+	MX6_PAD_GPIO1_IO08__CSI_VSYNC                         = IOMUX_PAD(0x0308, 0x007C, 3, 0x052C, 1, 0),
+	MX6_PAD_GPIO1_IO08__USDHC2_VSELECT                    = IOMUX_PAD(0x0308, 0x007C, 4, 0x0000, 0, 0),
+	MX6_PAD_GPIO1_IO08__GPIO1_IO08                        = IOMUX_PAD(0x0308, 0x007C, 5, 0x0000, 0, 0),
+	MX6_PAD_GPIO1_IO08__CCM_PMIC_RDY                      = IOMUX_PAD(0x0308, 0x007C, 6, 0x04C0, 1, 0),
+	MX6_PAD_GPIO1_IO08__UART5_DCE_RTS                     = IOMUX_PAD(0x0308, 0x007C, 8, 0x0640, 1, 0),
+	MX6_PAD_GPIO1_IO08__UART5_DTE_CTS                     = IOMUX_PAD(0x0308, 0x007C, 8, 0x0000, 0, 0),
+
+	MX6_PAD_GPIO1_IO09__PWM2_OUT                          = IOMUX_PAD(0x030C, 0x0080, 0, 0x0000, 0, 0),
+	MX6_PAD_GPIO1_IO09__WDOG1_WDOG_ANY                    = IOMUX_PAD(0x030C, 0x0080, 1, 0x0000, 0, 0),
+	MX6_PAD_GPIO1_IO09__SPDIF_IN                          = IOMUX_PAD(0x030C, 0x0080, 2, 0x0618, 0, 0),
+	MX6_PAD_GPIO1_IO09__CSI_HSYNC                         = IOMUX_PAD(0x030C, 0x0080, 3, 0x0524, 1, 0),
+	MX6_PAD_GPIO1_IO09__USDHC2_RESET_B                    = IOMUX_PAD(0x030C, 0x0080, 4, 0x0000, 0, 0),
+	MX6_PAD_GPIO1_IO09__GPIO1_IO09                        = IOMUX_PAD(0x030C, 0x0080, 5, 0x0000, 0, 0),
+	MX6_PAD_GPIO1_IO09__USDHC1_RESET_B                    = IOMUX_PAD(0x030C, 0x0080, 6, 0x0000, 0, 0),
+	MX6_PAD_GPIO1_IO09__UART5_DCE_CTS                     = IOMUX_PAD(0x030C, 0x0080, 8, 0x0000, 0, 0),
+	MX6_PAD_GPIO1_IO09__UART5_DTE_RTS                     = IOMUX_PAD(0x030C, 0x0080, 8, 0x0640, 2, 0),
+
+	MX6_PAD_UART1_TX_DATA__UART1_DCE_TX                   = IOMUX_PAD(0x0310, 0x0084, 0, 0x0000, 0, 0),
+
+	MX6_PAD_UART1_TX_DATA__UART1_DTE_RX                   = IOMUX_PAD(0x0310, 0x0084, 0, 0x0624, 2, 0),
+	MX6_PAD_UART1_TX_DATA__ENET1_RDATA02                  = IOMUX_PAD(0x0310, 0x0084, 1, 0x0000, 0, 0),
+	MX6_PAD_UART1_TX_DATA__I2C3_SCL                       = IOMUX_PAD(0x0310, 0x0084, IOMUX_CONFIG_SION | 2, 0x05B4, 0, 0),
+	MX6_PAD_UART1_TX_DATA__CSI_DATA02                     = IOMUX_PAD(0x0310, 0x0084, 3, 0x04C4, 1, 0),
+	MX6_PAD_UART1_TX_DATA__GPT1_COMPARE1                  = IOMUX_PAD(0x0310, 0x0084, 4, 0x0000, 0, 0),
+	MX6_PAD_UART1_TX_DATA__GPIO1_IO16                     = IOMUX_PAD(0x0310, 0x0084, 5, 0x0000, 0, 0),
+	MX6_PAD_UART1_TX_DATA__SPDIF_OUT                      = IOMUX_PAD(0x0310, 0x0084, 8, 0x0000, 0, 0),
+
+	MX6_PAD_UART1_RX_DATA__UART1_DCE_RX                   = IOMUX_PAD(0x0314, 0x0088, 0, 0x0624, 3, 0),
+
+	MX6_PAD_UART1_RX_DATA__UART1_DTE_TX                   = IOMUX_PAD(0x0314, 0x0088, 0, 0x0000, 0, 0),
+	MX6_PAD_UART1_RX_DATA__ENET1_RDATA03                  = IOMUX_PAD(0x0314, 0x0088, 1, 0x0000, 0, 0),
+	MX6_PAD_UART1_RX_DATA__I2C3_SDA                       = IOMUX_PAD(0x0314, 0x0088, IOMUX_CONFIG_SION | 2, 0x05B8, 0, 0),
+	MX6_PAD_UART1_RX_DATA__CSI_DATA03                     = IOMUX_PAD(0x0314, 0x0088, 3, 0x04C8, 1, 0),
+	MX6_PAD_UART1_RX_DATA__GPT1_CLK                       = IOMUX_PAD(0x0314, 0x0088, 4, 0x0594, 0, 0),
+	MX6_PAD_UART1_RX_DATA__GPIO1_IO17                     = IOMUX_PAD(0x0314, 0x0088, 5, 0x0000, 0, 0),
+	MX6_PAD_UART1_RX_DATA__SPDIF_IN                       = IOMUX_PAD(0x0314, 0x0088, 8, 0x0618, 1, 0),
+
+	MX6_PAD_UART1_CTS_B__UART1_DCE_CTS                    = IOMUX_PAD(0x0318, 0x008C, 0, 0x0000, 0, 0),
+
+	MX6_PAD_UART1_CTS_B__UART1_DTE_RTS                    = IOMUX_PAD(0x0318, 0x008C, 0, 0x0620, 2, 0),
+	MX6_PAD_UART1_CTS_B__ENET1_RX_CLK                     = IOMUX_PAD(0x0318, 0x008C, 1, 0x0000, 0, 0),
+	MX6_PAD_UART1_CTS_B__USDHC1_WP                        = IOMUX_PAD(0x0318, 0x008C, 2, 0x066C, 1, 0),
+	MX6_PAD_UART1_CTS_B__CSI_DATA04                       = IOMUX_PAD(0x0318, 0x008C, 3, 0x04D8, 0, 0),
+	MX6_PAD_UART1_CTS_B__ENET2_1588_EVENT1_IN             = IOMUX_PAD(0x0318, 0x008C, 4, 0x0000, 0, 0),
+	MX6_PAD_UART1_CTS_B__GPIO1_IO18                       = IOMUX_PAD(0x0318, 0x008C, 5, 0x0000, 0, 0),
+	MX6_PAD_UART1_CTS_B__USDHC2_WP                        = IOMUX_PAD(0x0318, 0x008C, 8, 0x069C, 1, 0),
+
+	MX6_PAD_UART1_RTS_B__UART1_DCE_RTS                    = IOMUX_PAD(0x031C, 0x0090, 0, 0x0620, 3, 0),
+
+	MX6_PAD_UART1_RTS_B__UART1_DTE_CTS                    = IOMUX_PAD(0x031C, 0x0090, 0, 0x0000, 0, 0),
+	MX6_PAD_UART1_RTS_B__ENET1_TX_ER                      = IOMUX_PAD(0x031C, 0x0090, 1, 0x0000, 0, 0),
+	MX6_PAD_UART1_RTS_B__USDHC1_CD_B                      = IOMUX_PAD(0x031C, 0x0090, 2, 0x0668, 1, 0),
+	MX6_PAD_UART1_RTS_B__CSI_DATA05                       = IOMUX_PAD(0x031C, 0x0090, 3, 0x04CC, 1, 0),
+	MX6_PAD_UART1_RTS_B__ENET2_1588_EVENT1_OUT            = IOMUX_PAD(0x031C, 0x0090, 4, 0x0000, 0, 0),
+	MX6_PAD_UART1_RTS_B__GPIO1_IO19                       = IOMUX_PAD(0x031C, 0x0090, 5, 0x0000, 0, 0),
+	MX6_PAD_UART1_RTS_B__USDHC2_CD_B                      = IOMUX_PAD(0x031C, 0x0090, 8, 0x0674, 2, 0),
+
+	MX6_PAD_UART2_TX_DATA__UART2_DCE_TX                   = IOMUX_PAD(0x0320, 0x0094, 0, 0x0000, 0, 0),
+
+	MX6_PAD_UART2_TX_DATA__UART2_DTE_RX                   = IOMUX_PAD(0x0320, 0x0094, 0, 0x062C, 0, 0),
+	MX6_PAD_UART2_TX_DATA__ENET1_TDATA02                  = IOMUX_PAD(0x0320, 0x0094, 1, 0x0000, 0, 0),
+	MX6_PAD_UART2_TX_DATA__I2C4_SCL                       = IOMUX_PAD(0x0320, 0x0094, IOMUX_CONFIG_SION | 2, 0x05BC, 0, 0),
+	MX6_PAD_UART2_TX_DATA__CSI_DATA06                     = IOMUX_PAD(0x0320, 0x0094, 3, 0x04DC, 0, 0),
+	MX6_PAD_UART2_TX_DATA__GPT1_CAPTURE1                  = IOMUX_PAD(0x0320, 0x0094, 4, 0x058C, 1, 0),
+	MX6_PAD_UART2_TX_DATA__GPIO1_IO20                     = IOMUX_PAD(0x0320, 0x0094, 5, 0x0000, 0, 0),
+	MX6_PAD_UART2_TX_DATA__ECSPI3_SS0                     = IOMUX_PAD(0x0320, 0x0094, 8, 0x0560, 0, 0),
+
+	MX6_PAD_UART2_RX_DATA__UART2_DCE_RX                   = IOMUX_PAD(0x0324, 0x0098, 0, 0x062C, 1, 0),
+
+	MX6_PAD_UART2_RX_DATA__UART2_DTE_TX                   = IOMUX_PAD(0x0324, 0x0098, 0, 0x0000, 0, 0),
+	MX6_PAD_UART2_RX_DATA__ENET1_TDATA03                  = IOMUX_PAD(0x0324, 0x0098, 1, 0x0000, 0, 0),
+	MX6_PAD_UART2_RX_DATA__I2C4_SDA                       = IOMUX_PAD(0x0324, 0x0098, IOMUX_CONFIG_SION | 2, 0x05C0, 0, 0),
+	MX6_PAD_UART2_RX_DATA__CSI_DATA07                     = IOMUX_PAD(0x0324, 0x0098, 3, 0x04E0, 0, 0),
+	MX6_PAD_UART2_RX_DATA__GPT1_CAPTURE2                  = IOMUX_PAD(0x0324, 0x0098, 4, 0x0590, 0, 0),
+	MX6_PAD_UART2_RX_DATA__GPIO1_IO21                     = IOMUX_PAD(0x0324, 0x0098, 5, 0x0000, 0, 0),
+	MX6_PAD_UART2_RX_DATA__SJC_DONE                       = IOMUX_PAD(0x0324, 0x0098, 7, 0x0000, 0, 0),
+	MX6_PAD_UART2_RX_DATA__ECSPI3_SCLK                    = IOMUX_PAD(0x0324, 0x0098, 8, 0x0554, 0, 0),
+
+	MX6_PAD_UART2_CTS_B__UART2_DCE_CTS                    = IOMUX_PAD(0x0328, 0x009C, 0, 0x0000, 0, 0),
+
+	MX6_PAD_UART2_CTS_B__UART2_DTE_RTS                    = IOMUX_PAD(0x0328, 0x009C, 0, 0x0628, 0, 0),
+	MX6_PAD_UART2_CTS_B__ENET1_CRS                        = IOMUX_PAD(0x0328, 0x009C, 1, 0x0000, 0, 0),
+	MX6_PAD_UART2_CTS_B__FLEXCAN2_TX                      = IOMUX_PAD(0x0328, 0x009C, 2, 0x0000, 0, 0),
+	MX6_PAD_UART2_CTS_B__CSI_DATA08                       = IOMUX_PAD(0x0328, 0x009C, 3, 0x04E4, 0, 0),
+	MX6_PAD_UART2_CTS_B__GPT1_COMPARE2                    = IOMUX_PAD(0x0328, 0x009C, 4, 0x0000, 0, 0),
+	MX6_PAD_UART2_CTS_B__GPIO1_IO22                       = IOMUX_PAD(0x0328, 0x009C, 5, 0x0000, 0, 0),
+	MX6_PAD_UART2_CTS_B__SJC_DE_B                         = IOMUX_PAD(0x0328, 0x009C, 7, 0x0000, 0, 0),
+	MX6_PAD_UART2_CTS_B__ECSPI3_MOSI                      = IOMUX_PAD(0x0328, 0x009C, 8, 0x055C, 0, 0),
+
+	MX6_PAD_UART2_RTS_B__UART2_DCE_RTS                    = IOMUX_PAD(0x032C, 0x00A0, 0, 0x0628, 1, 0),
+
+	MX6_PAD_UART2_RTS_B__UART2_DTE_CTS                    = IOMUX_PAD(0x032C, 0x00A0, 0, 0x0000, 0, 0),
+	MX6_PAD_UART2_RTS_B__ENET1_COL                        = IOMUX_PAD(0x032C, 0x00A0, 1, 0x0000, 0, 0),
+	MX6_PAD_UART2_RTS_B__FLEXCAN2_RX                      = IOMUX_PAD(0x032C, 0x00A0, 2, 0x0588, 0, 0),
+	MX6_PAD_UART2_RTS_B__CSI_DATA09                       = IOMUX_PAD(0x032C, 0x00A0, 3, 0x04E8, 0, 0),
+	MX6_PAD_UART2_RTS_B__GPT1_COMPARE3                    = IOMUX_PAD(0x032C, 0x00A0, 4, 0x0000, 0, 0),
+	MX6_PAD_UART2_RTS_B__GPIO1_IO23                       = IOMUX_PAD(0x032C, 0x00A0, 5, 0x0000, 0, 0),
+	MX6_PAD_UART2_RTS_B__SJC_FAIL                         = IOMUX_PAD(0x032C, 0x00A0, 7, 0x0000, 0, 0),
+	MX6_PAD_UART2_RTS_B__ECSPI3_MISO                      = IOMUX_PAD(0x032C, 0x00A0, 8, 0x0558, 0, 0),
+
+	MX6_PAD_UART3_TX_DATA__UART3_DCE_TX                   = IOMUX_PAD(0x0330, 0x00A4, 0, 0x0000, 0, 0),
+
+	MX6_PAD_UART3_TX_DATA__UART3_DTE_RX                   = IOMUX_PAD(0x0330, 0x00A4, 0, 0x0634, 0, 0),
+	MX6_PAD_UART3_TX_DATA__ENET2_RDATA02                  = IOMUX_PAD(0x0330, 0x00A4, 1, 0x0000, 0, 0),
+	MX6_PAD_UART3_TX_DATA__SIM1_PORT0_PD                  = IOMUX_PAD(0x0330, 0x00A4, 2, 0x0000, 0, 0),
+	MX6_PAD_UART3_TX_DATA__CSI_DATA01                     = IOMUX_PAD(0x0330, 0x00A4, 3, 0x04D4, 0, 0),
+	MX6_PAD_UART3_TX_DATA__UART2_DCE_CTS                  = IOMUX_PAD(0x0330, 0x00A4, 4, 0x0000, 0, 0),
+	MX6_PAD_UART3_TX_DATA__UART2_DTE_RTS                  = IOMUX_PAD(0x0330, 0x00A4, 4, 0x0628, 2, 0),
+	MX6_PAD_UART3_TX_DATA__GPIO1_IO24                     = IOMUX_PAD(0x0330, 0x00A4, 5, 0x0000, 0, 0),
+	MX6_PAD_UART3_TX_DATA__SJC_JTAG_ACT                   = IOMUX_PAD(0x0330, 0x00A4, 7, 0x0000, 0, 0),
+	MX6_PAD_UART3_TX_DATA__ANATOP_OTG1_ID                 = IOMUX_PAD(0x0330, 0x00A4, 8, 0x04B8, 1, 0),
+
+	MX6_PAD_UART3_RX_DATA__UART3_DCE_RX                   = IOMUX_PAD(0x0334, 0x00A8, 0, 0x0634, 1, 0),
+
+	MX6_PAD_UART3_RX_DATA__UART3_DTE_TX                   = IOMUX_PAD(0x0334, 0x00A8, 0, 0x0000, 0, 0),
+	MX6_PAD_UART3_RX_DATA__ENET2_RDATA03                  = IOMUX_PAD(0x0334, 0x00A8, 1, 0x0000, 0, 0),
+	MX6_PAD_UART3_RX_DATA__SIM2_PORT0_PD                  = IOMUX_PAD(0x0334, 0x00A8, 2, 0x0000, 0, 0),
+	MX6_PAD_UART3_RX_DATA__CSI_DATA00                     = IOMUX_PAD(0x0334, 0x00A8, 3, 0x04D0, 0, 0),
+	MX6_PAD_UART3_RX_DATA__UART2_DCE_RTS                  = IOMUX_PAD(0x0334, 0x00A8, 4, 0x0628, 3, 0),
+	MX6_PAD_UART3_RX_DATA__UART2_DTE_CTS                  = IOMUX_PAD(0x0334, 0x00A8, 4, 0x0000, 0, 0),
+	MX6_PAD_UART3_RX_DATA__GPIO1_IO25                     = IOMUX_PAD(0x0334, 0x00A8, 5, 0x0000, 0, 0),
+	MX6_PAD_UART3_RX_DATA__EPIT1_OUT                      = IOMUX_PAD(0x0334, 0x00A8, 8, 0x0000, 0, 0),
+
+	MX6_PAD_UART3_CTS_B__UART3_DCE_CTS                    = IOMUX_PAD(0x0338, 0x00AC, 0, 0x0000, 0, 0),
+
+	MX6_PAD_UART3_CTS_B__UART3_DTE_RTS                    = IOMUX_PAD(0x0338, 0x00AC, 0, 0x0630, 0, 0),
+	MX6_PAD_UART3_CTS_B__ENET2_RX_CLK                     = IOMUX_PAD(0x0338, 0x00AC, IOMUX_CONFIG_SION | 1, 0x0000, 0, 0),
+	MX6_PAD_UART3_CTS_B__FLEXCAN1_TX                      = IOMUX_PAD(0x0338, 0x00AC, 2, 0x0000, 0, 0),
+	MX6_PAD_UART3_CTS_B__CSI_DATA10                       = IOMUX_PAD(0x0338, 0x00AC, 3, 0x04EC, 0, 0),
+	MX6_PAD_UART3_CTS_B__ENET1_1588_EVENT1_IN             = IOMUX_PAD(0x0338, 0x00AC, 4, 0x0000, 0, 0),
+	MX6_PAD_UART3_CTS_B__GPIO1_IO26                       = IOMUX_PAD(0x0338, 0x00AC, 5, 0x0000, 0, 0),
+	MX6_PAD_UART3_CTS_B__EPIT2_OUT                        = IOMUX_PAD(0x0338, 0x00AC, 8, 0x0000, 0, 0),
+
+	MX6_PAD_UART3_RTS_B__UART3_DCE_RTS                    = IOMUX_PAD(0x033C, 0x00B0, 0, 0x0630, 1, 0),
+
+	MX6_PAD_UART3_RTS_B__UART3_DTE_CTS                    = IOMUX_PAD(0x033C, 0x00B0, 0, 0x0000, 0, 0),
+	MX6_PAD_UART3_RTS_B__ENET2_TX_ER                      = IOMUX_PAD(0x033C, 0x00B0, 1, 0x0000, 0, 0),
+	MX6_PAD_UART3_RTS_B__FLEXCAN1_RX                      = IOMUX_PAD(0x033C, 0x00B0, 2, 0x0584, 0, 0),
+	MX6_PAD_UART3_RTS_B__CSI_DATA11                       = IOMUX_PAD(0x033C, 0x00B0, 3, 0x04F0, 0, 0),
+	MX6_PAD_UART3_RTS_B__ENET1_1588_EVENT1_OUT            = IOMUX_PAD(0x033C, 0x00B0, 4, 0x0000, 0, 0),
+	MX6_PAD_UART3_RTS_B__GPIO1_IO27                       = IOMUX_PAD(0x033C, 0x00B0, 5, 0x0000, 0, 0),
+	MX6_PAD_UART3_RTS_B__WDOG1_WDOG_B                     = IOMUX_PAD(0x033C, 0x00B0, 8, 0x0000, 0, 0),
+
+	MX6_PAD_UART4_TX_DATA__UART4_DCE_TX                   = IOMUX_PAD(0x0340, 0x00B4, 0, 0x0000, 0, 0),
+
+	MX6_PAD_UART4_TX_DATA__UART4_DTE_RX                   = IOMUX_PAD(0x0340, 0x00B4, 0, 0x063C, 0, 0),
+	MX6_PAD_UART4_TX_DATA__ENET2_TDATA02                  = IOMUX_PAD(0x0340, 0x00B4, 1, 0x0000, 0, 0),
+	MX6_PAD_UART4_TX_DATA__I2C1_SCL                       = IOMUX_PAD(0x0340, 0x00B4, IOMUX_CONFIG_SION | 2, 0x05A4, 1, 0),
+	MX6_PAD_UART4_TX_DATA__CSI_DATA12                     = IOMUX_PAD(0x0340, 0x00B4, 3, 0x04F4, 0, 0),
+	MX6_PAD_UART4_TX_DATA__CSU_CSU_ALARM_AUT02            = IOMUX_PAD(0x0340, 0x00B4, 4, 0x0000, 0, 0),
+	MX6_PAD_UART4_TX_DATA__GPIO1_IO28                     = IOMUX_PAD(0x0340, 0x00B4, 5, 0x0000, 0, 0),
+	MX6_PAD_UART4_TX_DATA__ECSPI2_SCLK                    = IOMUX_PAD(0x0340, 0x00B4, 8, 0x0544, 1, 0),
+
+	MX6_PAD_UART4_RX_DATA__UART4_DCE_RX                   = IOMUX_PAD(0x0344, 0x00B8, 0, 0x063C, 1, 0),
+
+	MX6_PAD_UART4_RX_DATA__UART4_DTE_TX                   = IOMUX_PAD(0x0344, 0x00B8, 0, 0x0000, 0, 0),
+	MX6_PAD_UART4_RX_DATA__ENET2_TDATA03                  = IOMUX_PAD(0x0344, 0x00B8, 1, 0x0000, 0, 0),
+	MX6_PAD_UART4_RX_DATA__I2C1_SDA                       = IOMUX_PAD(0x0344, 0x00B8, IOMUX_CONFIG_SION | 2, 0x05A8, 2, 0),
+	MX6_PAD_UART4_RX_DATA__CSI_DATA13                     = IOMUX_PAD(0x0344, 0x00B8, 3, 0x04F8, 0, 0),
+	MX6_PAD_UART4_RX_DATA__CSU_CSU_ALARM_AUT01            = IOMUX_PAD(0x0344, 0x00B8, 4, 0x0000, 0, 0),
+	MX6_PAD_UART4_RX_DATA__GPIO1_IO29                     = IOMUX_PAD(0x0344, 0x00B8, 5, 0x0000, 0, 0),
+	MX6_PAD_UART4_RX_DATA__ECSPI2_SS0                     = IOMUX_PAD(0x0344, 0x00B8, 8, 0x0550, 1, 0),
+	MX6_PAD_UART5_TX_DATA__GPIO1_IO30                     = IOMUX_PAD(0x0348, 0x00BC, 5, 0x0000, 0, 0),
+	MX6_PAD_UART5_TX_DATA__ECSPI2_MOSI                    = IOMUX_PAD(0x0348, 0x00BC, 8, 0x054C, 0, 0),
+
+	MX6_PAD_UART5_TX_DATA__UART5_DCE_TX                   = IOMUX_PAD(0x0348, 0x00BC, 0, 0x0000, 0, 0),
+
+	MX6_PAD_UART5_TX_DATA__UART5_DTE_RX                   = IOMUX_PAD(0x0348, 0x00BC, 0, 0x0644, 4, 0),
+	MX6_PAD_UART5_TX_DATA__ENET2_CRS                      = IOMUX_PAD(0x0348, 0x00BC, 1, 0x0000, 0, 0),
+	MX6_PAD_UART5_TX_DATA__I2C2_SCL                       = IOMUX_PAD(0x0348, 0x00BC, IOMUX_CONFIG_SION | 2, 0x05AC, 2, 0),
+	MX6_PAD_UART5_TX_DATA__CSI_DATA14                     = IOMUX_PAD(0x0348, 0x00BC, 3, 0x04FC, 0, 0),
+	MX6_PAD_UART5_TX_DATA__CSU_CSU_ALARM_AUT00            = IOMUX_PAD(0x0348, 0x00BC, 4, 0x0000, 0, 0),
+
+	MX6_PAD_UART5_RX_DATA__UART5_DCE_RX                   = IOMUX_PAD(0x034C, 0x00C0, 0, 0x0644, 5, 0),
+
+	MX6_PAD_UART5_RX_DATA__UART5_DTE_TX                   = IOMUX_PAD(0x034C, 0x00C0, 0, 0x0000, 0, 0),
+	MX6_PAD_UART5_RX_DATA__ENET2_COL                      = IOMUX_PAD(0x034C, 0x00C0, 1, 0x0000, 0, 0),
+	MX6_PAD_UART5_RX_DATA__I2C2_SDA                       = IOMUX_PAD(0x034C, 0x00C0, IOMUX_CONFIG_SION | 2, 0x05B0, 2, 0),
+	MX6_PAD_UART5_RX_DATA__CSI_DATA15                     = IOMUX_PAD(0x034C, 0x00C0, 3, 0x0500, 0, 0),
+	MX6_PAD_UART5_RX_DATA__CSU_CSU_INT_DEB                = IOMUX_PAD(0x034C, 0x00C0, 4, 0x0000, 0, 0),
+	MX6_PAD_UART5_RX_DATA__GPIO1_IO31                     = IOMUX_PAD(0x034C, 0x00C0, 5, 0x0000, 0, 0),
+	MX6_PAD_UART5_RX_DATA__ECSPI2_MISO                    = IOMUX_PAD(0x034C, 0x00C0, 8, 0x0548, 1, 0),
+
+	MX6_PAD_ENET1_RX_DATA0__ENET1_RDATA00                 = IOMUX_PAD(0x0350, 0x00C4, 0, 0x0000, 0, 0),
+	MX6_PAD_ENET1_RX_DATA0__UART4_DCE_RTS                 = IOMUX_PAD(0x0350, 0x00C4, 1, 0x0638, 0, 0),
+	MX6_PAD_ENET1_RX_DATA0__UART4_DTE_CTS                 = IOMUX_PAD(0x0350, 0x00C4, 1, 0x0000, 0, 0),
+	MX6_PAD_ENET1_RX_DATA0__PWM1_OUT                      = IOMUX_PAD(0x0350, 0x00C4, 2, 0x0000, 0, 0),
+	MX6_PAD_ENET1_RX_DATA0__CSI_DATA16                    = IOMUX_PAD(0x0350, 0x00C4, 3, 0x0504, 0, 0),
+	MX6_PAD_ENET1_RX_DATA0__FLEXCAN1_TX                   = IOMUX_PAD(0x0350, 0x00C4, 4, 0x0000, 0, 0),
+	MX6_PAD_ENET1_RX_DATA0__GPIO2_IO00                    = IOMUX_PAD(0x0350, 0x00C4, 5, 0x0000, 0, 0),
+	MX6_PAD_ENET1_RX_DATA0__KPP_ROW00                     = IOMUX_PAD(0x0350, 0x00C4, 6, 0x05D0, 0, 0),
+	MX6_PAD_ENET1_RX_DATA0__USDHC1_LCTL                   = IOMUX_PAD(0x0350, 0x00C4, 8, 0x0000, 0, 0),
+
+	MX6_PAD_ENET1_RX_DATA1__ENET1_RDATA01                 = IOMUX_PAD(0x0354, 0x00C8, 0, 0x0000, 0, 0),
+	MX6_PAD_ENET1_RX_DATA1__UART4_DCE_CTS                 = IOMUX_PAD(0x0354, 0x00C8, 1, 0x0000, 0, 0),
+	MX6_PAD_ENET1_RX_DATA1__UART4_DTE_RTS                 = IOMUX_PAD(0x0354, 0x00C8, 1, 0x0638, 1, 0),
+	MX6_PAD_ENET1_RX_DATA1__PWM2_OUT                      = IOMUX_PAD(0x0354, 0x00C8, 2, 0x0000, 0, 0),
+	MX6_PAD_ENET1_RX_DATA1__CSI_DATA17                    = IOMUX_PAD(0x0354, 0x00C8, 3, 0x0508, 0, 0),
+	MX6_PAD_ENET1_RX_DATA1__FLEXCAN1_RX                   = IOMUX_PAD(0x0354, 0x00C8, 4, 0x0584, 1, 0),
+	MX6_PAD_ENET1_RX_DATA1__GPIO2_IO01                    = IOMUX_PAD(0x0354, 0x00C8, 5, 0x0000, 0, 0),
+	MX6_PAD_ENET1_RX_DATA1__KPP_COL00                     = IOMUX_PAD(0x0354, 0x00C8, 6, 0x05C4, 0, 0),
+	MX6_PAD_ENET1_RX_DATA1__USDHC2_LCTL                   = IOMUX_PAD(0x0354, 0x00C8, 8, 0x0000, 0, 0),
+
+	MX6_PAD_ENET1_RX_EN__ENET1_RX_EN                      = IOMUX_PAD(0x0358, 0x00CC, 0, 0x0000, 0, 0),
+	MX6_PAD_ENET1_RX_EN__UART5_DCE_RTS                    = IOMUX_PAD(0x0358, 0x00CC, 1, 0x0640, 3, 0),
+	MX6_PAD_ENET1_RX_EN__UART5_DTE_CTS                    = IOMUX_PAD(0x0358, 0x00CC, 1, 0x0000, 0, 0),
+	MX6_PAD_ENET1_RX_EN__CSI_DATA18                       = IOMUX_PAD(0x0358, 0x00CC, 3, 0x050C, 0, 0),
+	MX6_PAD_ENET1_RX_EN__FLEXCAN2_TX                      = IOMUX_PAD(0x0358, 0x00CC, 4, 0x0000, 0, 0),
+	MX6_PAD_ENET1_RX_EN__GPIO2_IO02                       = IOMUX_PAD(0x0358, 0x00CC, 5, 0x0000, 0, 0),
+	MX6_PAD_ENET1_RX_EN__KPP_ROW01                        = IOMUX_PAD(0x0358, 0x00CC, 6, 0x05D4, 0, 0),
+	MX6_PAD_ENET1_RX_EN__USDHC1_VSELECT                   = IOMUX_PAD(0x0358, 0x00CC, 8, 0x0000, 0, 0),
+
+	MX6_PAD_ENET1_TX_DATA0__ENET1_TDATA00                 = IOMUX_PAD(0x035C, 0x00D0, 0, 0x0000, 0, 0),
+	MX6_PAD_ENET1_TX_DATA0__UART5_DCE_CTS                 = IOMUX_PAD(0x035C, 0x00D0, 1, 0x0000, 0, 0),
+	MX6_PAD_ENET1_TX_DATA0__UART5_DTE_RTS                 = IOMUX_PAD(0x035C, 0x00D0, 1, 0x0640, 4, 0),
+	MX6_PAD_ENET1_TX_DATA0__CSI_DATA19                    = IOMUX_PAD(0x035C, 0x00D0, 3, 0x0510, 0, 0),
+	MX6_PAD_ENET1_TX_DATA0__FLEXCAN2_RX                   = IOMUX_PAD(0x035C, 0x00D0, 4, 0x0588, 1, 0),
+	MX6_PAD_ENET1_TX_DATA0__GPIO2_IO03                    = IOMUX_PAD(0x035C, 0x00D0, 5, 0x0000, 0, 0),
+	MX6_PAD_ENET1_TX_DATA0__KPP_COL01                     = IOMUX_PAD(0x035C, 0x00D0, 6, 0x05C8, 0, 0),
+	MX6_PAD_ENET1_TX_DATA0__USDHC2_VSELECT                = IOMUX_PAD(0x035C, 0x00D0, 8, 0x0000, 0, 0),
+
+	MX6_PAD_ENET1_TX_DATA1__ENET1_TDATA01                 = IOMUX_PAD(0x0360, 0x00D4, 0, 0x0000, 0, 0),
+	MX6_PAD_ENET1_TX_DATA1__UART6_DCE_CTS                 = IOMUX_PAD(0x0360, 0x00D4, 1, 0x0000, 0, 0),
+	MX6_PAD_ENET1_TX_DATA1__UART6_DTE_RTS                 = IOMUX_PAD(0x0360, 0x00D4, 1, 0x0648, 2, 0),
+	MX6_PAD_ENET1_TX_DATA1__PWM5_OUT                      = IOMUX_PAD(0x0360, 0x00D4, 2, 0x0000, 0, 0),
+	MX6_PAD_ENET1_TX_DATA1__CSI_DATA20                    = IOMUX_PAD(0x0360, 0x00D4, 3, 0x0514, 0, 0),
+	MX6_PAD_ENET1_TX_DATA1__ENET2_MDIO                    = IOMUX_PAD(0x0360, 0x00D4, 4, 0x0580, 1, 0),
+	MX6_PAD_ENET1_TX_DATA1__GPIO2_IO04                    = IOMUX_PAD(0x0360, 0x00D4, 5, 0x0000, 0, 0),
+	MX6_PAD_ENET1_TX_DATA1__KPP_ROW02                     = IOMUX_PAD(0x0360, 0x00D4, 6, 0x05D8, 0, 0),
+	MX6_PAD_ENET1_TX_DATA1__WDOG1_WDOG_RST_B_DEB          = IOMUX_PAD(0x0360, 0x00D4, 8, 0x0000, 0, 0),
+
+	MX6_PAD_ENET1_TX_EN__ENET1_TX_EN                      = IOMUX_PAD(0x0364, 0x00D8, 0, 0x0000, 0, 0),
+	MX6_PAD_ENET1_TX_EN__UART6_DCE_RTS                    = IOMUX_PAD(0x0364, 0x00D8, 1, 0x0648, 3, 0),
+	MX6_PAD_ENET1_TX_EN__UART6_DTE_CTS                    = IOMUX_PAD(0x0364, 0x00D8, 1, 0x0000, 0, 0),
+	MX6_PAD_ENET1_TX_EN__PWM6_OUT                         = IOMUX_PAD(0x0364, 0x00D8, 2, 0x0000, 0, 0),
+	MX6_PAD_ENET1_TX_EN__CSI_DATA21                       = IOMUX_PAD(0x0364, 0x00D8, 3, 0x0518, 0, 0),
+	MX6_PAD_ENET1_TX_EN__ENET2_MDC                        = IOMUX_PAD(0x0364, 0x00D8, 4, 0x0000, 0, 0),
+	MX6_PAD_ENET1_TX_EN__GPIO2_IO05                       = IOMUX_PAD(0x0364, 0x00D8, 5, 0x0000, 0, 0),
+	MX6_PAD_ENET1_TX_EN__KPP_COL02                        = IOMUX_PAD(0x0364, 0x00D8, 6, 0x05CC, 0, 0),
+	MX6_PAD_ENET1_TX_EN__WDOG2_WDOG_RST_B_DEB             = IOMUX_PAD(0x0364, 0x00D8, 8, 0x0000, 0, 0),
+
+	MX6_PAD_ENET1_TX_CLK__ENET1_TX_CLK                    = IOMUX_PAD(0x0368, 0x00DC, 0, 0x0000, 0, 0),
+	MX6_PAD_ENET1_TX_CLK__UART7_DCE_CTS                   = IOMUX_PAD(0x0368, 0x00DC, 1, 0x0000, 0, 0),
+	MX6_PAD_ENET1_TX_CLK__UART7_DTE_RTS                   = IOMUX_PAD(0x0368, 0x00DC, 1, 0x0650, 0, 0),
+	MX6_PAD_ENET1_TX_CLK__PWM7_OUT                        = IOMUX_PAD(0x0368, 0x00DC, 2, 0x0000, 0, 0),
+	MX6_PAD_ENET1_TX_CLK__CSI_DATA22                      = IOMUX_PAD(0x0368, 0x00DC, 3, 0x051C, 0, 0),
+	MX6_PAD_ENET1_TX_CLK__ENET1_REF_CLK1                  = IOMUX_PAD(0x0368, 0x00DC, IOMUX_CONFIG_SION | 4, 0x0574, 2, 0),
+	MX6_PAD_ENET1_TX_CLK__GPIO2_IO06                      = IOMUX_PAD(0x0368, 0x00DC, 5, 0x0000, 0, 0),
+	MX6_PAD_ENET1_TX_CLK__KPP_ROW03                       = IOMUX_PAD(0x0368, 0x00DC, 6, 0x0000, 0, 0),
+	MX6_PAD_ENET1_TX_CLK__GPT1_CLK                        = IOMUX_PAD(0x0368, 0x00DC, 8, 0x0594, 1, 0),
+
+	MX6_PAD_ENET1_RX_ER__ENET1_RX_ER                      = IOMUX_PAD(0x036C, 0x00E0, 0, 0x0000, 0, 0),
+	MX6_PAD_ENET1_RX_ER__UART7_DCE_RTS                    = IOMUX_PAD(0x036C, 0x00E0, 1, 0x0650, 1, 0),
+	MX6_PAD_ENET1_RX_ER__UART7_DTE_CTS                    = IOMUX_PAD(0x036C, 0x00E0, 1, 0x0000, 0, 0),
+	MX6_PAD_ENET1_RX_ER__PWM8_OUT                         = IOMUX_PAD(0x036C, 0x00E0, 2, 0x0000, 0, 0),
+	MX6_PAD_ENET1_RX_ER__CSI_DATA23                       = IOMUX_PAD(0x036C, 0x00E0, 3, 0x0520, 0, 0),
+	MX6_PAD_ENET1_RX_ER__EIM_CRE                          = IOMUX_PAD(0x036C, 0x00E0, 4, 0x0000, 0, 0),
+	MX6_PAD_ENET1_RX_ER__GPIO2_IO07                       = IOMUX_PAD(0x036C, 0x00E0, 5, 0x0000, 0, 0),
+	MX6_PAD_ENET1_RX_ER__KPP_COL03                        = IOMUX_PAD(0x036C, 0x00E0, 6, 0x0000, 0, 0),
+	MX6_PAD_ENET1_RX_ER__GPT1_CAPTURE2                    = IOMUX_PAD(0x036C, 0x00E0, 8, 0x0590, 1, 0),
+
+	MX6_PAD_ENET2_RX_DATA0__ENET2_RDATA00                 = IOMUX_PAD(0x0370, 0x00E4, 0, 0x0000, 0, 0),
+	MX6_PAD_ENET2_RX_DATA0__UART6_DCE_TX                  = IOMUX_PAD(0x0370, 0x00E4, 1, 0x0000, 0, 0),
+	MX6_PAD_ENET2_RX_DATA0__UART6_DTE_RX                  = IOMUX_PAD(0x0370, 0x00E4, 1, 0x064C, 1, 0),
+	MX6_PAD_ENET2_RX_DATA0__SIM1_PORT0_TRXD               = IOMUX_PAD(0x0370, 0x00E4, 2, 0x0000, 0, 0),
+	MX6_PAD_ENET2_RX_DATA0__I2C3_SCL                      = IOMUX_PAD(0x0370, 0x00E4, IOMUX_CONFIG_SION | 3, 0x05B4, 1, 0),
+	MX6_PAD_ENET2_RX_DATA0__ENET1_MDIO                    = IOMUX_PAD(0x0370, 0x00E4, 4, 0x0578, 1, 0),
+	MX6_PAD_ENET2_RX_DATA0__GPIO2_IO08                    = IOMUX_PAD(0x0370, 0x00E4, 5, 0x0000, 0, 0),
+	MX6_PAD_ENET2_RX_DATA0__KPP_ROW04                     = IOMUX_PAD(0x0370, 0x00E4, 6, 0x0000, 0, 0),
+	MX6_PAD_ENET2_RX_DATA0__USB_OTG1_PWR                  = IOMUX_PAD(0x0370, 0x00E4, 8, 0x0000, 0, 0),
+
+	MX6_PAD_ENET2_RX_DATA1__ENET2_RDATA01                 = IOMUX_PAD(0x0374, 0x00E8, 0, 0x0000, 0, 0),
+	MX6_PAD_ENET2_RX_DATA1__UART6_DCE_RX                  = IOMUX_PAD(0x0374, 0x00E8, 1, 0x064C, 2, 0),
+	MX6_PAD_ENET2_RX_DATA1__UART6_DTE_TX                  = IOMUX_PAD(0x0374, 0x00E8, 1, 0x0000, 0, 0),
+	MX6_PAD_ENET2_RX_DATA1__SIM1_PORT0_CLK                = IOMUX_PAD(0x0374, 0x00E8, 2, 0x0000, 0, 0),
+	MX6_PAD_ENET2_RX_DATA1__I2C3_SDA                      = IOMUX_PAD(0x0374, 0x00E8, IOMUX_CONFIG_SION | 3, 0x05B8, 1, 0),
+	MX6_PAD_ENET2_RX_DATA1__ENET1_MDC                     = IOMUX_PAD(0x0374, 0x00E8, 4, 0x0000, 0, 0),
+	MX6_PAD_ENET2_RX_DATA1__GPIO2_IO09                    = IOMUX_PAD(0x0374, 0x00E8, 5, 0x0000, 0, 0),
+	MX6_PAD_ENET2_RX_DATA1__KPP_COL04                     = IOMUX_PAD(0x0374, 0x00E8, 6, 0x0000, 0, 0),
+	MX6_PAD_ENET2_RX_DATA1__USB_OTG1_OC                   = IOMUX_PAD(0x0374, 0x00E8, 8, 0x0664, 1, 0),
+
+	MX6_PAD_ENET2_RX_EN__ENET2_RX_EN                      = IOMUX_PAD(0x0378, 0x00EC, 0, 0x0000, 0, 0),
+	MX6_PAD_ENET2_RX_EN__UART7_DCE_TX                     = IOMUX_PAD(0x0378, 0x00EC, 1, 0x0000, 0, 0),
+	MX6_PAD_ENET2_RX_EN__UART7_DTE_RX                     = IOMUX_PAD(0x0378, 0x00EC, 1, 0x0654, 0, 0),
+	MX6_PAD_ENET2_RX_EN__SIM1_PORT0_RST_B                 = IOMUX_PAD(0x0378, 0x00EC, 2, 0x0000, 0, 0),
+	MX6_PAD_ENET2_RX_EN__I2C4_SCL                         = IOMUX_PAD(0x0378, 0x00EC, IOMUX_CONFIG_SION | 3, 0x05BC, 1, 0),
+	MX6_PAD_ENET2_RX_EN__EIM_ADDR26                       = IOMUX_PAD(0x0378, 0x00EC, 4, 0x0000, 0, 0),
+	MX6_PAD_ENET2_RX_EN__GPIO2_IO10                       = IOMUX_PAD(0x0378, 0x00EC, 5, 0x0000, 0, 0),
+	MX6_PAD_ENET2_RX_EN__KPP_ROW05                        = IOMUX_PAD(0x0378, 0x00EC, 6, 0x0000, 0, 0),
+	MX6_PAD_ENET2_RX_EN__ENET1_REF_CLK_25M                = IOMUX_PAD(0x0378, 0x00EC, 8, 0x0000, 0, 0),
+
+	MX6_PAD_ENET2_TX_DATA0__ENET2_TDATA00                 = IOMUX_PAD(0x037C, 0x00F0, 0, 0x0000, 0, 0),
+	MX6_PAD_ENET2_TX_DATA0__UART7_DCE_RX                  = IOMUX_PAD(0x037C, 0x00F0, 1, 0x0654, 1, 0),
+	MX6_PAD_ENET2_TX_DATA0__UART7_DTE_TX                  = IOMUX_PAD(0x037C, 0x00F0, 1, 0x0000, 0, 0),
+	MX6_PAD_ENET2_TX_DATA0__SIM1_PORT0_SVEN               = IOMUX_PAD(0x037C, 0x00F0, 2, 0x0000, 0, 0),
+	MX6_PAD_ENET2_TX_DATA0__I2C4_SDA                      = IOMUX_PAD(0x037C, 0x00F0, IOMUX_CONFIG_SION | 3, 0x05C0, 1, 0),
+	MX6_PAD_ENET2_TX_DATA0__EIM_EB_B02                    = IOMUX_PAD(0x037C, 0x00F0, 4, 0x0000, 0, 0),
+	MX6_PAD_ENET2_TX_DATA0__GPIO2_IO11                    = IOMUX_PAD(0x037C, 0x00F0, 5, 0x0000, 0, 0),
+	MX6_PAD_ENET2_TX_DATA0__KPP_COL05                     = IOMUX_PAD(0x037C, 0x00F0, 6, 0x0000, 0, 0),
+
+	MX6_PAD_ENET2_TX_DATA1__ENET2_TDATA01                 = IOMUX_PAD(0x0380, 0x00F4, 0, 0x0000, 0, 0),
+	MX6_PAD_ENET2_TX_DATA1__UART8_DCE_TX                  = IOMUX_PAD(0x0380, 0x00F4, 1, 0x0000, 0, 0),
+	MX6_PAD_ENET2_TX_DATA1__UART8_DTE_RX                  = IOMUX_PAD(0x0380, 0x00F4, 1, 0x065C, 0, 0),
+	MX6_PAD_ENET2_TX_DATA1__SIM2_PORT0_TRXD               = IOMUX_PAD(0x0380, 0x00F4, 2, 0x0000, 0, 0),
+	MX6_PAD_ENET2_TX_DATA1__ECSPI4_SCLK                   = IOMUX_PAD(0x0380, 0x00F4, 3, 0x0564, 0, 0),
+	MX6_PAD_ENET2_TX_DATA1__EIM_EB_B03                    = IOMUX_PAD(0x0380, 0x00F4, 4, 0x0000, 0, 0),
+	MX6_PAD_ENET2_TX_DATA1__GPIO2_IO12                    = IOMUX_PAD(0x0380, 0x00F4, 5, 0x0000, 0, 0),
+	MX6_PAD_ENET2_TX_DATA1__KPP_ROW06                     = IOMUX_PAD(0x0380, 0x00F4, 6, 0x0000, 0, 0),
+	MX6_PAD_ENET2_TX_DATA1__USB_OTG2_PWR                  = IOMUX_PAD(0x0380, 0x00F4, 8, 0x0000, 0, 0),
+
+	MX6_PAD_ENET2_TX_EN__ENET2_TX_EN                      = IOMUX_PAD(0x0384, 0x00F8, 0, 0x0000, 0, 0),
+	MX6_PAD_ENET2_TX_EN__UART8_DCE_RX                     = IOMUX_PAD(0x0384, 0x00F8, 1, 0x065C, 1, 0),
+	MX6_PAD_ENET2_TX_EN__UART8_DTE_TX                     = IOMUX_PAD(0x0384, 0x00F8, 1, 0x0000, 0, 0),
+	MX6_PAD_ENET2_TX_EN__SIM2_PORT0_CLK                   = IOMUX_PAD(0x0384, 0x00F8, 2, 0x0000, 0, 0),
+	MX6_PAD_ENET2_TX_EN__ECSPI4_MOSI                      = IOMUX_PAD(0x0384, 0x00F8, 3, 0x056C, 0, 0),
+	MX6_PAD_ENET2_TX_EN__EIM_ACLK_FREERUN                 = IOMUX_PAD(0x0384, 0x00F8, 4, 0x0000, 0, 0),
+	MX6_PAD_ENET2_TX_EN__GPIO2_IO13                       = IOMUX_PAD(0x0384, 0x00F8, 5, 0x0000, 0, 0),
+	MX6_PAD_ENET2_TX_EN__KPP_COL06                        = IOMUX_PAD(0x0384, 0x00F8, 6, 0x0000, 0, 0),
+	MX6_PAD_ENET2_TX_EN__USB_OTG2_OC                      = IOMUX_PAD(0x0384, 0x00F8, 8, 0x0660, 1, 0),
+
+	MX6_PAD_ENET2_TX_CLK__ENET2_TX_CLK                    = IOMUX_PAD(0x0388, 0x00FC, IOMUX_CONFIG_SION | 0, 0x0000, 0, 0),
+	MX6_PAD_ENET2_TX_CLK__UART8_DCE_CTS                   = IOMUX_PAD(0x0388, 0x00FC, 1, 0x0000, 0, 0),
+	MX6_PAD_ENET2_TX_CLK__UART8_DTE_RTS                   = IOMUX_PAD(0x0388, 0x00FC, 1, 0x0658, 0, 0),
+	MX6_PAD_ENET2_TX_CLK__SIM2_PORT0_RST_B                = IOMUX_PAD(0x0388, 0x00FC, 2, 0x0000, 0, 0),
+	MX6_PAD_ENET2_TX_CLK__ECSPI4_MISO                     = IOMUX_PAD(0x0388, 0x00FC, 3, 0x0568, 0, 0),
+	MX6_PAD_ENET2_TX_CLK__ENET2_REF_CLK2                  = IOMUX_PAD(0x0388, 0x00FC, IOMUX_CONFIG_SION | 4, 0x057C, 2, 0),
+	MX6_PAD_ENET2_TX_CLK__GPIO2_IO14                      = IOMUX_PAD(0x0388, 0x00FC, 5, 0x0000, 0, 0),
+	MX6_PAD_ENET2_TX_CLK__KPP_ROW07                       = IOMUX_PAD(0x0388, 0x00FC, 6, 0x0000, 0, 0),
+	MX6_PAD_ENET2_TX_CLK__ANATOP_OTG2_ID                  = IOMUX_PAD(0x0388, 0x00FC, 8, 0x04BC, 1, 0),
+
+	MX6_PAD_ENET2_RX_ER__ENET2_RX_ER                      = IOMUX_PAD(0x038C, 0x0100, 0, 0x0000, 0, 0),
+	MX6_PAD_ENET2_RX_ER__UART8_DCE_RTS                    = IOMUX_PAD(0x038C, 0x0100, 1, 0x0658, 1, 0),
+	MX6_PAD_ENET2_RX_ER__UART8_DTE_CTS                    = IOMUX_PAD(0x038C, 0x0100, 1, 0x0000, 0, 0),
+	MX6_PAD_ENET2_RX_ER__SIM2_PORT0_SVEN                  = IOMUX_PAD(0x038C, 0x0100, 2, 0x0000, 0, 0),
+	MX6_PAD_ENET2_RX_ER__ECSPI4_SS0                       = IOMUX_PAD(0x038C, 0x0100, 3, 0x0570, 0, 0),
+	MX6_PAD_ENET2_RX_ER__EIM_ADDR25                       = IOMUX_PAD(0x038C, 0x0100, 4, 0x0000, 0, 0),
+	MX6_PAD_ENET2_RX_ER__GPIO2_IO15                       = IOMUX_PAD(0x038C, 0x0100, 5, 0x0000, 0, 0),
+	MX6_PAD_ENET2_RX_ER__KPP_COL07                        = IOMUX_PAD(0x038C, 0x0100, 6, 0x0000, 0, 0),
+	MX6_PAD_ENET2_RX_ER__WDOG1_WDOG_ANY                   = IOMUX_PAD(0x038C, 0x0100, 8, 0x0000, 0, 0),
+
+	MX6_PAD_LCD_CLK__LCDIF_CLK                            = IOMUX_PAD(0x0390, 0x0104, 0, 0x0000, 0, 0),
+	MX6_PAD_LCD_CLK__LCDIF_WR_RWN                         = IOMUX_PAD(0x0390, 0x0104, 1, 0x0000, 0, 0),
+	MX6_PAD_LCD_CLK__UART4_DCE_TX                         = IOMUX_PAD(0x0390, 0x0104, 2, 0x0000, 0, 0),
+	MX6_PAD_LCD_CLK__UART4_DTE_RX                         = IOMUX_PAD(0x0390, 0x0104, 2, 0x063C, 2, 0),
+	MX6_PAD_LCD_CLK__SAI3_MCLK                            = IOMUX_PAD(0x0390, 0x0104, 3, 0x0600, 0, 0),
+	MX6_PAD_LCD_CLK__EIM_CS2_B                            = IOMUX_PAD(0x0390, 0x0104, 4, 0x0000, 0, 0),
+	MX6_PAD_LCD_CLK__GPIO3_IO00                           = IOMUX_PAD(0x0390, 0x0104, 5, 0x0000, 0, 0),
+	MX6_PAD_LCD_CLK__WDOG1_WDOG_RST_B_DEB                 = IOMUX_PAD(0x0390, 0x0104, 8, 0x0000, 0, 0),
+
+	MX6_PAD_LCD_ENABLE__LCDIF_ENABLE                      = IOMUX_PAD(0x0394, 0x0108, 0, 0x0000, 0, 0),
+	MX6_PAD_LCD_ENABLE__LCDIF_RD_E                        = IOMUX_PAD(0x0394, 0x0108, 1, 0x0000, 0, 0),
+	MX6_PAD_LCD_ENABLE__UART4_DCE_RX                      = IOMUX_PAD(0x0394, 0x0108, 2, 0x063C, 3, 0),
+	MX6_PAD_LCD_ENABLE__UART4_DTE_TX                      = IOMUX_PAD(0x0394, 0x0108, 2, 0x0000, 0, 0),
+	MX6_PAD_LCD_ENABLE__SAI3_TX_SYNC                      = IOMUX_PAD(0x0394, 0x0108, 3, 0x060C, 0, 0),
+	MX6_PAD_LCD_ENABLE__EIM_CS3_B                         = IOMUX_PAD(0x0394, 0x0108, 4, 0x0000, 0, 0),
+	MX6_PAD_LCD_ENABLE__GPIO3_IO01                        = IOMUX_PAD(0x0394, 0x0108, 5, 0x0000, 0, 0),
+	MX6_PAD_LCD_ENABLE__ECSPI2_RDY                        = IOMUX_PAD(0x0394, 0x0108, 8, 0x0000, 0, 0),
+
+	MX6_PAD_LCD_HSYNC__LCDIF_HSYNC                        = IOMUX_PAD(0x0398, 0x010C, 0, 0x05DC, 0, 0),
+	MX6_PAD_LCD_HSYNC__LCDIF_RS                           = IOMUX_PAD(0x0398, 0x010C, 1, 0x0000, 0, 0),
+	MX6_PAD_LCD_HSYNC__UART4_DCE_CTS                      = IOMUX_PAD(0x0398, 0x010C, 2, 0x0000, 0, 0),
+	MX6_PAD_LCD_HSYNC__UART4_DTE_RTS                      = IOMUX_PAD(0x0398, 0x010C, 2, 0x0638, 2, 0),
+	MX6_PAD_LCD_HSYNC__SAI3_TX_BCLK                       = IOMUX_PAD(0x0398, 0x010C, 3, 0x0608, 0, 0),
+	MX6_PAD_LCD_HSYNC__WDOG3_WDOG_RST_B_DEB               = IOMUX_PAD(0x0398, 0x010C, 4, 0x0000, 0, 0),
+	MX6_PAD_LCD_HSYNC__GPIO3_IO02                         = IOMUX_PAD(0x0398, 0x010C, 5, 0x0000, 0, 0),
+	MX6_PAD_LCD_HSYNC__ECSPI2_SS1                         = IOMUX_PAD(0x0398, 0x010C, 8, 0x0000, 0, 0),
+
+	MX6_PAD_LCD_VSYNC__LCDIF_VSYNC                        = IOMUX_PAD(0x039C, 0x0110, 0, 0x0000, 0, 0),
+	MX6_PAD_LCD_VSYNC__LCDIF_BUSY                         = IOMUX_PAD(0x039C, 0x0110, 1, 0x05DC, 1, 0),
+	MX6_PAD_LCD_VSYNC__UART4_DCE_RTS                      = IOMUX_PAD(0x039C, 0x0110, 2, 0x0638, 3, 0),
+	MX6_PAD_LCD_VSYNC__UART4_DTE_CTS                      = IOMUX_PAD(0x039C, 0x0110, 2, 0x0000, 0, 0),
+	MX6_PAD_LCD_VSYNC__SAI3_RX_DATA                       = IOMUX_PAD(0x039C, 0x0110, 3, 0x0604, 0, 0),
+	MX6_PAD_LCD_VSYNC__WDOG2_WDOG_B                       = IOMUX_PAD(0x039C, 0x0110, 4, 0x0000, 0, 0),
+	MX6_PAD_LCD_VSYNC__GPIO3_IO03                         = IOMUX_PAD(0x039C, 0x0110, 5, 0x0000, 0, 0),
+	MX6_PAD_LCD_VSYNC__ECSPI2_SS2                         = IOMUX_PAD(0x039C, 0x0110, 8, 0x0000, 0, 0),
+
+	MX6_PAD_LCD_RESET__LCDIF_RESET                        = IOMUX_PAD(0x03A0, 0x0114, 0, 0x0000, 0, 0),
+	MX6_PAD_LCD_RESET__LCDIF_CS                           = IOMUX_PAD(0x03A0, 0x0114, 1, 0x0000, 0, 0),
+	MX6_PAD_LCD_RESET__CA7_MX6ULL_EVENTI                  = IOMUX_PAD(0x03A0, 0x0114, 2, 0x0000, 0, 0),
+	MX6_PAD_LCD_RESET__SAI3_TX_DATA                       = IOMUX_PAD(0x03A0, 0x0114, 3, 0x0000, 0, 0),
+	MX6_PAD_LCD_RESET__WDOG1_WDOG_ANY                     = IOMUX_PAD(0x03A0, 0x0114, 4, 0x0000, 0, 0),
+	MX6_PAD_LCD_RESET__GPIO3_IO04                         = IOMUX_PAD(0x03A0, 0x0114, 5, 0x0000, 0, 0),
+	MX6_PAD_LCD_RESET__ECSPI2_SS3                         = IOMUX_PAD(0x03A0, 0x0114, 8, 0x0000, 0, 0),
+
+	MX6_PAD_LCD_DATA00__LCDIF_DATA00                      = IOMUX_PAD(0x03A4, 0x0118, 0, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA00__PWM1_OUT                          = IOMUX_PAD(0x03A4, 0x0118, 1, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA00__ENET1_1588_EVENT2_IN              = IOMUX_PAD(0x03A4, 0x0118, 3, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA00__I2C3_SDA                          = IOMUX_PAD(0x03A4, 0x0118, IOMUX_CONFIG_SION | 4, 0x05B8, 2, 0),
+	MX6_PAD_LCD_DATA00__GPIO3_IO05                        = IOMUX_PAD(0x03A4, 0x0118, 5, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA00__SRC_BT_CFG00                      = IOMUX_PAD(0x03A4, 0x0118, 6, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA00__SAI1_MCLK                         = IOMUX_PAD(0x03A4, 0x0118, 8, 0x05E0, 1, 0),
+
+	MX6_PAD_LCD_DATA01__LCDIF_DATA01                      = IOMUX_PAD(0x03A8, 0x011C, 0, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA01__PWM2_OUT                          = IOMUX_PAD(0x03A8, 0x011C, 1, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA01__ENET1_1588_EVENT2_OUT             = IOMUX_PAD(0x03A8, 0x011C, 3, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA01__I2C3_SCL                          = IOMUX_PAD(0x03A8, 0x011C, IOMUX_CONFIG_SION | 4, 0x05B4, 2, 0),
+	MX6_PAD_LCD_DATA01__GPIO3_IO06                        = IOMUX_PAD(0x03A8, 0x011C, 5, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA01__SRC_BT_CFG01                      = IOMUX_PAD(0x03A8, 0x011C, 6, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA01__SAI1_TX_SYNC                      = IOMUX_PAD(0x03A8, 0x011C, 8, 0x05EC, 0, 0),
+
+	MX6_PAD_LCD_DATA02__LCDIF_DATA02                      = IOMUX_PAD(0x03AC, 0x0120, 0, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA02__PWM3_OUT                          = IOMUX_PAD(0x03AC, 0x0120, 1, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA02__ENET1_1588_EVENT3_IN              = IOMUX_PAD(0x03AC, 0x0120, 3, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA02__I2C4_SDA                          = IOMUX_PAD(0x03AC, 0x0120, IOMUX_CONFIG_SION | 4, 0x05C0, 2, 0),
+	MX6_PAD_LCD_DATA02__GPIO3_IO07                        = IOMUX_PAD(0x03AC, 0x0120, 5, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA02__SRC_BT_CFG02                      = IOMUX_PAD(0x03AC, 0x0120, 6, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA02__SAI1_TX_BCLK                      = IOMUX_PAD(0x03AC, 0x0120, 8, 0x05E8, 0, 0),
+
+	MX6_PAD_LCD_DATA03__LCDIF_DATA03                      = IOMUX_PAD(0x03B0, 0x0124, 0, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA03__PWM4_OUT                          = IOMUX_PAD(0x03B0, 0x0124, 1, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA03__ENET1_1588_EVENT3_OUT             = IOMUX_PAD(0x03B0, 0x0124, 3, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA03__I2C4_SCL                          = IOMUX_PAD(0x03B0, 0x0124, IOMUX_CONFIG_SION | 4, 0x05BC, 2, 0),
+	MX6_PAD_LCD_DATA03__GPIO3_IO08                        = IOMUX_PAD(0x03B0, 0x0124, 5, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA03__SRC_BT_CFG03                      = IOMUX_PAD(0x03B0, 0x0124, 6, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA03__SAI1_RX_DATA                      = IOMUX_PAD(0x03B0, 0x0124, 8, 0x05E4, 0, 0),
+
+	MX6_PAD_LCD_DATA04__LCDIF_DATA04                      = IOMUX_PAD(0x03B4, 0x0128, 0, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA04__UART8_DCE_CTS                     = IOMUX_PAD(0x03B4, 0x0128, 1, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA04__UART8_DTE_RTS                     = IOMUX_PAD(0x03B4, 0x0128, 1, 0x0658, 2, 0),
+	MX6_PAD_LCD_DATA04__ENET2_1588_EVENT2_IN              = IOMUX_PAD(0x03B4, 0x0128, 3, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA04__SPDIF_SR_CLK                      = IOMUX_PAD(0x03B4, 0x0128, 4, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA04__GPIO3_IO09                        = IOMUX_PAD(0x03B4, 0x0128, 5, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA04__SRC_BT_CFG04                      = IOMUX_PAD(0x03B4, 0x0128, 6, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA04__SAI1_TX_DATA                      = IOMUX_PAD(0x03B4, 0x0128, 8, 0x0000, 0, 0),
+
+	MX6_PAD_LCD_DATA05__LCDIF_DATA05                      = IOMUX_PAD(0x03B8, 0x012C, 0, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA05__UART8_DCE_RTS                     = IOMUX_PAD(0x03B8, 0x012C, 1, 0x0658, 3, 0),
+	MX6_PAD_LCD_DATA05__UART8_DTE_CTS                     = IOMUX_PAD(0x03B8, 0x012C, 1, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA05__ENET2_1588_EVENT2_OUT             = IOMUX_PAD(0x03B8, 0x012C, 3, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA05__SPDIF_OUT                         = IOMUX_PAD(0x03B8, 0x012C, 4, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA05__GPIO3_IO10                        = IOMUX_PAD(0x03B8, 0x012C, 5, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA05__SRC_BT_CFG05                      = IOMUX_PAD(0x03B8, 0x012C, 6, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA05__ECSPI1_SS1                        = IOMUX_PAD(0x03B8, 0x012C, 8, 0x0000, 0, 0),
+
+	MX6_PAD_LCD_DATA06__LCDIF_DATA06                      = IOMUX_PAD(0x03BC, 0x0130, 0, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA06__UART7_DCE_CTS                     = IOMUX_PAD(0x03BC, 0x0130, 1, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA06__UART7_DTE_RTS                     = IOMUX_PAD(0x03BC, 0x0130, 1, 0x0650, 2, 0),
+	MX6_PAD_LCD_DATA06__ENET2_1588_EVENT3_IN              = IOMUX_PAD(0x03BC, 0x0130, 3, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA06__SPDIF_LOCK                        = IOMUX_PAD(0x03BC, 0x0130, 4, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA06__GPIO3_IO11                        = IOMUX_PAD(0x03BC, 0x0130, 5, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA06__SRC_BT_CFG06                      = IOMUX_PAD(0x03BC, 0x0130, 6, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA06__ECSPI1_SS2                        = IOMUX_PAD(0x03BC, 0x0130, 8, 0x0000, 0, 0),
+
+	MX6_PAD_LCD_DATA07__LCDIF_DATA07                      = IOMUX_PAD(0x03C0, 0x0134, 0, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA07__UART7_DCE_RTS                     = IOMUX_PAD(0x03C0, 0x0134, 1, 0x0650, 3, 0),
+	MX6_PAD_LCD_DATA07__UART7_DTE_CTS                     = IOMUX_PAD(0x03C0, 0x0134, 1, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA07__ENET2_1588_EVENT3_OUT             = IOMUX_PAD(0x03C0, 0x0134, 3, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA07__SPDIF_EXT_CLK                     = IOMUX_PAD(0x03C0, 0x0134, 4, 0x061C, 0, 0),
+	MX6_PAD_LCD_DATA07__GPIO3_IO12                        = IOMUX_PAD(0x03C0, 0x0134, 5, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA07__SRC_BT_CFG07                      = IOMUX_PAD(0x03C0, 0x0134, 6, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA07__ECSPI1_SS3                        = IOMUX_PAD(0x03C0, 0x0134, 8, 0x0000, 0, 0),
+
+	MX6_PAD_LCD_DATA08__LCDIF_DATA08                      = IOMUX_PAD(0x03C4, 0x0138, 0, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA08__SPDIF_IN                          = IOMUX_PAD(0x03C4, 0x0138, 1, 0x0618, 2, 0),
+	MX6_PAD_LCD_DATA08__CSI_DATA16                        = IOMUX_PAD(0x03C4, 0x0138, 3, 0x0504, 1, 0),
+	MX6_PAD_LCD_DATA08__EIM_DATA00                        = IOMUX_PAD(0x03C4, 0x0138, 4, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA08__GPIO3_IO13                        = IOMUX_PAD(0x03C4, 0x0138, 5, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA08__SRC_BT_CFG08                      = IOMUX_PAD(0x03C4, 0x0138, 6, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA08__FLEXCAN1_TX                       = IOMUX_PAD(0x03C4, 0x0138, 8, 0x0000, 0, 0),
+
+	MX6_PAD_LCD_DATA09__LCDIF_DATA09                      = IOMUX_PAD(0x03C8, 0x013C, 0, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA09__SAI3_MCLK                         = IOMUX_PAD(0x03C8, 0x013C, 1, 0x0600, 1, 0),
+	MX6_PAD_LCD_DATA09__CSI_DATA17                        = IOMUX_PAD(0x03C8, 0x013C, 3, 0x0508, 1, 0),
+	MX6_PAD_LCD_DATA09__EIM_DATA01                        = IOMUX_PAD(0x03C8, 0x013C, 4, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA09__GPIO3_IO14                        = IOMUX_PAD(0x03C8, 0x013C, 5, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA09__SRC_BT_CFG09                      = IOMUX_PAD(0x03C8, 0x013C, 6, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA09__FLEXCAN1_RX                       = IOMUX_PAD(0x03C8, 0x013C, 8, 0x0584, 2, 0),
+
+	MX6_PAD_LCD_DATA10__LCDIF_DATA10                      = IOMUX_PAD(0x03CC, 0x0140, 0, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA10__SAI3_RX_SYNC                      = IOMUX_PAD(0x03CC, 0x0140, 1, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA10__CSI_DATA18                        = IOMUX_PAD(0x03CC, 0x0140, 3, 0x050C, 1, 0),
+	MX6_PAD_LCD_DATA10__EIM_DATA02                        = IOMUX_PAD(0x03CC, 0x0140, 4, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA10__GPIO3_IO15                        = IOMUX_PAD(0x03CC, 0x0140, 5, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA10__SRC_BT_CFG10                      = IOMUX_PAD(0x03CC, 0x0140, 6, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA10__FLEXCAN2_TX                       = IOMUX_PAD(0x03CC, 0x0140, 8, 0x0000, 0, 0),
+
+	MX6_PAD_LCD_DATA11__LCDIF_DATA11                      = IOMUX_PAD(0x03D0, 0x0144, 0, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA11__SAI3_RX_BCLK                      = IOMUX_PAD(0x03D0, 0x0144, 1, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA11__CSI_DATA19                        = IOMUX_PAD(0x03D0, 0x0144, 3, 0x0510, 1, 0),
+	MX6_PAD_LCD_DATA11__EIM_DATA03                        = IOMUX_PAD(0x03D0, 0x0144, 4, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA11__GPIO3_IO16                        = IOMUX_PAD(0x03D0, 0x0144, 5, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA11__SRC_BT_CFG11                      = IOMUX_PAD(0x03D0, 0x0144, 6, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA11__FLEXCAN2_RX                       = IOMUX_PAD(0x03D0, 0x0144, 8, 0x0588, 2, 0),
+
+	MX6_PAD_LCD_DATA12__LCDIF_DATA12                      = IOMUX_PAD(0x03D4, 0x0148, 0, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA12__SAI3_TX_SYNC                      = IOMUX_PAD(0x03D4, 0x0148, 1, 0x060C, 1, 0),
+	MX6_PAD_LCD_DATA12__CSI_DATA20                        = IOMUX_PAD(0x03D4, 0x0148, 3, 0x0514, 1, 0),
+	MX6_PAD_LCD_DATA12__EIM_DATA04                        = IOMUX_PAD(0x03D4, 0x0148, 4, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA12__GPIO3_IO17                        = IOMUX_PAD(0x03D4, 0x0148, 5, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA12__SRC_BT_CFG12                      = IOMUX_PAD(0x03D4, 0x0148, 6, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA12__ECSPI1_RDY                        = IOMUX_PAD(0x03D4, 0x0148, 8, 0x0000, 0, 0),
+
+	MX6_PAD_LCD_DATA13__LCDIF_DATA13                      = IOMUX_PAD(0x03D8, 0x014C, 0, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA13__SAI3_TX_BCLK                      = IOMUX_PAD(0x03D8, 0x014C, 1, 0x0608, 1, 0),
+	MX6_PAD_LCD_DATA13__CSI_DATA21                        = IOMUX_PAD(0x03D8, 0x014C, 3, 0x0518, 1, 0),
+	MX6_PAD_LCD_DATA13__EIM_DATA05                        = IOMUX_PAD(0x03D8, 0x014C, 4, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA13__GPIO3_IO18                        = IOMUX_PAD(0x03D8, 0x014C, 5, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA13__SRC_BT_CFG13                      = IOMUX_PAD(0x03D8, 0x014C, 6, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA13__USDHC2_RESET_B                    = IOMUX_PAD(0x03D8, 0x014C, 8, 0x0000, 0, 0),
+
+	MX6_PAD_LCD_DATA14__LCDIF_DATA14                      = IOMUX_PAD(0x03DC, 0x0150, 0, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA14__SAI3_RX_DATA                      = IOMUX_PAD(0x03DC, 0x0150, 1, 0x0604, 1, 0),
+	MX6_PAD_LCD_DATA14__CSI_DATA22                        = IOMUX_PAD(0x03DC, 0x0150, 3, 0x051C, 1, 0),
+	MX6_PAD_LCD_DATA14__EIM_DATA06                        = IOMUX_PAD(0x03DC, 0x0150, 4, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA14__GPIO3_IO19                        = IOMUX_PAD(0x03DC, 0x0150, 5, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA14__SRC_BT_CFG14                      = IOMUX_PAD(0x03DC, 0x0150, 6, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA14__USDHC2_DATA4                      = IOMUX_PAD(0x03DC, 0x0150, 8, 0x068C, 0, 0),
+
+	MX6_PAD_LCD_DATA15__LCDIF_DATA15                      = IOMUX_PAD(0x03E0, 0x0154, 0, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA15__SAI3_TX_DATA                      = IOMUX_PAD(0x03E0, 0x0154, 1, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA15__CSI_DATA23                        = IOMUX_PAD(0x03E0, 0x0154, 3, 0x0520, 1, 0),
+	MX6_PAD_LCD_DATA15__EIM_DATA07                        = IOMUX_PAD(0x03E0, 0x0154, 4, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA15__GPIO3_IO20                        = IOMUX_PAD(0x03E0, 0x0154, 5, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA15__SRC_BT_CFG15                      = IOMUX_PAD(0x03E0, 0x0154, 6, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA15__USDHC2_DATA5                      = IOMUX_PAD(0x03E0, 0x0154, 8, 0x0690, 0, 0),
+
+	MX6_PAD_LCD_DATA16__LCDIF_DATA16                      = IOMUX_PAD(0x03E4, 0x0158, 0, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA16__UART7_DCE_TX                      = IOMUX_PAD(0x03E4, 0x0158, 1, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA16__UART7_DTE_RX                      = IOMUX_PAD(0x03E4, 0x0158, 1, 0x0654, 2, 0),
+	MX6_PAD_LCD_DATA16__CSI_DATA01                        = IOMUX_PAD(0x03E4, 0x0158, 3, 0x04D4, 1, 0),
+	MX6_PAD_LCD_DATA16__EIM_DATA08                        = IOMUX_PAD(0x03E4, 0x0158, 4, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA16__GPIO3_IO21                        = IOMUX_PAD(0x03E4, 0x0158, 5, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA16__SRC_BT_CFG24                      = IOMUX_PAD(0x03E4, 0x0158, 6, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA16__USDHC2_DATA6                      = IOMUX_PAD(0x03E4, 0x0158, 8, 0x0694, 0, 0),
+
+	MX6_PAD_LCD_DATA17__LCDIF_DATA17                      = IOMUX_PAD(0x03E8, 0x015C, 0, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA17__UART7_DCE_RX                      = IOMUX_PAD(0x03E8, 0x015C, 1, 0x0654, 3, 0),
+	MX6_PAD_LCD_DATA17__UART7_DTE_TX                      = IOMUX_PAD(0x03E8, 0x015C, 1, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA17__CSI_DATA00                        = IOMUX_PAD(0x03E8, 0x015C, 3, 0x04D0, 1, 0),
+	MX6_PAD_LCD_DATA17__EIM_DATA09                        = IOMUX_PAD(0x03E8, 0x015C, 4, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA17__GPIO3_IO22                        = IOMUX_PAD(0x03E8, 0x015C, 5, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA17__SRC_BT_CFG25                      = IOMUX_PAD(0x03E8, 0x015C, 6, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA17__USDHC2_DATA7                      = IOMUX_PAD(0x03E8, 0x015C, 8, 0x0698, 0, 0),
+
+	MX6_PAD_LCD_DATA18__LCDIF_DATA18                      = IOMUX_PAD(0x03EC, 0x0160, 0, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA18__PWM5_OUT                          = IOMUX_PAD(0x03EC, 0x0160, 1, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA18__CA7_MX6ULL_EVENTO                 = IOMUX_PAD(0x03EC, 0x0160, 2, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA18__CSI_DATA10                        = IOMUX_PAD(0x03EC, 0x0160, 3, 0x04EC, 1, 0),
+	MX6_PAD_LCD_DATA18__EIM_DATA10                        = IOMUX_PAD(0x03EC, 0x0160, 4, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA18__GPIO3_IO23                        = IOMUX_PAD(0x03EC, 0x0160, 5, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA18__SRC_BT_CFG26                      = IOMUX_PAD(0x03EC, 0x0160, 6, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA18__USDHC2_CMD                        = IOMUX_PAD(0x03EC, 0x0160, 8, 0x0678, 1, 0),
+	MX6_PAD_LCD_DATA19__EIM_DATA11                        = IOMUX_PAD(0x03F0, 0x0164, 4, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA19__GPIO3_IO24                        = IOMUX_PAD(0x03F0, 0x0164, 5, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA19__SRC_BT_CFG27                      = IOMUX_PAD(0x03F0, 0x0164, 6, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA19__USDHC2_CLK                        = IOMUX_PAD(0x03F0, 0x0164, 8, 0x0670, 1, 0),
+
+	MX6_PAD_LCD_DATA19__LCDIF_DATA19                      = IOMUX_PAD(0x03F0, 0x0164, 0, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA19__PWM6_OUT                          = IOMUX_PAD(0x03F0, 0x0164, 1, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA19__WDOG1_WDOG_ANY                    = IOMUX_PAD(0x03F0, 0x0164, 2, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA19__CSI_DATA11                        = IOMUX_PAD(0x03F0, 0x0164, 3, 0x04F0, 1, 0),
+	MX6_PAD_LCD_DATA20__EIM_DATA12                        = IOMUX_PAD(0x03F4, 0x0168, 4, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA20__GPIO3_IO25                        = IOMUX_PAD(0x03F4, 0x0168, 5, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA20__SRC_BT_CFG28                      = IOMUX_PAD(0x03F4, 0x0168, 6, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA20__USDHC2_DATA0                      = IOMUX_PAD(0x03F4, 0x0168, 8, 0x067C, 1, 0),
+
+	MX6_PAD_LCD_DATA20__LCDIF_DATA20                      = IOMUX_PAD(0x03F4, 0x0168, 0, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA20__UART8_DCE_TX                      = IOMUX_PAD(0x03F4, 0x0168, 1, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA20__UART8_DTE_RX                      = IOMUX_PAD(0x03F4, 0x0168, 1, 0x065C, 2, 0),
+	MX6_PAD_LCD_DATA20__ECSPI1_SCLK                       = IOMUX_PAD(0x03F4, 0x0168, 2, 0x0534, 0, 0),
+	MX6_PAD_LCD_DATA20__CSI_DATA12                        = IOMUX_PAD(0x03F4, 0x0168, 3, 0x04F4, 1, 0),
+
+	MX6_PAD_LCD_DATA21__LCDIF_DATA21                      = IOMUX_PAD(0x03F8, 0x016C, 0, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA21__UART8_DCE_RX                      = IOMUX_PAD(0x03F8, 0x016C, 1, 0x065C, 3, 0),
+	MX6_PAD_LCD_DATA21__UART8_DTE_TX                      = IOMUX_PAD(0x03F8, 0x016C, 1, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA21__ECSPI1_SS0                        = IOMUX_PAD(0x03F8, 0x016C, 2, 0x0540, 0, 0),
+	MX6_PAD_LCD_DATA21__CSI_DATA13                        = IOMUX_PAD(0x03F8, 0x016C, 3, 0x04F8, 1, 0),
+	MX6_PAD_LCD_DATA21__EIM_DATA13                        = IOMUX_PAD(0x03F8, 0x016C, 4, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA21__GPIO3_IO26                        = IOMUX_PAD(0x03F8, 0x016C, 5, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA21__SRC_BT_CFG29                      = IOMUX_PAD(0x03F8, 0x016C, 6, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA21__USDHC2_DATA1                      = IOMUX_PAD(0x03F8, 0x016C, 8, 0x0680, 1, 0),
+
+	MX6_PAD_LCD_DATA22__LCDIF_DATA22                      = IOMUX_PAD(0x03FC, 0x0170, 0, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA22__MQS_RIGHT                         = IOMUX_PAD(0x03FC, 0x0170, 1, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA22__ECSPI1_MOSI                       = IOMUX_PAD(0x03FC, 0x0170, 2, 0x053C, 0, 0),
+	MX6_PAD_LCD_DATA22__CSI_DATA14                        = IOMUX_PAD(0x03FC, 0x0170, 3, 0x04FC, 1, 0),
+	MX6_PAD_LCD_DATA22__EIM_DATA14                        = IOMUX_PAD(0x03FC, 0x0170, 4, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA22__GPIO3_IO27                        = IOMUX_PAD(0x03FC, 0x0170, 5, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA22__SRC_BT_CFG30                      = IOMUX_PAD(0x03FC, 0x0170, 6, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA22__USDHC2_DATA2                      = IOMUX_PAD(0x03FC, 0x0170, 8, 0x0684, 0, 0),
+
+	MX6_PAD_LCD_DATA23__LCDIF_DATA23                      = IOMUX_PAD(0x0400, 0x0174, 0, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA23__MQS_LEFT                          = IOMUX_PAD(0x0400, 0x0174, 1, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA23__ECSPI1_MISO                       = IOMUX_PAD(0x0400, 0x0174, 2, 0x0538, 0, 0),
+	MX6_PAD_LCD_DATA23__CSI_DATA15                        = IOMUX_PAD(0x0400, 0x0174, 3, 0x0500, 1, 0),
+	MX6_PAD_LCD_DATA23__EIM_DATA15                        = IOMUX_PAD(0x0400, 0x0174, 4, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA23__GPIO3_IO28                        = IOMUX_PAD(0x0400, 0x0174, 5, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA23__SRC_BT_CFG31                      = IOMUX_PAD(0x0400, 0x0174, 6, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA23__USDHC2_DATA3                      = IOMUX_PAD(0x0400, 0x0174, 8, 0x0688, 1, 0),
+
+	MX6_PAD_NAND_RE_B__RAWNAND_RE_B                       = IOMUX_PAD(0x0404, 0x0178, 0, 0x0000, 0, 0),
+	MX6_PAD_NAND_RE_B__USDHC2_CLK                         = IOMUX_PAD(0x0404, 0x0178, 1, 0x0670, 2, 0),
+	MX6_PAD_NAND_RE_B__QSPI_B_SCLK                        = IOMUX_PAD(0x0404, 0x0178, 2, 0x0000, 0, 0),
+	MX6_PAD_NAND_RE_B__KPP_ROW00                          = IOMUX_PAD(0x0404, 0x0178, 3, 0x05D0, 1, 0),
+	MX6_PAD_NAND_RE_B__EIM_EB_B00                         = IOMUX_PAD(0x0404, 0x0178, 4, 0x0000, 0, 0),
+	MX6_PAD_NAND_RE_B__GPIO4_IO00                         = IOMUX_PAD(0x0404, 0x0178, 5, 0x0000, 0, 0),
+	MX6_PAD_NAND_RE_B__ECSPI3_SS2                         = IOMUX_PAD(0x0404, 0x0178, 8, 0x0000, 0, 0),
+
+	MX6_PAD_NAND_WE_B__RAWNAND_WE_B                       = IOMUX_PAD(0x0408, 0x017C, 0, 0x0000, 0, 0),
+	MX6_PAD_NAND_WE_B__USDHC2_CMD                         = IOMUX_PAD(0x0408, 0x017C, 1, 0x0678, 2, 0),
+	MX6_PAD_NAND_WE_B__QSPI_B_SS0_B                       = IOMUX_PAD(0x0408, 0x017C, 2, 0x0000, 0, 0),
+	MX6_PAD_NAND_WE_B__KPP_COL00                          = IOMUX_PAD(0x0408, 0x017C, 3, 0x05C4, 1, 0),
+	MX6_PAD_NAND_WE_B__EIM_EB_B01                         = IOMUX_PAD(0x0408, 0x017C, 4, 0x0000, 0, 0),
+	MX6_PAD_NAND_WE_B__GPIO4_IO01                         = IOMUX_PAD(0x0408, 0x017C, 5, 0x0000, 0, 0),
+	MX6_PAD_NAND_WE_B__ECSPI3_SS3                         = IOMUX_PAD(0x0408, 0x017C, 8, 0x0000, 0, 0),
+
+	MX6_PAD_NAND_DATA00__RAWNAND_DATA00                   = IOMUX_PAD(0x040C, 0x0180, 0, 0x0000, 0, 0),
+	MX6_PAD_NAND_DATA00__USDHC2_DATA0                     = IOMUX_PAD(0x040C, 0x0180, 1, 0x067C, 2, 0),
+	MX6_PAD_NAND_DATA00__QSPI_B_SS1_B                     = IOMUX_PAD(0x040C, 0x0180, 2, 0x0000, 0, 0),
+	MX6_PAD_NAND_DATA00__KPP_ROW01                        = IOMUX_PAD(0x040C, 0x0180, 3, 0x05D4, 1, 0),
+	MX6_PAD_NAND_DATA00__EIM_AD08                         = IOMUX_PAD(0x040C, 0x0180, 4, 0x0000, 0, 0),
+	MX6_PAD_NAND_DATA00__GPIO4_IO02                       = IOMUX_PAD(0x040C, 0x0180, 5, 0x0000, 0, 0),
+	MX6_PAD_NAND_DATA00__ECSPI4_RDY                       = IOMUX_PAD(0x040C, 0x0180, 8, 0x0000, 0, 0),
+
+	MX6_PAD_NAND_DATA01__RAWNAND_DATA01                   = IOMUX_PAD(0x0410, 0x0184, 0, 0x0000, 0, 0),
+	MX6_PAD_NAND_DATA01__USDHC2_DATA1                     = IOMUX_PAD(0x0410, 0x0184, 1, 0x0680, 2, 0),
+	MX6_PAD_NAND_DATA01__QSPI_B_DQS                       = IOMUX_PAD(0x0410, 0x0184, 2, 0x0000, 0, 0),
+	MX6_PAD_NAND_DATA01__KPP_COL01                        = IOMUX_PAD(0x0410, 0x0184, 3, 0x05C8, 1, 0),
+	MX6_PAD_NAND_DATA01__EIM_AD09                         = IOMUX_PAD(0x0410, 0x0184, 4, 0x0000, 0, 0),
+	MX6_PAD_NAND_DATA01__GPIO4_IO03                       = IOMUX_PAD(0x0410, 0x0184, 5, 0x0000, 0, 0),
+	MX6_PAD_NAND_DATA01__ECSPI4_SS1                       = IOMUX_PAD(0x0410, 0x0184, 8, 0x0000, 0, 0),
+
+	MX6_PAD_NAND_DATA02__RAWNAND_DATA02                   = IOMUX_PAD(0x0414, 0x0188, 0, 0x0000, 0, 0),
+	MX6_PAD_NAND_DATA02__USDHC2_DATA2                     = IOMUX_PAD(0x0414, 0x0188, 1, 0x0684, 1, 0),
+	MX6_PAD_NAND_DATA02__QSPI_B_DATA00                    = IOMUX_PAD(0x0414, 0x0188, 2, 0x0000, 0, 0),
+	MX6_PAD_NAND_DATA02__KPP_ROW02                        = IOMUX_PAD(0x0414, 0x0188, 3, 0x05D8, 1, 0),
+	MX6_PAD_NAND_DATA02__EIM_AD10                         = IOMUX_PAD(0x0414, 0x0188, 4, 0x0000, 0, 0),
+	MX6_PAD_NAND_DATA02__GPIO4_IO04                       = IOMUX_PAD(0x0414, 0x0188, 5, 0x0000, 0, 0),
+	MX6_PAD_NAND_DATA02__ECSPI4_SS2                       = IOMUX_PAD(0x0414, 0x0188, 8, 0x0000, 0, 0),
+
+	MX6_PAD_NAND_DATA03__RAWNAND_DATA03                   = IOMUX_PAD(0x0418, 0x018C, 0, 0x0000, 0, 0),
+	MX6_PAD_NAND_DATA03__USDHC2_DATA3                     = IOMUX_PAD(0x0418, 0x018C, 1, 0x0688, 2, 0),
+	MX6_PAD_NAND_DATA03__QSPI_B_DATA01                    = IOMUX_PAD(0x0418, 0x018C, 2, 0x0000, 0, 0),
+	MX6_PAD_NAND_DATA03__KPP_COL02                        = IOMUX_PAD(0x0418, 0x018C, 3, 0x05CC, 1, 0),
+	MX6_PAD_NAND_DATA03__EIM_AD11                         = IOMUX_PAD(0x0418, 0x018C, 4, 0x0000, 0, 0),
+	MX6_PAD_NAND_DATA03__GPIO4_IO05                       = IOMUX_PAD(0x0418, 0x018C, 5, 0x0000, 0, 0),
+	MX6_PAD_NAND_DATA03__ECSPI4_SS3                       = IOMUX_PAD(0x0418, 0x018C, 8, 0x0000, 0, 0),
+
+	MX6_PAD_NAND_DATA04__RAWNAND_DATA04                   = IOMUX_PAD(0x041C, 0x0190, 0, 0x0000, 0, 0),
+	MX6_PAD_NAND_DATA04__USDHC2_DATA4                     = IOMUX_PAD(0x041C, 0x0190, 1, 0x068C, 1, 0),
+	MX6_PAD_NAND_DATA04__QSPI_B_DATA02                    = IOMUX_PAD(0x041C, 0x0190, 2, 0x0000, 0, 0),
+	MX6_PAD_NAND_DATA04__ECSPI4_SCLK                      = IOMUX_PAD(0x041C, 0x0190, 3, 0x0564, 1, 0),
+	MX6_PAD_NAND_DATA04__EIM_AD12                         = IOMUX_PAD(0x041C, 0x0190, 4, 0x0000, 0, 0),
+	MX6_PAD_NAND_DATA04__GPIO4_IO06                       = IOMUX_PAD(0x041C, 0x0190, 5, 0x0000, 0, 0),
+	MX6_PAD_NAND_DATA04__UART2_DCE_TX                     = IOMUX_PAD(0x041C, 0x0190, 8, 0x0000, 0, 0),
+	MX6_PAD_NAND_DATA04__UART2_DTE_RX                     = IOMUX_PAD(0x041C, 0x0190, 8, 0x062C, 2, 0),
+
+	MX6_PAD_NAND_DATA05__RAWNAND_DATA05                   = IOMUX_PAD(0x0420, 0x0194, 0, 0x0000, 0, 0),
+	MX6_PAD_NAND_DATA05__USDHC2_DATA5                     = IOMUX_PAD(0x0420, 0x0194, 1, 0x0690, 1, 0),
+	MX6_PAD_NAND_DATA05__QSPI_B_DATA03                    = IOMUX_PAD(0x0420, 0x0194, 2, 0x0000, 0, 0),
+	MX6_PAD_NAND_DATA05__ECSPI4_MOSI                      = IOMUX_PAD(0x0420, 0x0194, 3, 0x056C, 1, 0),
+	MX6_PAD_NAND_DATA05__EIM_AD13                         = IOMUX_PAD(0x0420, 0x0194, 4, 0x0000, 0, 0),
+	MX6_PAD_NAND_DATA05__GPIO4_IO07                       = IOMUX_PAD(0x0420, 0x0194, 5, 0x0000, 0, 0),
+	MX6_PAD_NAND_DATA05__UART2_DCE_RX                     = IOMUX_PAD(0x0420, 0x0194, 8, 0x062C, 3, 0),
+	MX6_PAD_NAND_DATA05__UART2_DTE_TX                     = IOMUX_PAD(0x0420, 0x0194, 8, 0x0000, 0, 0),
+
+	MX6_PAD_NAND_DATA06__RAWNAND_DATA06                   = IOMUX_PAD(0x0424, 0x0198, 0, 0x0000, 0, 0),
+	MX6_PAD_NAND_DATA06__USDHC2_DATA6                     = IOMUX_PAD(0x0424, 0x0198, 1, 0x0694, 1, 0),
+	MX6_PAD_NAND_DATA06__SAI2_RX_BCLK                     = IOMUX_PAD(0x0424, 0x0198, 2, 0x0000, 0, 0),
+	MX6_PAD_NAND_DATA06__ECSPI4_MISO                      = IOMUX_PAD(0x0424, 0x0198, 3, 0x0568, 1, 0),
+	MX6_PAD_NAND_DATA06__EIM_AD14                         = IOMUX_PAD(0x0424, 0x0198, 4, 0x0000, 0, 0),
+	MX6_PAD_NAND_DATA06__GPIO4_IO08                       = IOMUX_PAD(0x0424, 0x0198, 5, 0x0000, 0, 0),
+	MX6_PAD_NAND_DATA06__UART2_DCE_CTS                    = IOMUX_PAD(0x0424, 0x0198, 8, 0x0000, 0, 0),
+	MX6_PAD_NAND_DATA06__UART2_DTE_RTS                    = IOMUX_PAD(0x0424, 0x0198, 8, 0x0628, 4, 0),
+
+	MX6_PAD_NAND_DATA07__RAWNAND_DATA07                   = IOMUX_PAD(0x0428, 0x019C, 0, 0x0000, 0, 0),
+	MX6_PAD_NAND_DATA07__USDHC2_DATA7                     = IOMUX_PAD(0x0428, 0x019C, 1, 0x0698, 1, 0),
+	MX6_PAD_NAND_DATA07__QSPI_A_SS1_B                     = IOMUX_PAD(0x0428, 0x019C, 2, 0x0000, 0, 0),
+	MX6_PAD_NAND_DATA07__ECSPI4_SS0                       = IOMUX_PAD(0x0428, 0x019C, 3, 0x0570, 1, 0),
+	MX6_PAD_NAND_DATA07__EIM_AD15                         = IOMUX_PAD(0x0428, 0x019C, 4, 0x0000, 0, 0),
+	MX6_PAD_NAND_DATA07__GPIO4_IO09                       = IOMUX_PAD(0x0428, 0x019C, 5, 0x0000, 0, 0),
+	MX6_PAD_NAND_DATA07__UART2_DCE_RTS                    = IOMUX_PAD(0x0428, 0x019C, 8, 0x0628, 5, 0),
+	MX6_PAD_NAND_DATA07__UART2_DTE_CTS                    = IOMUX_PAD(0x0428, 0x019C, 8, 0x0000, 0, 0),
+
+	MX6_PAD_NAND_ALE__RAWNAND_ALE                         = IOMUX_PAD(0x042C, 0x01A0, 0, 0x0000, 0, 0),
+	MX6_PAD_NAND_ALE__USDHC2_RESET_B                      = IOMUX_PAD(0x042C, 0x01A0, 1, 0x0000, 0, 0),
+	MX6_PAD_NAND_ALE__QSPI_A_DQS                          = IOMUX_PAD(0x042C, 0x01A0, 2, 0x0000, 0, 0),
+	MX6_PAD_NAND_ALE__PWM3_OUT                            = IOMUX_PAD(0x042C, 0x01A0, 3, 0x0000, 0, 0),
+	MX6_PAD_NAND_ALE__EIM_ADDR17                          = IOMUX_PAD(0x042C, 0x01A0, 4, 0x0000, 0, 0),
+	MX6_PAD_NAND_ALE__GPIO4_IO10                          = IOMUX_PAD(0x042C, 0x01A0, 5, 0x0000, 0, 0),
+	MX6_PAD_NAND_ALE__ECSPI3_SS1                          = IOMUX_PAD(0x042C, 0x01A0, 8, 0x0000, 0, 0),
+
+	MX6_PAD_NAND_WP_B__RAWNAND_WP_B                       = IOMUX_PAD(0x0430, 0x01A4, 0, 0x0000, 0, 0),
+	MX6_PAD_NAND_WP_B__USDHC1_RESET_B                     = IOMUX_PAD(0x0430, 0x01A4, 1, 0x0000, 0, 0),
+	MX6_PAD_NAND_WP_B__QSPI_A_SCLK                        = IOMUX_PAD(0x0430, 0x01A4, 2, 0x0000, 0, 0),
+	MX6_PAD_NAND_WP_B__PWM4_OUT                           = IOMUX_PAD(0x0430, 0x01A4, 3, 0x0000, 0, 0),
+	MX6_PAD_NAND_WP_B__EIM_BCLK                           = IOMUX_PAD(0x0430, 0x01A4, 4, 0x0000, 0, 0),
+	MX6_PAD_NAND_WP_B__GPIO4_IO11                         = IOMUX_PAD(0x0430, 0x01A4, 5, 0x0000, 0, 0),
+	MX6_PAD_NAND_WP_B__ECSPI3_RDY                         = IOMUX_PAD(0x0430, 0x01A4, 8, 0x0000, 0, 0),
+
+	MX6_PAD_NAND_READY_B__RAWNAND_READY_B                 = IOMUX_PAD(0x0434, 0x01A8, 0, 0x0000, 0, 0),
+	MX6_PAD_NAND_READY_B__USDHC1_DATA4                    = IOMUX_PAD(0x0434, 0x01A8, 1, 0x0000, 0, 0),
+	MX6_PAD_NAND_READY_B__QSPI_A_DATA00                   = IOMUX_PAD(0x0434, 0x01A8, 2, 0x0000, 0, 0),
+	MX6_PAD_NAND_READY_B__ECSPI3_SS0                      = IOMUX_PAD(0x0434, 0x01A8, 3, 0x0560, 1, 0),
+	MX6_PAD_NAND_READY_B__EIM_CS1_B                       = IOMUX_PAD(0x0434, 0x01A8, 4, 0x0000, 0, 0),
+	MX6_PAD_NAND_READY_B__GPIO4_IO12                      = IOMUX_PAD(0x0434, 0x01A8, 5, 0x0000, 0, 0),
+	MX6_PAD_NAND_READY_B__UART3_DCE_TX                    = IOMUX_PAD(0x0434, 0x01A8, 8, 0x0000, 0, 0),
+	MX6_PAD_NAND_READY_B__UART3_DTE_RX                    = IOMUX_PAD(0x0434, 0x01A8, 8, 0x0634, 2, 0),
+
+	MX6_PAD_NAND_CE0_B__RAWNAND_CE0_B                     = IOMUX_PAD(0x0438, 0x01AC, 0, 0x0000, 0, 0),
+	MX6_PAD_NAND_CE0_B__USDHC1_DATA5                      = IOMUX_PAD(0x0438, 0x01AC, 1, 0x0000, 0, 0),
+	MX6_PAD_NAND_CE0_B__QSPI_A_DATA01                     = IOMUX_PAD(0x0438, 0x01AC, 2, 0x0000, 0, 0),
+	MX6_PAD_NAND_CE0_B__ECSPI3_SCLK                       = IOMUX_PAD(0x0438, 0x01AC, 3, 0x0554, 1, 0),
+	MX6_PAD_NAND_CE0_B__EIM_DTACK_B                       = IOMUX_PAD(0x0438, 0x01AC, 4, 0x0000, 0, 0),
+	MX6_PAD_NAND_CE0_B__GPIO4_IO13                        = IOMUX_PAD(0x0438, 0x01AC, 5, 0x0000, 0, 0),
+	MX6_PAD_NAND_CE0_B__UART3_DCE_RX                      = IOMUX_PAD(0x0438, 0x01AC, 8, 0x0634, 3, 0),
+	MX6_PAD_NAND_CE0_B__UART3_DTE_TX                      = IOMUX_PAD(0x0438, 0x01AC, 8, 0x0000, 0, 0),
+
+	MX6_PAD_NAND_CE1_B__RAWNAND_CE1_B                     = IOMUX_PAD(0x043C, 0x01B0, 0, 0x0000, 0, 0),
+	MX6_PAD_NAND_CE1_B__USDHC1_DATA6                      = IOMUX_PAD(0x043C, 0x01B0, 1, 0x0000, 0, 0),
+	MX6_PAD_NAND_CE1_B__QSPI_A_DATA02                     = IOMUX_PAD(0x043C, 0x01B0, 2, 0x0000, 0, 0),
+	MX6_PAD_NAND_CE1_B__ECSPI3_MOSI                       = IOMUX_PAD(0x043C, 0x01B0, 3, 0x055C, 1, 0),
+	MX6_PAD_NAND_CE1_B__EIM_ADDR18                        = IOMUX_PAD(0x043C, 0x01B0, 4, 0x0000, 0, 0),
+	MX6_PAD_NAND_CE1_B__GPIO4_IO14                        = IOMUX_PAD(0x043C, 0x01B0, 5, 0x0000, 0, 0),
+	MX6_PAD_NAND_CE1_B__UART3_DCE_CTS                     = IOMUX_PAD(0x043C, 0x01B0, 8, 0x0000, 0, 0),
+	MX6_PAD_NAND_CE1_B__UART3_DTE_RTS                     = IOMUX_PAD(0x043C, 0x01B0, 8, 0x0630, 2, 0),
+
+	MX6_PAD_NAND_CLE__RAWNAND_CLE                         = IOMUX_PAD(0x0440, 0x01B4, 0, 0x0000, 0, 0),
+	MX6_PAD_NAND_CLE__USDHC1_DATA7                        = IOMUX_PAD(0x0440, 0x01B4, 1, 0x0000, 0, 0),
+	MX6_PAD_NAND_CLE__QSPI_A_DATA03                       = IOMUX_PAD(0x0440, 0x01B4, 2, 0x0000, 0, 0),
+	MX6_PAD_NAND_CLE__ECSPI3_MISO                         = IOMUX_PAD(0x0440, 0x01B4, 3, 0x0558, 1, 0),
+	MX6_PAD_NAND_CLE__EIM_ADDR16                          = IOMUX_PAD(0x0440, 0x01B4, 4, 0x0000, 0, 0),
+	MX6_PAD_NAND_CLE__GPIO4_IO15                          = IOMUX_PAD(0x0440, 0x01B4, 5, 0x0000, 0, 0),
+	MX6_PAD_NAND_CLE__UART3_DCE_RTS                       = IOMUX_PAD(0x0440, 0x01B4, 8, 0x0630, 3, 0),
+	MX6_PAD_NAND_CLE__UART3_DTE_CTS                       = IOMUX_PAD(0x0440, 0x01B4, 8, 0x0000, 0, 0),
+
+	MX6_PAD_NAND_DQS__RAWNAND_DQS                         = IOMUX_PAD(0x0444, 0x01B8, 0, 0x0000, 0, 0),
+	MX6_PAD_NAND_DQS__CSI_FIELD                           = IOMUX_PAD(0x0444, 0x01B8, 1, 0x0530, 1, 0),
+	MX6_PAD_NAND_DQS__QSPI_A_SS0_B                        = IOMUX_PAD(0x0444, 0x01B8, 2, 0x0000, 0, 0),
+	MX6_PAD_NAND_DQS__PWM5_OUT                            = IOMUX_PAD(0x0444, 0x01B8, 3, 0x0000, 0, 0),
+	MX6_PAD_NAND_DQS__EIM_WAIT                            = IOMUX_PAD(0x0444, 0x01B8, 4, 0x0000, 0, 0),
+	MX6_PAD_NAND_DQS__GPIO4_IO16                          = IOMUX_PAD(0x0444, 0x01B8, 5, 0x0000, 0, 0),
+	MX6_PAD_NAND_DQS__SDMA_EXT_EVENT01                    = IOMUX_PAD(0x0444, 0x01B8, 6, 0x0614, 1, 0),
+	MX6_PAD_NAND_DQS__SPDIF_EXT_CLK                       = IOMUX_PAD(0x0444, 0x01B8, 8, 0x061C, 1, 0),
+
+	MX6_PAD_SD1_CMD__USDHC1_CMD                           = IOMUX_PAD(0x0448, 0x01BC, 0, 0x0000, 0, 0),
+	MX6_PAD_SD1_CMD__GPT2_COMPARE1                        = IOMUX_PAD(0x0448, 0x01BC, 1, 0x0000, 0, 0),
+	MX6_PAD_SD1_CMD__SAI2_RX_SYNC                         = IOMUX_PAD(0x0448, 0x01BC, 2, 0x0000, 0, 0),
+	MX6_PAD_SD1_CMD__SPDIF_OUT                            = IOMUX_PAD(0x0448, 0x01BC, 3, 0x0000, 0, 0),
+	MX6_PAD_SD1_CMD__EIM_ADDR19                           = IOMUX_PAD(0x0448, 0x01BC, 4, 0x0000, 0, 0),
+	MX6_PAD_SD1_CMD__GPIO2_IO16                           = IOMUX_PAD(0x0448, 0x01BC, 5, 0x0000, 0, 0),
+	MX6_PAD_SD1_CMD__SDMA_EXT_EVENT00                     = IOMUX_PAD(0x0448, 0x01BC, 6, 0x0610, 2, 0),
+	MX6_PAD_SD1_CMD__USB_OTG1_PWR                         = IOMUX_PAD(0x0448, 0x01BC, 8, 0x0000, 0, 0),
+
+	MX6_PAD_SD1_CLK__USDHC1_CLK                           = IOMUX_PAD(0x044C, 0x01C0, 0, 0x0000, 0, 0),
+	MX6_PAD_SD1_CLK__GPT2_COMPARE2                        = IOMUX_PAD(0x044C, 0x01C0, 1, 0x0000, 0, 0),
+	MX6_PAD_SD1_CLK__SAI2_MCLK                            = IOMUX_PAD(0x044C, 0x01C0, 2, 0x05F0, 1, 0),
+	MX6_PAD_SD1_CLK__SPDIF_IN                             = IOMUX_PAD(0x044C, 0x01C0, 3, 0x0618, 3, 0),
+	MX6_PAD_SD1_CLK__EIM_ADDR20                           = IOMUX_PAD(0x044C, 0x01C0, 4, 0x0000, 0, 0),
+	MX6_PAD_SD1_CLK__GPIO2_IO17                           = IOMUX_PAD(0x044C, 0x01C0, 5, 0x0000, 0, 0),
+	MX6_PAD_SD1_CLK__USB_OTG1_OC                          = IOMUX_PAD(0x044C, 0x01C0, 8, 0x0664, 2, 0),
+
+	MX6_PAD_SD1_DATA0__USDHC1_DATA0                       = IOMUX_PAD(0x0450, 0x01C4, 0, 0x0000, 0, 0),
+	MX6_PAD_SD1_DATA0__GPT2_COMPARE3                      = IOMUX_PAD(0x0450, 0x01C4, 1, 0x0000, 0, 0),
+	MX6_PAD_SD1_DATA0__SAI2_TX_SYNC                       = IOMUX_PAD(0x0450, 0x01C4, 2, 0x05FC, 1, 0),
+	MX6_PAD_SD1_DATA0__FLEXCAN1_TX                        = IOMUX_PAD(0x0450, 0x01C4, 3, 0x0000, 0, 0),
+	MX6_PAD_SD1_DATA0__EIM_ADDR21                         = IOMUX_PAD(0x0450, 0x01C4, 4, 0x0000, 0, 0),
+	MX6_PAD_SD1_DATA0__GPIO2_IO18                         = IOMUX_PAD(0x0450, 0x01C4, 5, 0x0000, 0, 0),
+	MX6_PAD_SD1_DATA0__ANATOP_OTG1_ID                     = IOMUX_PAD(0x0450, 0x01C4, 8, 0x04B8, 2, 0),
+
+	MX6_PAD_SD1_DATA1__USDHC1_DATA1                       = IOMUX_PAD(0x0454, 0x01C8, 0, 0x0000, 0, 0),
+	MX6_PAD_SD1_DATA1__GPT2_CLK                           = IOMUX_PAD(0x0454, 0x01C8, 1, 0x05A0, 1, 0),
+	MX6_PAD_SD1_DATA1__SAI2_TX_BCLK                       = IOMUX_PAD(0x0454, 0x01C8, 2, 0x05F8, 1, 0),
+	MX6_PAD_SD1_DATA1__FLEXCAN1_RX                        = IOMUX_PAD(0x0454, 0x01C8, 3, 0x0584, 3, 0),
+	MX6_PAD_SD1_DATA1__EIM_ADDR22                         = IOMUX_PAD(0x0454, 0x01C8, 4, 0x0000, 0, 0),
+	MX6_PAD_SD1_DATA1__GPIO2_IO19                         = IOMUX_PAD(0x0454, 0x01C8, 5, 0x0000, 0, 0),
+	MX6_PAD_SD1_DATA1__USB_OTG2_PWR                       = IOMUX_PAD(0x0454, 0x01C8, 8, 0x0000, 0, 0),
+
+	MX6_PAD_SD1_DATA2__USDHC1_DATA2                       = IOMUX_PAD(0x0458, 0x01CC, 0, 0x0000, 0, 0),
+	MX6_PAD_SD1_DATA2__GPT2_CAPTURE1                      = IOMUX_PAD(0x0458, 0x01CC, 1, 0x0598, 1, 0),
+	MX6_PAD_SD1_DATA2__SAI2_RX_DATA                       = IOMUX_PAD(0x0458, 0x01CC, 2, 0x05F4, 1, 0),
+	MX6_PAD_SD1_DATA2__FLEXCAN2_TX                        = IOMUX_PAD(0x0458, 0x01CC, 3, 0x0000, 0, 0),
+	MX6_PAD_SD1_DATA2__EIM_ADDR23                         = IOMUX_PAD(0x0458, 0x01CC, 4, 0x0000, 0, 0),
+	MX6_PAD_SD1_DATA2__GPIO2_IO20                         = IOMUX_PAD(0x0458, 0x01CC, 5, 0x0000, 0, 0),
+	MX6_PAD_SD1_DATA2__CCM_CLKO1                          = IOMUX_PAD(0x0458, 0x01CC, 6, 0x0000, 0, 0),
+	MX6_PAD_SD1_DATA2__USB_OTG2_OC                        = IOMUX_PAD(0x0458, 0x01CC, 8, 0x0660, 2, 0),
+
+	MX6_PAD_SD1_DATA3__USDHC1_DATA3                       = IOMUX_PAD(0x045C, 0x01D0, 0, 0x0000, 0, 0),
+	MX6_PAD_SD1_DATA3__GPT2_CAPTURE2                      = IOMUX_PAD(0x045C, 0x01D0, 1, 0x059C, 1, 0),
+	MX6_PAD_SD1_DATA3__SAI2_TX_DATA                       = IOMUX_PAD(0x045C, 0x01D0, 2, 0x0000, 0, 0),
+	MX6_PAD_SD1_DATA3__FLEXCAN2_RX                        = IOMUX_PAD(0x045C, 0x01D0, 3, 0x0588, 3, 0),
+	MX6_PAD_SD1_DATA3__EIM_ADDR24                         = IOMUX_PAD(0x045C, 0x01D0, 4, 0x0000, 0, 0),
+	MX6_PAD_SD1_DATA3__GPIO2_IO21                         = IOMUX_PAD(0x045C, 0x01D0, 5, 0x0000, 0, 0),
+	MX6_PAD_SD1_DATA3__CCM_CLKO2                          = IOMUX_PAD(0x045C, 0x01D0, 6, 0x0000, 0, 0),
+	MX6_PAD_SD1_DATA3__ANATOP_OTG2_ID                     = IOMUX_PAD(0x045C, 0x01D0, 8, 0x04BC, 2, 0),
+
+	MX6_PAD_CSI_MCLK__CSI_MCLK                            = IOMUX_PAD(0x0460, 0x01D4, 0, 0x0000, 0, 0),
+	MX6_PAD_CSI_MCLK__USDHC2_CD_B                         = IOMUX_PAD(0x0460, 0x01D4, 1, 0x0674, 0, 0),
+	MX6_PAD_CSI_MCLK__RAWNAND_CE2_B                       = IOMUX_PAD(0x0460, 0x01D4, 2, 0x0000, 0, 0),
+	MX6_PAD_CSI_MCLK__I2C1_SDA                            = IOMUX_PAD(0x0460, 0x01D4, IOMUX_CONFIG_SION | 3, 0x05A8, 0, 0),
+	MX6_PAD_CSI_MCLK__EIM_CS0_B                           = IOMUX_PAD(0x0460, 0x01D4, 4, 0x0000, 0, 0),
+	MX6_PAD_CSI_MCLK__GPIO4_IO17                          = IOMUX_PAD(0x0460, 0x01D4, 5, 0x0000, 0, 0),
+	MX6_PAD_CSI_MCLK__SNVS_HP_VIO_5_CTL                   = IOMUX_PAD(0x0460, 0x01D4, 6, 0x0000, 0, 0),
+	MX6_PAD_CSI_MCLK__UART6_DCE_TX                        = IOMUX_PAD(0x0460, 0x01D4, 8, 0x0000, 0, 0),
+	MX6_PAD_CSI_MCLK__UART6_DTE_RX                        = IOMUX_PAD(0x0460, 0x01D4, 8, 0x064C, 0, 0),
+
+	MX6_PAD_CSI_PIXCLK__CSI_PIXCLK                        = IOMUX_PAD(0x0464, 0x01D8, 0, 0x0528, 1, 0),
+	MX6_PAD_CSI_PIXCLK__USDHC2_WP                         = IOMUX_PAD(0x0464, 0x01D8, 1, 0x069C, 2, 0),
+	MX6_PAD_CSI_PIXCLK__RAWNAND_CE3_B                     = IOMUX_PAD(0x0464, 0x01D8, 2, 0x0000, 0, 0),
+	MX6_PAD_CSI_PIXCLK__I2C1_SCL                          = IOMUX_PAD(0x0464, 0x01D8, IOMUX_CONFIG_SION | 3, 0x05A4, 2, 0),
+	MX6_PAD_CSI_PIXCLK__EIM_OE                            = IOMUX_PAD(0x0464, 0x01D8, 4, 0x0000, 0, 0),
+	MX6_PAD_CSI_PIXCLK__GPIO4_IO18                        = IOMUX_PAD(0x0464, 0x01D8, 5, 0x0000, 0, 0),
+	MX6_PAD_CSI_PIXCLK__SNVS_HP_VIO_5                     = IOMUX_PAD(0x0464, 0x01D8, 6, 0x0000, 0, 0),
+	MX6_PAD_CSI_PIXCLK__UART6_DCE_RX                      = IOMUX_PAD(0x0464, 0x01D8, 8, 0x064C, 3, 0),
+	MX6_PAD_CSI_PIXCLK__UART6_DTE_TX                      = IOMUX_PAD(0x0464, 0x01D8, 8, 0x0000, 0, 0),
+
+	MX6_PAD_CSI_VSYNC__CSI_VSYNC                          = IOMUX_PAD(0x0468, 0x01DC, 0, 0x052C, 0, 0),
+	MX6_PAD_CSI_VSYNC__USDHC2_CLK                         = IOMUX_PAD(0x0468, 0x01DC, 1, 0x0670, 0, 0),
+	MX6_PAD_CSI_VSYNC__SIM1_PORT1_CLK                     = IOMUX_PAD(0x0468, 0x01DC, 2, 0x0000, 0, 0),
+	MX6_PAD_CSI_VSYNC__I2C2_SDA                           = IOMUX_PAD(0x0468, 0x01DC, IOMUX_CONFIG_SION | 3, 0x05B0, 0, 0),
+	MX6_PAD_CSI_VSYNC__EIM_RW                             = IOMUX_PAD(0x0468, 0x01DC, 4, 0x0000, 0, 0),
+	MX6_PAD_CSI_VSYNC__GPIO4_IO19                         = IOMUX_PAD(0x0468, 0x01DC, 5, 0x0000, 0, 0),
+	MX6_PAD_CSI_VSYNC__PWM7_OUT                           = IOMUX_PAD(0x0468, 0x01DC, 6, 0x0000, 0, 0),
+	MX6_PAD_CSI_VSYNC__UART6_DCE_RTS                      = IOMUX_PAD(0x0468, 0x01DC, 8, 0x0648, 0, 0),
+	MX6_PAD_CSI_VSYNC__UART6_DTE_CTS                      = IOMUX_PAD(0x0468, 0x01DC, 8, 0x0000, 0, 0),
+
+	MX6_PAD_CSI_HSYNC__CSI_HSYNC                          = IOMUX_PAD(0x046C, 0x01E0, 0, 0x0524, 0, 0),
+	MX6_PAD_CSI_HSYNC__USDHC2_CMD                         = IOMUX_PAD(0x046C, 0x01E0, 1, 0x0678, 0, 0),
+	MX6_PAD_CSI_HSYNC__SIM1_PORT1_PD                      = IOMUX_PAD(0x046C, 0x01E0, 2, 0x0000, 0, 0),
+	MX6_PAD_CSI_HSYNC__I2C2_SCL                           = IOMUX_PAD(0x046C, 0x01E0, IOMUX_CONFIG_SION | 3, 0x05AC, 0, 0),
+	MX6_PAD_CSI_HSYNC__EIM_LBA_B                          = IOMUX_PAD(0x046C, 0x01E0, 4, 0x0000, 0, 0),
+	MX6_PAD_CSI_HSYNC__GPIO4_IO20                         = IOMUX_PAD(0x046C, 0x01E0, 5, 0x0000, 0, 0),
+	MX6_PAD_CSI_HSYNC__PWM8_OUT                           = IOMUX_PAD(0x046C, 0x01E0, 6, 0x0000, 0, 0),
+	MX6_PAD_CSI_HSYNC__UART6_DCE_CTS                      = IOMUX_PAD(0x046C, 0x01E0, 8, 0x0000, 0, 0),
+	MX6_PAD_CSI_HSYNC__UART6_DTE_RTS                      = IOMUX_PAD(0x046C, 0x01E0, 8, 0x0648, 1, 0),
+
+	MX6_PAD_CSI_DATA00__CSI_DATA02                        = IOMUX_PAD(0x0470, 0x01E4, 0, 0x04C4, 0, 0),
+	MX6_PAD_CSI_DATA00__USDHC2_DATA0                      = IOMUX_PAD(0x0470, 0x01E4, 1, 0x067C, 0, 0),
+	MX6_PAD_CSI_DATA00__SIM1_PORT1_RST_B                  = IOMUX_PAD(0x0470, 0x01E4, 2, 0x0000, 0, 0),
+	MX6_PAD_CSI_DATA00__ECSPI2_SCLK                       = IOMUX_PAD(0x0470, 0x01E4, 3, 0x0544, 0, 0),
+	MX6_PAD_CSI_DATA00__EIM_AD00                          = IOMUX_PAD(0x0470, 0x01E4, 4, 0x0000, 0, 0),
+	MX6_PAD_CSI_DATA00__GPIO4_IO21                        = IOMUX_PAD(0x0470, 0x01E4, 5, 0x0000, 0, 0),
+	MX6_PAD_CSI_DATA00__SRC_INT_BOOT                      = IOMUX_PAD(0x0470, 0x01E4, 6, 0x0000, 0, 0),
+	MX6_PAD_CSI_DATA00__UART5_DCE_TX                      = IOMUX_PAD(0x0470, 0x01E4, 8, 0x0000, 0, 0),
+	MX6_PAD_CSI_DATA00__UART5_DTE_RX                      = IOMUX_PAD(0x0470, 0x01E4, 8, 0x0644, 0, 0),
+
+	MX6_PAD_CSI_DATA01__CSI_DATA03                        = IOMUX_PAD(0x0474, 0x01E8, 0, 0x04C8, 0, 0),
+	MX6_PAD_CSI_DATA01__USDHC2_DATA1                      = IOMUX_PAD(0x0474, 0x01E8, 1, 0x0680, 0, 0),
+	MX6_PAD_CSI_DATA01__SIM1_PORT1_SVEN                   = IOMUX_PAD(0x0474, 0x01E8, 2, 0x0000, 0, 0),
+	MX6_PAD_CSI_DATA01__ECSPI2_SS0                        = IOMUX_PAD(0x0474, 0x01E8, 3, 0x0550, 0, 0),
+	MX6_PAD_CSI_DATA01__EIM_AD01                          = IOMUX_PAD(0x0474, 0x01E8, 4, 0x0000, 0, 0),
+	MX6_PAD_CSI_DATA01__GPIO4_IO22                        = IOMUX_PAD(0x0474, 0x01E8, 5, 0x0000, 0, 0),
+	MX6_PAD_CSI_DATA01__SAI1_MCLK                         = IOMUX_PAD(0x0474, 0x01E8, 6, 0x05E0, 0, 0),
+	MX6_PAD_CSI_DATA01__UART5_DCE_RX                      = IOMUX_PAD(0x0474, 0x01E8, 8, 0x0644, 1, 0),
+	MX6_PAD_CSI_DATA01__UART5_DTE_TX                      = IOMUX_PAD(0x0474, 0x01E8, 8, 0x0000, 0, 0),
+
+	MX6_PAD_CSI_DATA02__CSI_DATA04                        = IOMUX_PAD(0x0478, 0x01EC, 0, 0x04D8, 1, 0),
+	MX6_PAD_CSI_DATA02__USDHC2_DATA2                      = IOMUX_PAD(0x0478, 0x01EC, 1, 0x0684, 2, 0),
+	MX6_PAD_CSI_DATA02__SIM1_PORT1_TRXD                   = IOMUX_PAD(0x0478, 0x01EC, 2, 0x0000, 0, 0),
+	MX6_PAD_CSI_DATA02__ECSPI2_MOSI                       = IOMUX_PAD(0x0478, 0x01EC, 3, 0x054C, 1, 0),
+	MX6_PAD_CSI_DATA02__EIM_AD02                          = IOMUX_PAD(0x0478, 0x01EC, 4, 0x0000, 0, 0),
+	MX6_PAD_CSI_DATA02__GPIO4_IO23                        = IOMUX_PAD(0x0478, 0x01EC, 5, 0x0000, 0, 0),
+	MX6_PAD_CSI_DATA02__SAI1_RX_SYNC                      = IOMUX_PAD(0x0478, 0x01EC, 6, 0x0000, 0, 0),
+	MX6_PAD_CSI_DATA02__UART5_DCE_RTS                     = IOMUX_PAD(0x0478, 0x01EC, 8, 0x0640, 5, 0),
+	MX6_PAD_CSI_DATA02__UART5_DTE_CTS                     = IOMUX_PAD(0x0478, 0x01EC, 8, 0x0000, 0, 0),
+
+	MX6_PAD_CSI_DATA03__CSI_DATA05                        = IOMUX_PAD(0x047C, 0x01F0, 0, 0x04CC, 0, 0),
+	MX6_PAD_CSI_DATA03__USDHC2_DATA3                      = IOMUX_PAD(0x047C, 0x01F0, 1, 0x0688, 0, 0),
+	MX6_PAD_CSI_DATA03__SIM2_PORT1_PD                     = IOMUX_PAD(0x047C, 0x01F0, 2, 0x0000, 0, 0),
+	MX6_PAD_CSI_DATA03__ECSPI2_MISO                       = IOMUX_PAD(0x047C, 0x01F0, 3, 0x0548, 0, 0),
+	MX6_PAD_CSI_DATA03__EIM_AD03                          = IOMUX_PAD(0x047C, 0x01F0, 4, 0x0000, 0, 0),
+	MX6_PAD_CSI_DATA03__GPIO4_IO24                        = IOMUX_PAD(0x047C, 0x01F0, 5, 0x0000, 0, 0),
+	MX6_PAD_CSI_DATA03__SAI1_RX_BCLK                      = IOMUX_PAD(0x047C, 0x01F0, 6, 0x0000, 0, 0),
+	MX6_PAD_CSI_DATA03__UART5_DCE_CTS                     = IOMUX_PAD(0x047C, 0x01F0, 8, 0x0000, 0, 0),
+	MX6_PAD_CSI_DATA03__UART5_DTE_RTS                     = IOMUX_PAD(0x047C, 0x01F0, 8, 0x0640, 0, 0),
+
+	MX6_PAD_CSI_DATA04__CSI_DATA06                        = IOMUX_PAD(0x0480, 0x01F4, 0, 0x04DC, 1, 0),
+	MX6_PAD_CSI_DATA04__USDHC2_DATA4                      = IOMUX_PAD(0x0480, 0x01F4, 1, 0x068C, 2, 0),
+	MX6_PAD_CSI_DATA04__SIM2_PORT1_CLK                    = IOMUX_PAD(0x0480, 0x01F4, 2, 0x0000, 0, 0),
+	MX6_PAD_CSI_DATA04__ECSPI1_SCLK                       = IOMUX_PAD(0x0480, 0x01F4, 3, 0x0534, 1, 0),
+	MX6_PAD_CSI_DATA04__EIM_AD04                          = IOMUX_PAD(0x0480, 0x01F4, 4, 0x0000, 0, 0),
+	MX6_PAD_CSI_DATA04__GPIO4_IO25                        = IOMUX_PAD(0x0480, 0x01F4, 5, 0x0000, 0, 0),
+	MX6_PAD_CSI_DATA04__SAI1_TX_SYNC                      = IOMUX_PAD(0x0480, 0x01F4, 6, 0x05EC, 1, 0),
+	MX6_PAD_CSI_DATA04__USDHC1_WP                         = IOMUX_PAD(0x0480, 0x01F4, 8, 0x066C, 2, 0),
+
+	MX6_PAD_CSI_DATA05__CSI_DATA07                        = IOMUX_PAD(0x0484, 0x01F8, 0, 0x04E0, 1, 0),
+	MX6_PAD_CSI_DATA05__USDHC2_DATA5                      = IOMUX_PAD(0x0484, 0x01F8, 1, 0x0690, 2, 0),
+	MX6_PAD_CSI_DATA05__SIM2_PORT1_RST_B                  = IOMUX_PAD(0x0484, 0x01F8, 2, 0x0000, 0, 0),
+	MX6_PAD_CSI_DATA05__ECSPI1_SS0                        = IOMUX_PAD(0x0484, 0x01F8, 3, 0x0540, 1, 0),
+	MX6_PAD_CSI_DATA05__EIM_AD05                          = IOMUX_PAD(0x0484, 0x01F8, 4, 0x0000, 0, 0),
+	MX6_PAD_CSI_DATA05__GPIO4_IO26                        = IOMUX_PAD(0x0484, 0x01F8, 5, 0x0000, 0, 0),
+	MX6_PAD_CSI_DATA05__SAI1_TX_BCLK                      = IOMUX_PAD(0x0484, 0x01F8, 6, 0x05E8, 1, 0),
+	MX6_PAD_CSI_DATA05__USDHC1_CD_B                       = IOMUX_PAD(0x0484, 0x01F8, 8, 0x0668, 2, 0),
+
+	MX6_PAD_CSI_DATA06__CSI_DATA08                        = IOMUX_PAD(0x0488, 0x01FC, 0, 0x04E4, 1, 0),
+	MX6_PAD_CSI_DATA06__USDHC2_DATA6                      = IOMUX_PAD(0x0488, 0x01FC, 1, 0x0694, 2, 0),
+	MX6_PAD_CSI_DATA06__SIM2_PORT1_SVEN                   = IOMUX_PAD(0x0488, 0x01FC, 2, 0x0000, 0, 0),
+	MX6_PAD_CSI_DATA06__ECSPI1_MOSI                       = IOMUX_PAD(0x0488, 0x01FC, 3, 0x053C, 1, 0),
+	MX6_PAD_CSI_DATA06__EIM_AD06                          = IOMUX_PAD(0x0488, 0x01FC, 4, 0x0000, 0, 0),
+	MX6_PAD_CSI_DATA06__GPIO4_IO27                        = IOMUX_PAD(0x0488, 0x01FC, 5, 0x0000, 0, 0),
+	MX6_PAD_CSI_DATA06__SAI1_RX_DATA                      = IOMUX_PAD(0x0488, 0x01FC, 6, 0x05E4, 1, 0),
+	MX6_PAD_CSI_DATA06__USDHC1_RESET_B                    = IOMUX_PAD(0x0488, 0x01FC, 8, 0x0000, 0, 0),
+
+	MX6_PAD_CSI_DATA07__CSI_DATA09                        = IOMUX_PAD(0x048C, 0x0200, 0, 0x04E8, 1, 0),
+	MX6_PAD_CSI_DATA07__USDHC2_DATA7                      = IOMUX_PAD(0x048C, 0x0200, 1, 0x0698, 2, 0),
+	MX6_PAD_CSI_DATA07__SIM2_PORT1_TRXD                   = IOMUX_PAD(0x048C, 0x0200, 2, 0x0000, 0, 0),
+	MX6_PAD_CSI_DATA07__ECSPI1_MISO                       = IOMUX_PAD(0x048C, 0x0200, 3, 0x0538, 1, 0),
+	MX6_PAD_CSI_DATA07__EIM_AD07                          = IOMUX_PAD(0x048C, 0x0200, 4, 0x0000, 0, 0),
+	MX6_PAD_CSI_DATA07__GPIO4_IO28                        = IOMUX_PAD(0x048C, 0x0200, 5, 0x0000, 0, 0),
+	MX6_PAD_CSI_DATA07__SAI1_TX_DATA                      = IOMUX_PAD(0x048C, 0x0200, 6, 0x0000, 0, 0),
+	MX6_PAD_CSI_DATA07__USDHC1_VSELECT                    = IOMUX_PAD(0x048C, 0x0200, 8, 0x0000, 0, 0),
+};
+#endif  /* __ASM_ARCH_IMX6ULL_PINS_H__ */
diff --git a/arch/arm/include/asm/arch-mx7/mx7d_pins.h b/arch/arm/include/asm/arch-mx7/mx7d_pins.h
index 0ab1246..d8b4097 100644
--- a/arch/arm/include/asm/arch-mx7/mx7d_pins.h
+++ b/arch/arm/include/asm/arch-mx7/mx7d_pins.h
@@ -635,7 +635,7 @@ enum {
 	MX7D_PAD_LCD_DATA23__GPIO3_IO28                          = IOMUX_PAD(0x0394, 0x0124, 5, 0x0000, 0, 0),
 	MX7D_PAD_LCD_DATA23__I2C4_SDA                            = IOMUX_PAD(0x0394, 0x0124, IOMUX_CONFIG_SION | 6, 0x05F0, 1, 0),
 
-	MX7D_PAD_UART1_RX_DATA__UART1_DCE_RX                     = IOMUX_PAD(0x0398, 0x0128, 0, 0x06F4, 0, 0),
+	MX7D_PAD_UART1_RX_DATA__UART1_DCE_RX                     = IOMUX_PAD(0x0398, 0x0128, 0, 0x0000, 0, 0),
 
 	MX7D_PAD_UART1_RX_DATA__UART1_DTE_TX                     = IOMUX_PAD(0x0398, 0x0128, 0, 0x0000, 0, 0),
 	MX7D_PAD_UART1_RX_DATA__I2C1_SCL                         = IOMUX_PAD(0x0398, 0x0128, IOMUX_CONFIG_SION | 1, 0x0000, 0, 0),
@@ -655,7 +655,7 @@ enum {
 	MX7D_PAD_UART1_TX_DATA__GPIO4_IO1                        = IOMUX_PAD(0x039C, 0x012C, 5, 0x0000, 0, 0),
 	MX7D_PAD_UART1_TX_DATA__ENET1_MDC                        = IOMUX_PAD(0x039C, 0x012C, 6, 0x0000, 0, 0),
 
-	MX7D_PAD_UART2_RX_DATA__UART2_DCE_RX                     = IOMUX_PAD(0x03A0, 0x0130, 0, 0x06FC, 2, 0),
+	MX7D_PAD_UART2_RX_DATA__UART2_DCE_RX                     = IOMUX_PAD(0x03A0, 0x0130, 0, 0x0000, 0, 0),
 
 	MX7D_PAD_UART2_RX_DATA__UART2_DTE_TX                     = IOMUX_PAD(0x03A0, 0x0130, 0, 0x0000, 0, 0),
 	MX7D_PAD_UART2_RX_DATA__I2C2_SCL                         = IOMUX_PAD(0x03A0, 0x0130, IOMUX_CONFIG_SION | 1, 0x0000, 0, 0),
@@ -667,7 +667,7 @@ enum {
 
 	MX7D_PAD_UART2_TX_DATA__UART2_DCE_TX                     = IOMUX_PAD(0x03A4, 0x0134, 0, 0x0000, 0, 0),
 
-	MX7D_PAD_UART2_TX_DATA__UART2_DTE_RX                     = IOMUX_PAD(0x03A4, 0x0134, 0, 0x06FC, 3, 0),
+	MX7D_PAD_UART2_TX_DATA__UART2_DTE_RX                     = IOMUX_PAD(0x03A4, 0x0134, 0, 0x0000, 0, 0),
 	MX7D_PAD_UART2_TX_DATA__I2C2_SDA                         = IOMUX_PAD(0x03A4, 0x0134, IOMUX_CONFIG_SION | 1, 0x05E0, 0, 0),
 	MX7D_PAD_UART2_TX_DATA__SAI3_RX_DATA0                    = IOMUX_PAD(0x03A4, 0x0134, 2, 0x06C8, 0, 0),
 	MX7D_PAD_UART2_TX_DATA__ECSPI1_RDY                       = IOMUX_PAD(0x03A4, 0x0134, 3, 0x0000, 0, 0),
@@ -695,7 +695,7 @@ enum {
 	MX7D_PAD_UART3_TX_DATA__GPIO4_IO5                        = IOMUX_PAD(0x03AC, 0x013C, 5, 0x0000, 0, 0),
 	MX7D_PAD_UART3_TX_DATA__SD2_LCTL                         = IOMUX_PAD(0x03AC, 0x013C, 6, 0x0000, 0, 0),
 
-	MX7D_PAD_UART3_RTS_B__UART3_DCE_RTS                      = IOMUX_PAD(0x03B0, 0x0140, 0, 0x0700, 2, 0),
+	MX7D_PAD_UART3_RTS_B__UART3_DCE_RTS                      = IOMUX_PAD(0x03B0, 0x0140, 0, 0x0000, 0, 0),
 
 	MX7D_PAD_UART3_RTS_B__UART3_DTE_CTS                      = IOMUX_PAD(0x03B0, 0x0140, 0, 0x0000, 0, 0),
 	MX7D_PAD_UART3_RTS_B__USB_OTG2_OC                        = IOMUX_PAD(0x03B0, 0x0140, 1, 0x0000, 0, 0),
diff --git a/arch/arm/include/asm/imx-common/regs-bch.h b/arch/arm/include/asm/imx-common/regs-bch.h
index 3f4feaf..0322403 100644
--- a/arch/arm/include/asm/imx-common/regs-bch.h
+++ b/arch/arm/include/asm/imx-common/regs-bch.h
@@ -5,7 +5,7 @@
  * on behalf of DENX Software Engineering GmbH
  *
  * Based on code from LTIB:
- * Copyright 2008-2016 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2008-2015 Freescale Semiconductor, Inc. All Rights Reserved.
  *
  * SPDX-License-Identifier:	GPL-2.0+
  */
@@ -41,7 +41,6 @@ struct mxs_bch_regs {
 	mxs_reg_32(hw_bch_dbgahbmread)
 	mxs_reg_32(hw_bch_blockname)
 	mxs_reg_32(hw_bch_version)
-	mxs_reg_32(hw_bch_debug1)
 };
 #endif
 
@@ -77,9 +76,6 @@ struct mxs_bch_regs {
 
 #define	BCH_MODE_ERASE_THRESHOLD_MASK			0xff
 #define	BCH_MODE_ERASE_THRESHOLD_OFFSET			0
-#define BCH_MODE_ERASE_THRESHOLD(v)			\
-	(((v) << BCH_MODE_ERASE_THRESHOLD_OFFSET) &	\
-	 BCH_MODE_ERASE_THRESHOLD_MASK)
 
 #define	BCH_ENCODEPTR_ADDR_MASK				0xffffffff
 #define	BCH_ENCODEPTR_ADDR_OFFSET			0
diff --git a/board/freescale/common/recovery.c b/board/freescale/common/recovery.c
index e6f2137..9fa31c4 100644
--- a/board/freescale/common/recovery.c
+++ b/board/freescale/common/recovery.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2010-2014 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright (C) 2010-2016 Freescale Semiconductor, Inc. All Rights Reserved.
  *
  * SPDX-License-Identifier:	GPL-2.0+
  */
@@ -72,6 +72,11 @@ void check_recovery_mode(void)
 	} else if (check_recovery_cmd_file()) {
 		puts("Fastboot: Recovery command file found!\n");
 		setup_recovery_env();
+#ifdef CONFIG_BCB_SUPPORT
+	} else if (recovery_check_and_clean_command()) {
+		puts("Fastboot: BCB command found\n");
+		setup_recovery_env();
+#endif
 	} else {
 		puts("Fastboot: Normal\n");
 	}
diff --git a/board/freescale/mx6qarm2/mt128x64mx32.cfg b/board/freescale/mx6qarm2/mt128x64mx32.cfg
index adc8c4b..35a686f 100644
--- a/board/freescale/mx6qarm2/mt128x64mx32.cfg
+++ b/board/freescale/mx6qarm2/mt128x64mx32.cfg
@@ -209,7 +209,7 @@ DATA 4 	0x021b002c	0x0F9F26D2	// MMDC0_MDRWD
 DATA 4 	0x021b0030	0x009F0E10	// MMDC0_MDOR
 DATA 4 	0x021b0038	0x001A0889	// MMDC0_MDCFG3LP
 DATA 4 	0x021b0008	0x00000000	// MMDC0_MDOTC
-DATA 4 	0x021b0040	0x00000053	// Chan0 CS0_END 2 channel with 4K-interleave mode
+DATA 4 	0x021b0040	0x0000004F	// Chan0 CS0_END 2 channel with 2 Channel fixed mode
 // DATA 4  	0x021b0400	0x11420000      	//MMDC0_MAARCR ADOPT optimized priorities. Dyn jump disabled
 DATA 4 	0x021b0000	0x83110000	// MMDC0_MDCTL
 
@@ -224,7 +224,7 @@ DATA 4 	0x021b402c	0x0F9F26D2	// MMDC1_MDRWD
 DATA 4 	0x021b4030	0x009F0E10	// MMDC1_MDOR
 DATA 4 	0x021b4038	0x001A0889	// MMDC1_MDCFG3LP
 DATA 4 	0x021b4008	0x00000000	// MMDC1_MDOTC
-DATA 4 	0x021b4040	0x00000013	// Chan1 CS0_END
+DATA 4 	0x021b4040	0x00000017	// Chan1 CS0_END
 // DATA 4  	0x021b4400	0x11420000      	//MMDC0_MAARCR ADOPT optimized priorities. Dyn jump disabled
 DATA 4 	0x021b4000	0x83110000	// MMDC1_MDCTL
 
diff --git a/board/freescale/mx6qarm2/mx6qarm2.c b/board/freescale/mx6qarm2/mx6qarm2.c
index 188096b..72f59ef 100644
--- a/board/freescale/mx6qarm2/mx6qarm2.c
+++ b/board/freescale/mx6qarm2/mx6qarm2.c
@@ -47,6 +47,15 @@ int dram_init(void)
 	return 0;
 }
 
+#if defined(CONFIG_MX6DQ_POP_LPDDR2)
+void dram_init_banksize(void) {
+	gd->bd->bi_dram[0].start = PHYS_SDRAM_0;
+	gd->bd->bi_dram[0].size = (phys_size_t)CONFIG_DDR_MB * 1024 * 1024;
+	gd->bd->bi_dram[1].start = PHYS_SDRAM_1;
+	gd->bd->bi_dram[1].size = (phys_size_t)CONFIG_DDR_MB * 1024 * 1024;
+}
+#endif
+
 iomux_v3_cfg_t const uart4_pads[] = {
 	MX6_PAD_KEY_COL0__UART4_TX_DATA | MUX_PAD_CTRL(UART_PAD_CTRL),
 	MX6_PAD_KEY_ROW0__UART4_RX_DATA | MUX_PAD_CTRL(UART_PAD_CTRL),
diff --git a/board/freescale/mx6sabresd/mx6sabresd.c b/board/freescale/mx6sabresd/mx6sabresd.c
index 88f5d96..716e2d7 100644
--- a/board/freescale/mx6sabresd/mx6sabresd.c
+++ b/board/freescale/mx6sabresd/mx6sabresd.c
@@ -865,16 +865,6 @@ int overwrite_console(void)
 
 int board_eth_init(bd_t *bis)
 {
-	if (is_mx6dqp()) {
-		int ret;
-
-		/* select ENET MAC0 TX clock from PLL */
-		imx_iomux_set_gpr_register(5, 9, 1, 1);
-		ret = enable_fec_anatop_clock(0, ENET_125MHZ);
-		if (ret)
-		    printf("Error fec anatop clock settings!\n");
-	}
-
 	setup_iomux_enet();
 	setup_pcie();
 
diff --git a/board/freescale/mx6ul_14x14_evk/mx6ul_14x14_evk.c b/board/freescale/mx6ul_14x14_evk/mx6ul_14x14_evk.c
index 768138c..7e8947c 100644
--- a/board/freescale/mx6ul_14x14_evk/mx6ul_14x14_evk.c
+++ b/board/freescale/mx6ul_14x14_evk/mx6ul_14x14_evk.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2015-2016 Freescale Semiconductor, Inc.
+ * Copyright (C) 2015 Freescale Semiconductor, Inc.
  *
  * SPDX-License-Identifier:	GPL-2.0+
  */
diff --git a/board/freescale/mx6ull_ddr3_arm2/Kconfig b/board/freescale/mx6ull_ddr3_arm2/Kconfig
new file mode 100644
index 0000000..e351ad8
--- /dev/null
+++ b/board/freescale/mx6ull_ddr3_arm2/Kconfig
@@ -0,0 +1,12 @@
+if TARGET_MX6ULL_DDR3_ARM2
+
+config SYS_BOARD
+       default "mx6ull_ddr3_arm2"
+
+config SYS_VENDOR
+       default "freescale"
+
+config SYS_CONFIG_NAME
+       default "mx6ull_ddr3_arm2"
+
+endif
diff --git a/board/freescale/mx6ull_ddr3_arm2/Makefile b/board/freescale/mx6ull_ddr3_arm2/Makefile
new file mode 100644
index 0000000..d6a08fa
--- /dev/null
+++ b/board/freescale/mx6ull_ddr3_arm2/Makefile
@@ -0,0 +1,10 @@
+# (C) Copyright 2016 Freescale Semiconductor, Inc.
+#
+# SPDX-License-Identifier:	GPL-2.0+
+#
+
+obj-y  := mx6ull_ddr3_arm2.o
+
+extra-$(CONFIG_USE_PLUGIN) :=  plugin.bin
+$(obj)/plugin.bin: $(obj)/plugin.o
+	$(OBJCOPY) -O binary --gap-fill 0xff $< $@
diff --git a/board/freescale/mx6ull_ddr3_arm2/imximage.cfg b/board/freescale/mx6ull_ddr3_arm2/imximage.cfg
new file mode 100644
index 0000000..55a4a44
--- /dev/null
+++ b/board/freescale/mx6ull_ddr3_arm2/imximage.cfg
@@ -0,0 +1,114 @@
+/*
+ * Copyright (C) 2016 Freescale Semiconductor, Inc.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ *
+ * Refer docs/README.imxmage for more details about how-to configure
+ * and create imximage boot image
+ *
+ * The syntax is taken as close as possible with the kwbimage
+ */
+
+#define __ASSEMBLY__
+#include <config.h>
+
+/* image version */
+
+IMAGE_VERSION 2
+
+/*
+ * Boot Device : one of
+ * spi/sd/nand/onenand, qspi/nor
+ */
+
+#ifdef CONFIG_SYS_BOOT_QSPI
+BOOT_FROM	qspi
+#elif defined(CONFIG_SYS_BOOT_EIMNOR)
+BOOT_FROM	nor
+#else
+BOOT_FROM	sd
+#endif
+
+#ifdef CONFIG_USE_PLUGIN
+/*PLUGIN    plugin-binary-file    IRAM_FREE_START_ADDR*/
+PLUGIN	board/freescale/mx6ul_14x14_ddr3_arm2/plugin.bin 0x00907000
+#else
+
+#ifdef CONFIG_SECURE_BOOT
+CSF CONFIG_CSF_SIZE
+#endif
+
+/*
+ * Device Configuration Data (DCD)
+ *
+ * Each entry must have the format:
+ * Addr-type           Address        Value
+ *
+ * where:
+ *	Addr-type register length (1,2 or 4 bytes)
+ *	Address	  absolute address of the register
+ *	value	  value to be stored in the register
+ */
+
+DATA 4 0x020c4068 0xffffffff
+DATA 4 0x020c406c 0xffffffff
+DATA 4 0x020c4070 0xffffffff
+DATA 4 0x020c4074 0xffffffff
+DATA 4 0x020c4078 0xffffffff
+DATA 4 0x020c407c 0xffffffff
+DATA 4 0x020c4080 0xffffffff
+
+DATA 4 0x020E04B4 0x000C0000
+DATA 4 0x020E04AC 0x00000000
+DATA 4 0x020E027C 0x00000030
+DATA 4 0x020E0250 0x00000030
+DATA 4 0x020E024C 0x00000030
+DATA 4 0x020E0490 0x00000030
+DATA 4 0x020E0288 0x00000030
+DATA 4 0x020E0270 0x00000000
+DATA 4 0x020E0260 0x00000030
+DATA 4 0x020E0264 0x00000030
+DATA 4 0x020E04A0 0x00000030
+DATA 4 0x020E0494 0x00020000
+DATA 4 0x020E0280 0x00000030
+DATA 4 0x020E0284 0x00000030
+DATA 4 0x020E04B0 0x00020000
+DATA 4 0x020E0498 0x00000030
+DATA 4 0x020E04A4 0x00000030
+DATA 4 0x020E0244 0x00000030
+DATA 4 0x020E0248 0x00000030
+DATA 4 0x021B001C 0x00008000
+DATA 4 0x021B0800 0xA1390003
+DATA 4 0x021B080C 0x00150019
+DATA 4 0x021B083C 0x41550153
+DATA 4 0x021B0848 0x40403A3E
+DATA 4 0x021B0850 0x40402F2A
+DATA 4 0x021B081C 0x33333333
+DATA 4 0x021B0820 0x33333333
+DATA 4 0x021B082C 0xf3333333
+DATA 4 0x021B0830 0xf3333333
+DATA 4 0x021B08C0 0x00921012
+DATA 4 0x021B08b8 0x00000800
+DATA 4 0x021B0004 0x0002002D
+DATA 4 0x021B0008 0x1B333030
+DATA 4 0x021B000C 0x676B52F3
+DATA 4 0x021B0010 0xB66D0B63
+DATA 4 0x021B0014 0x01FF00DB
+DATA 4 0x021B0018 0x00201740
+DATA 4 0x021B001C 0x00008000
+DATA 4 0x021B002C 0x000026D2
+DATA 4 0x021B0030 0x006B1023
+DATA 4 0x021B0040 0x0000005F
+DATA 4 0x021B0000 0x85180000
+DATA 4 0x021B0890 0x00400A38
+DATA 4 0x021B001C 0x02008032
+DATA 4 0x021B001C 0x00008033
+DATA 4 0x021B001C 0x00048031
+DATA 4 0x021B001C 0x15208030
+DATA 4 0x021B001C 0x04008040
+DATA 4 0x021B0020 0x00000800
+DATA 4 0x021B0818 0x00000227
+DATA 4 0x021B0004 0x0002552D
+DATA 4 0x021B0404 0x00011006
+DATA 4 0x021B001C 0x00000000
+#endif
diff --git a/board/freescale/mx6ull_ddr3_arm2/mx6ull_ddr3_arm2.c b/board/freescale/mx6ull_ddr3_arm2/mx6ull_ddr3_arm2.c
new file mode 100644
index 0000000..171d34e
--- /dev/null
+++ b/board/freescale/mx6ull_ddr3_arm2/mx6ull_ddr3_arm2.c
@@ -0,0 +1,949 @@
+/*
+ * Copyright (C) 2016 Freescale Semiconductor, Inc.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <asm/arch/clock.h>
+#include <asm/arch/crm_regs.h>
+#include <asm/arch/iomux.h>
+#include <asm/arch/imx-regs.h>
+#include <asm/arch/mx6-pins.h>
+#include <asm/arch/sys_proto.h>
+#include <asm/gpio.h>
+#include <asm/imx-common/iomux-v3.h>
+#include <asm/imx-common/boot_mode.h>
+#include <asm/imx-common/mxc_i2c.h>
+#include <asm/io.h>
+#include <common.h>
+#include <fsl_esdhc.h>
+#include <i2c.h>
+#include <linux/sizes.h>
+#include <linux/fb.h>
+#include <miiphy.h>
+#include <mmc.h>
+#include <mxsfb.h>
+#include <netdev.h>
+#include <power/pmic.h>
+#include <power/pfuze100_pmic.h>
+#include "../common/pfuze.h"
+#include <usb.h>
+#include <usb/ehci-fsl.h>
+
+DECLARE_GLOBAL_DATA_PTR;
+
+#define UART_PAD_CTRL  (PAD_CTL_PKE | PAD_CTL_PUE |		\
+	PAD_CTL_PUS_100K_UP | PAD_CTL_SPEED_MED |		\
+	PAD_CTL_DSE_40ohm   | PAD_CTL_SRE_FAST  | PAD_CTL_HYS)
+
+#define USDHC_PAD_CTRL (PAD_CTL_PKE | PAD_CTL_PUE |		\
+	PAD_CTL_PUS_22K_UP  | PAD_CTL_SPEED_LOW |		\
+	PAD_CTL_DSE_80ohm   | PAD_CTL_SRE_FAST  | PAD_CTL_HYS)
+
+#define USDHC_PAD_CTRL_WP (PAD_CTL_PKE | PAD_CTL_PUE |		\
+	PAD_CTL_PUS_100K_DOWN | PAD_CTL_SPEED_LOW |		\
+	PAD_CTL_DSE_80ohm   | PAD_CTL_SRE_FAST  | PAD_CTL_HYS)
+
+#define ENET_PAD_CTRL  (PAD_CTL_PUS_100K_UP | PAD_CTL_PUE |     \
+	PAD_CTL_SPEED_HIGH   |                                   \
+	PAD_CTL_DSE_48ohm   | PAD_CTL_SRE_FAST)
+
+#define ENET_CLK_PAD_CTRL  (PAD_CTL_SPEED_MED | \
+	PAD_CTL_DSE_120ohm   | PAD_CTL_SRE_FAST)
+
+#define ENET_RX_PAD_CTRL  (PAD_CTL_PKE | PAD_CTL_PUE |          \
+	PAD_CTL_SPEED_HIGH   | PAD_CTL_SRE_FAST)
+
+#define I2C_PAD_CTRL    (PAD_CTL_PKE | PAD_CTL_PUE |            \
+	PAD_CTL_PUS_100K_UP | PAD_CTL_SPEED_MED |               \
+	PAD_CTL_DSE_40ohm | PAD_CTL_HYS |			\
+	PAD_CTL_ODE)
+
+#define LCD_PAD_CTRL    (PAD_CTL_HYS | PAD_CTL_PUS_100K_UP | PAD_CTL_PUE | \
+	PAD_CTL_PKE | PAD_CTL_SPEED_MED | PAD_CTL_DSE_40ohm)
+
+#define GPMI_PAD_CTRL0 (PAD_CTL_PKE | PAD_CTL_PUE | PAD_CTL_PUS_100K_UP)
+#define GPMI_PAD_CTRL1 (PAD_CTL_DSE_40ohm | PAD_CTL_SPEED_MED | \
+			PAD_CTL_SRE_FAST)
+#define GPMI_PAD_CTRL2 (GPMI_PAD_CTRL0 | GPMI_PAD_CTRL1)
+
+#define WEIM_NOR_PAD_CTRL (PAD_CTL_PKE | PAD_CTL_PUE | \
+		PAD_CTL_PUS_100K_UP | PAD_CTL_SPEED_MED | \
+		PAD_CTL_DSE_40ohm   | PAD_CTL_SRE_FAST)
+
+#define SPI_PAD_CTRL (PAD_CTL_HYS |				\
+	PAD_CTL_SPEED_MED |		\
+	PAD_CTL_DSE_40ohm | PAD_CTL_SRE_FAST)
+
+#define OTG_ID_PAD_CTRL (PAD_CTL_PKE | PAD_CTL_PUE |		\
+	PAD_CTL_PUS_47K_UP  | PAD_CTL_SPEED_LOW |		\
+	PAD_CTL_DSE_80ohm   | PAD_CTL_SRE_FAST  | PAD_CTL_HYS)
+
+#ifdef CONFIG_SYS_I2C_MXC
+#define PC MUX_PAD_CTRL(I2C_PAD_CTRL)
+/* I2C1 for PMIC and EEPROM */
+struct i2c_pads_info i2c_pad_info1 = {
+	.scl = {
+		/* conflict with usb_otg2_pwr */
+		.i2c_mode = MX6_PAD_GPIO1_IO02__I2C1_SCL | PC,
+		.gpio_mode = MX6_PAD_GPIO1_IO02__GPIO1_IO02 | PC,
+		.gp = IMX_GPIO_NR(1, 2),
+	},
+	.sda = {
+		/* conflict with usb_otg2_oc */
+		.i2c_mode = MX6_PAD_GPIO1_IO03__I2C1_SDA | PC,
+		.gpio_mode = MX6_PAD_GPIO1_IO03__GPIO1_IO03 | PC,
+		.gp = IMX_GPIO_NR(1, 3),
+	},
+};
+#endif
+
+int dram_init(void)
+{
+	gd->ram_size = PHYS_SDRAM_SIZE;
+
+	return 0;
+}
+
+static iomux_v3_cfg_t const uart1_pads[] = {
+	MX6_PAD_UART1_TX_DATA__UART1_DCE_TX | MUX_PAD_CTRL(UART_PAD_CTRL),
+	MX6_PAD_UART1_RX_DATA__UART1_DCE_RX | MUX_PAD_CTRL(UART_PAD_CTRL),
+};
+
+#ifdef CONFIG_MX6ULL_DDR3_ARM2_EMMC_REWORK
+static iomux_v3_cfg_t const usdhc1_emmc_pads[] = {
+	MX6_PAD_SD1_CLK__USDHC1_CLK | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD1_CMD__USDHC1_CMD | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD1_DATA0__USDHC1_DATA0 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD1_DATA1__USDHC1_DATA1 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD1_DATA2__USDHC1_DATA2 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD1_DATA3__USDHC1_DATA3 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+#if !defined(CONFIG_SYS_USE_NAND) && !defined(CONFIG_SYS_USE_QSPI1A)
+	/*
+	 * The following 4 pins conflicts with qspi and nand flash.
+	 * You can comment out the following 4 pins and change
+	 * {USDHC1_BASE_ADDR, 0, 8}  -> {USDHC1_BASE_ADDR, 0, 4}
+	 * to make emmc and qspi coexists.
+	 */
+	MX6_PAD_NAND_READY_B__USDHC1_DATA4 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_NAND_CE0_B__USDHC1_DATA5 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_NAND_CE1_B__USDHC1_DATA6 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_NAND_CLE__USDHC1_DATA7 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+#endif
+
+	/* Default NO WP for emmc, since we use pull down */
+	MX6_PAD_UART1_CTS_B__USDHC1_WP  | MUX_PAD_CTRL(USDHC_PAD_CTRL_WP),
+	/* RST_B */
+	MX6_PAD_GPIO1_IO09__GPIO1_IO09 | MUX_PAD_CTRL(NO_PAD_CTRL),
+};
+#else
+static iomux_v3_cfg_t const usdhc1_pads[] = {
+	MX6_PAD_SD1_CLK__USDHC1_CLK | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD1_CMD__USDHC1_CMD | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD1_DATA0__USDHC1_DATA0 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD1_DATA1__USDHC1_DATA1 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD1_DATA2__USDHC1_DATA2 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD1_DATA3__USDHC1_DATA3 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_UART1_CTS_B__USDHC1_WP | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+
+	/* VSELECT */
+	MX6_PAD_GPIO1_IO05__GPIO1_IO05 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	/* CD */
+	MX6_PAD_UART1_RTS_B__GPIO1_IO19 | MUX_PAD_CTRL(NO_PAD_CTRL),
+	/* RST_B */
+	MX6_PAD_GPIO1_IO09__GPIO1_IO09 | MUX_PAD_CTRL(NO_PAD_CTRL),
+};
+#endif
+
+#if !defined(CONFIG_SYS_USE_NAND) && !defined(CONFIG_SYS_USE_QSPI1B)
+static iomux_v3_cfg_t const usdhc2_pads[] = {
+	/* usdhc2_clk, nand_re_b, qspi1b_clk */
+	MX6_PAD_NAND_RE_B__USDHC2_CLK | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	/* usdhc2_cmd, nand_we_b, qspi1b_cs0_b */
+	MX6_PAD_NAND_WE_B__USDHC2_CMD | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	/* usdhc2_data0, nand_data0, qspi1b_cs1_b */
+	MX6_PAD_NAND_DATA00__USDHC2_DATA0 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	/* usdhc2_data1, nand_data1 */
+	MX6_PAD_NAND_DATA01__USDHC2_DATA1 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	/* usdhc2_data2, nand_data2, qspi1b_dat0 */
+	MX6_PAD_NAND_DATA02__USDHC2_DATA2 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	/* usdhc2_data3, nand_data3, qspi1b_dat1 */
+	MX6_PAD_NAND_DATA03__USDHC2_DATA3 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+
+	/*
+	 * VSELECT
+	 * Conflicts with WDOG1, so default disabled.
+	 * MX6_PAD_GPIO1_IO08__USDHC2_VSELECT | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	 */
+	/*
+	 * CD
+	 * Share with sdhc1
+	 * MX6_PAD_CSI_MCLK__GPIO4_IO17 | MUX_PAD_CTRL(NO_PAD_CTRL),
+	 */
+	/*
+	 * RST_B
+	 * Pin conflicts with NAND ALE, if want to test nand,
+	 * Connect R169(B), disconnect R169(A).
+	 */
+	MX6_PAD_NAND_ALE__GPIO4_IO10 | MUX_PAD_CTRL(NO_PAD_CTRL),
+};
+#endif
+
+#ifdef CONFIG_SYS_USE_NAND
+static iomux_v3_cfg_t const nand_pads[] = {
+	MX6_PAD_NAND_DATA00__RAWNAND_DATA00 | MUX_PAD_CTRL(GPMI_PAD_CTRL2),
+	MX6_PAD_NAND_DATA01__RAWNAND_DATA01 | MUX_PAD_CTRL(GPMI_PAD_CTRL2),
+	MX6_PAD_NAND_DATA02__RAWNAND_DATA02 | MUX_PAD_CTRL(GPMI_PAD_CTRL2),
+	MX6_PAD_NAND_DATA03__RAWNAND_DATA03 | MUX_PAD_CTRL(GPMI_PAD_CTRL2),
+	MX6_PAD_NAND_DATA04__RAWNAND_DATA04 | MUX_PAD_CTRL(GPMI_PAD_CTRL2),
+	MX6_PAD_NAND_DATA05__RAWNAND_DATA05 | MUX_PAD_CTRL(GPMI_PAD_CTRL2),
+	MX6_PAD_NAND_DATA06__RAWNAND_DATA06 | MUX_PAD_CTRL(GPMI_PAD_CTRL2),
+	MX6_PAD_NAND_DATA07__RAWNAND_DATA07 | MUX_PAD_CTRL(GPMI_PAD_CTRL2),
+	MX6_PAD_NAND_CLE__RAWNAND_CLE | MUX_PAD_CTRL(GPMI_PAD_CTRL2),
+	MX6_PAD_NAND_ALE__RAWNAND_ALE | MUX_PAD_CTRL(GPMI_PAD_CTRL2),
+	MX6_PAD_NAND_CE0_B__RAWNAND_CE0_B | MUX_PAD_CTRL(GPMI_PAD_CTRL2),
+	MX6_PAD_NAND_CE1_B__RAWNAND_CE1_B | MUX_PAD_CTRL(GPMI_PAD_CTRL2),
+	MX6_PAD_CSI_MCLK__RAWNAND_CE2_B   | MUX_PAD_CTRL(GPMI_PAD_CTRL2),
+	MX6_PAD_CSI_PIXCLK__RAWNAND_CE3_B | MUX_PAD_CTRL(GPMI_PAD_CTRL2),
+	MX6_PAD_NAND_RE_B__RAWNAND_RE_B | MUX_PAD_CTRL(GPMI_PAD_CTRL2),
+	MX6_PAD_NAND_WE_B__RAWNAND_WE_B | MUX_PAD_CTRL(GPMI_PAD_CTRL2),
+	MX6_PAD_NAND_WP_B__RAWNAND_WP_B | MUX_PAD_CTRL(GPMI_PAD_CTRL2),
+	MX6_PAD_NAND_READY_B__RAWNAND_READY_B | MUX_PAD_CTRL(GPMI_PAD_CTRL2),
+	MX6_PAD_NAND_DQS__RAWNAND_DQS | MUX_PAD_CTRL(GPMI_PAD_CTRL2),
+};
+
+static void setup_gpmi_nand(void)
+{
+	struct mxc_ccm_reg *mxc_ccm = (struct mxc_ccm_reg *)CCM_BASE_ADDR;
+
+	/* config gpmi nand iomux */
+	imx_iomux_v3_setup_multiple_pads(nand_pads, ARRAY_SIZE(nand_pads));
+
+	clrbits_le32(&mxc_ccm->CCGR4,
+		     MXC_CCM_CCGR4_RAWNAND_U_BCH_INPUT_APB_MASK |
+		     MXC_CCM_CCGR4_RAWNAND_U_GPMI_BCH_INPUT_BCH_MASK |
+		     MXC_CCM_CCGR4_RAWNAND_U_GPMI_BCH_INPUT_GPMI_IO_MASK |
+		     MXC_CCM_CCGR4_RAWNAND_U_GPMI_INPUT_APB_MASK |
+		     MXC_CCM_CCGR4_PL301_MX6QPER1_BCH_MASK);
+
+	/*
+	 * config gpmi and bch clock to 100 MHz
+	 * bch/gpmi select PLL2 PFD2 400M
+	 * 100M = 400M / 4
+	 */
+	clrbits_le32(&mxc_ccm->cscmr1,
+		     MXC_CCM_CSCMR1_BCH_CLK_SEL |
+		     MXC_CCM_CSCMR1_GPMI_CLK_SEL);
+	clrsetbits_le32(&mxc_ccm->cscdr1,
+			MXC_CCM_CSCDR1_BCH_PODF_MASK |
+			MXC_CCM_CSCDR1_GPMI_PODF_MASK,
+			(3 << MXC_CCM_CSCDR1_BCH_PODF_OFFSET) |
+			(3 << MXC_CCM_CSCDR1_GPMI_PODF_OFFSET));
+
+	/* enable gpmi and bch clock gating */
+	setbits_le32(&mxc_ccm->CCGR4,
+		     MXC_CCM_CCGR4_RAWNAND_U_BCH_INPUT_APB_MASK |
+		     MXC_CCM_CCGR4_RAWNAND_U_GPMI_BCH_INPUT_BCH_MASK |
+		     MXC_CCM_CCGR4_RAWNAND_U_GPMI_BCH_INPUT_GPMI_IO_MASK |
+		     MXC_CCM_CCGR4_RAWNAND_U_GPMI_INPUT_APB_MASK |
+		     MXC_CCM_CCGR4_PL301_MX6QPER1_BCH_MASK);
+
+	/* enable apbh clock gating */
+	setbits_le32(&mxc_ccm->CCGR0, MXC_CCM_CCGR0_APBHDMA_MASK);
+}
+#endif
+
+#ifdef CONFIG_SYS_USE_SPINOR
+static iomux_v3_cfg_t const ecspi1_pads[] = {
+	MX6_PAD_CSI_DATA06__ECSPI1_MOSI | MUX_PAD_CTRL(SPI_PAD_CTRL),
+	MX6_PAD_CSI_DATA04__ECSPI1_SCLK | MUX_PAD_CTRL(SPI_PAD_CTRL),
+	MX6_PAD_CSI_DATA07__ECSPI1_MISO | MUX_PAD_CTRL(SPI_PAD_CTRL),
+
+	/* CS Pin */
+	MX6_PAD_CSI_DATA05__GPIO4_IO26 | MUX_PAD_CTRL(NO_PAD_CTRL),
+};
+
+static void setup_spinor(void)
+{
+	imx_iomux_v3_setup_multiple_pads(ecspi1_pads, ARRAY_SIZE(ecspi1_pads));
+	gpio_direction_output(IMX_GPIO_NR(4, 26), 0);
+}
+
+int board_spi_cs_gpio(unsigned bus, unsigned cs)
+{
+	return (bus == 0 && cs == 0) ? (IMX_GPIO_NR(4, 26)) : -1;
+}
+#endif
+
+#ifdef CONFIG_FEC_MXC
+/*
+ * pin conflicts for fec1 and fec2, GPIO1_IO06 and GPIO1_IO07 can only
+ * be used for ENET1 or ENET2, cannot be used for both.
+ */
+static iomux_v3_cfg_t const fec1_pads[] = {
+	MX6_PAD_GPIO1_IO06__ENET1_MDIO | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_GPIO1_IO07__ENET1_MDC | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_ENET1_TX_DATA0__ENET1_TDATA00 | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_ENET1_TX_DATA1__ENET1_TDATA01 | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_ENET1_TX_EN__ENET1_TX_EN | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_ENET1_TX_CLK__ENET1_REF_CLK1 | MUX_PAD_CTRL(ENET_CLK_PAD_CTRL),
+	/* Pin conflicts with LCD PWM1 */
+	MX6_PAD_ENET1_RX_DATA0__ENET1_RDATA00 | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_ENET1_RX_DATA1__ENET1_RDATA01 | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_ENET1_RX_ER__ENET1_RX_ER | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_ENET1_RX_EN__ENET1_RX_EN | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	/*
+	 * ALT5 mode is only valid when TAMPER pin is used for GPIO.
+	 * This depends on FUSE settings, TAMPER_PIN_DISABLE[1:0].
+	 *
+	 * ENET1_RST
+	 */
+	MX6_PAD_SNVS_TAMPER2__GPIO5_IO02 | MUX_PAD_CTRL(NO_PAD_CTRL),
+};
+
+static iomux_v3_cfg_t const fec2_pads[] = {
+	MX6_PAD_GPIO1_IO06__ENET2_MDIO | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_GPIO1_IO07__ENET2_MDC | MUX_PAD_CTRL(ENET_PAD_CTRL),
+
+	MX6_PAD_ENET2_RX_DATA0__ENET2_RDATA00 | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_ENET2_RX_DATA1__ENET2_RDATA01 | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_UART3_TX_DATA__ENET2_RDATA02 | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_UART3_RX_DATA__ENET2_RDATA03 | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_ENET2_RX_EN__ENET2_RX_EN | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_ENET2_RX_ER__ENET2_RX_ER | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_UART3_CTS_B__ENET2_RX_CLK | MUX_PAD_CTRL(ENET_PAD_CTRL),
+
+	MX6_PAD_ENET2_TX_DATA0__ENET2_TDATA00 | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_ENET2_TX_DATA1__ENET2_TDATA01 | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_UART4_TX_DATA__ENET2_TDATA02 | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_UART4_RX_DATA__ENET2_TDATA03 | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_ENET2_TX_CLK__ENET2_TX_CLK | MUX_PAD_CTRL(ENET_CLK_PAD_CTRL),
+	MX6_PAD_ENET2_TX_EN__ENET2_TX_EN | MUX_PAD_CTRL(ENET_PAD_CTRL),
+
+	MX6_PAD_UART5_RX_DATA__ENET2_COL | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_UART5_TX_DATA__ENET2_CRS | MUX_PAD_CTRL(ENET_PAD_CTRL),
+
+	/*
+	 * ENET2_RST
+	 *
+	 * This depends on FUSE settings, TAMPER_PIN_DISABLE[1:0]
+	 */
+	MX6_PAD_SNVS_TAMPER4__GPIO5_IO04 | MUX_PAD_CTRL(NO_PAD_CTRL),
+};
+
+static void setup_iomux_fec(int fec_id)
+{
+	if (fec_id == 0) {
+		imx_iomux_v3_setup_multiple_pads(fec1_pads,
+						 ARRAY_SIZE(fec1_pads));
+		gpio_direction_output(IMX_GPIO_NR(5, 2), 0);
+		udelay(50);
+		gpio_direction_output(IMX_GPIO_NR(5, 2), 1);
+	} else {
+		imx_iomux_v3_setup_multiple_pads(fec2_pads,
+						 ARRAY_SIZE(fec2_pads));
+		gpio_direction_output(IMX_GPIO_NR(5, 4), 0);
+		udelay(50);
+		gpio_direction_output(IMX_GPIO_NR(5, 4), 1);
+	}
+}
+#endif
+
+static void setup_iomux_uart(void)
+{
+	imx_iomux_v3_setup_multiple_pads(uart1_pads, ARRAY_SIZE(uart1_pads));
+}
+
+#ifdef CONFIG_FSL_QSPI
+
+#define QSPI_PAD_CTRL1	\
+	(PAD_CTL_SRE_FAST | PAD_CTL_SPEED_MED | \
+	 PAD_CTL_PKE | PAD_CTL_PUE | PAD_CTL_PUS_47K_UP | PAD_CTL_DSE_120ohm)
+
+static iomux_v3_cfg_t const quadspi_pads[] = {
+	MX6_PAD_NAND_WP_B__QSPI_A_SCLK	| MUX_PAD_CTRL(QSPI_PAD_CTRL1),
+	MX6_PAD_NAND_READY_B__QSPI_A_DATA00	| MUX_PAD_CTRL(QSPI_PAD_CTRL1),
+	MX6_PAD_NAND_CE0_B__QSPI_A_DATA01	| MUX_PAD_CTRL(QSPI_PAD_CTRL1),
+	MX6_PAD_NAND_CE1_B__QSPI_A_DATA02	| MUX_PAD_CTRL(QSPI_PAD_CTRL1),
+	MX6_PAD_NAND_CLE__QSPI_A_DATA03	| MUX_PAD_CTRL(QSPI_PAD_CTRL1),
+	MX6_PAD_NAND_DQS__QSPI_A_SS0_B	| MUX_PAD_CTRL(QSPI_PAD_CTRL1),
+	MX6_PAD_NAND_DATA07__QSPI_A_SS1_B	| MUX_PAD_CTRL(QSPI_PAD_CTRL1),
+
+	MX6_PAD_NAND_RE_B__QSPI_B_SCLK	| MUX_PAD_CTRL(QSPI_PAD_CTRL1),
+	MX6_PAD_NAND_WE_B__QSPI_B_SS0_B	| MUX_PAD_CTRL(QSPI_PAD_CTRL1),
+	MX6_PAD_NAND_DATA00__QSPI_B_SS1_B	| MUX_PAD_CTRL(QSPI_PAD_CTRL1),
+	MX6_PAD_NAND_DATA02__QSPI_B_DATA00	| MUX_PAD_CTRL(QSPI_PAD_CTRL1),
+	MX6_PAD_NAND_DATA03__QSPI_B_DATA01	| MUX_PAD_CTRL(QSPI_PAD_CTRL1),
+	MX6_PAD_NAND_DATA04__QSPI_B_DATA02	| MUX_PAD_CTRL(QSPI_PAD_CTRL1),
+	MX6_PAD_NAND_DATA05__QSPI_B_DATA03	| MUX_PAD_CTRL(QSPI_PAD_CTRL1),
+};
+
+int board_qspi_init(void)
+{
+	/* Set the iomux */
+	imx_iomux_v3_setup_multiple_pads(quadspi_pads,
+					 ARRAY_SIZE(quadspi_pads));
+
+	/* Set the clock */
+	enable_qspi_clk(0);
+
+	return 0;
+}
+#endif
+
+#ifdef CONFIG_FSL_ESDHC
+static struct fsl_esdhc_cfg usdhc_cfg[2] = {
+#if !defined(CONFIG_SYS_USE_NAND) && !defined(CONFIG_SYS_USE_QSPI1A)
+	/* If want to use qspi, should change to 4 bit width */
+	{USDHC1_BASE_ADDR, 0, 8},
+#else
+	{USDHC1_BASE_ADDR, 0, 4},
+#endif
+#if !defined(CONFIG_SYS_USE_NAND) && !defined(CONFIG_SYS_USE_QSPI1B)
+	{USDHC2_BASE_ADDR, 0, 4},
+#endif
+};
+
+#define USDHC1_CD_GPIO	IMX_GPIO_NR(1, 19)
+#define USDHC1_PWR_GPIO	IMX_GPIO_NR(1, 9)
+#define USDHC1_VSELECT IMX_GPIO_NR(1, 5)
+#define USDHC2_CD_GPIO	IMX_GPIO_NR(1, 19)
+#define USDHC2_PWR_GPIO	IMX_GPIO_NR(4, 10)
+
+int mmc_get_env_devno(void)
+{
+	u32 soc_sbmr = readl(SRC_BASE_ADDR + 0x4);
+	int dev_no;
+	u32 bootsel;
+
+	bootsel = (soc_sbmr & 0x000000FF) >> 6;
+
+	/* If not boot from sd/mmc, use default value */
+	if (bootsel != 1)
+		return CONFIG_SYS_MMC_ENV_DEV;
+
+	/* BOOT_CFG2[3] and BOOT_CFG2[4] */
+	dev_no = (soc_sbmr & 0x00001800) >> 11;
+
+	return dev_no;
+}
+
+int mmc_map_to_kernel_blk(int dev_no)
+{
+	return dev_no;
+}
+
+int board_mmc_getcd(struct mmc *mmc)
+{
+	struct fsl_esdhc_cfg *cfg = (struct fsl_esdhc_cfg *)mmc->priv;
+	int ret = 0;
+
+	switch (cfg->esdhc_base) {
+	case USDHC1_BASE_ADDR:
+#ifdef CONFIG_MX6ULL_DDR3_ARM2_EMMC_REWORK
+		ret = 1;
+#else
+		ret = !gpio_get_value(USDHC1_CD_GPIO);
+#endif
+		break;
+#if !defined(CONFIG_SYS_USE_NAND) && !defined(CONFIG_SYS_USE_QSPI1A)
+	case USDHC2_BASE_ADDR:
+		ret = !gpio_get_value(USDHC2_CD_GPIO);
+		break;
+#endif
+	}
+
+	return ret;
+}
+
+int board_mmc_init(bd_t *bis)
+{
+	int i;
+
+	/*
+	 * According to the board_mmc_init() the following map is done:
+	 * (U-boot device node)    (Physical Port)
+	 * mmc0                    USDHC1
+	 * mmc1                    USDHC2
+	 */
+	for (i = 0; i < CONFIG_SYS_FSL_USDHC_NUM; i++) {
+		switch (i) {
+		case 0:
+#ifdef CONFIG_MX6UL_DDR3_ARM2_EMMC_REWORK
+			imx_iomux_v3_setup_multiple_pads(
+				usdhc1_emmc_pads, ARRAY_SIZE(usdhc1_emmc_pads));
+#else
+			imx_iomux_v3_setup_multiple_pads(
+				usdhc1_pads, ARRAY_SIZE(usdhc1_pads));
+			gpio_direction_input(USDHC1_CD_GPIO);
+#endif
+			usdhc_cfg[0].sdhc_clk = mxc_get_clock(MXC_ESDHC_CLK);
+			/* 3.3V */
+			gpio_direction_output(USDHC1_VSELECT, 0);
+			gpio_direction_output(USDHC1_PWR_GPIO, 1);
+			break;
+#if !defined(CONFIG_SYS_USE_NAND) && !defined(CONFIG_SYS_USE_QSPI1A)
+		case 1:
+			imx_iomux_v3_setup_multiple_pads(
+				usdhc2_pads, ARRAY_SIZE(usdhc2_pads));
+			gpio_direction_input(USDHC2_CD_GPIO);
+			gpio_direction_output(USDHC2_PWR_GPIO, 1);
+			usdhc_cfg[1].sdhc_clk = mxc_get_clock(MXC_ESDHC2_CLK);
+			break;
+#endif
+		default:
+			printf("Warning: you configured more USDHC controllers (%d) than supported by the board\n", i + 1);
+			return 0;
+			}
+
+			if (fsl_esdhc_initialize(bis, &usdhc_cfg[i]))
+				printf("Warning: failed to initialize mmc dev %d\n", i);
+	}
+
+	return 0;
+}
+
+int check_mmc_autodetect(void)
+{
+	char *autodetect_str = getenv("mmcautodetect");
+
+	if ((autodetect_str != NULL) && (strcmp(autodetect_str, "yes") == 0))
+		return 1;
+
+	return 0;
+}
+
+void board_late_mmc_init(void)
+{
+	char cmd[32];
+	char mmcblk[32];
+	u32 dev_no = mmc_get_env_devno();
+
+	if (!check_mmc_autodetect())
+		return;
+
+	setenv_ulong("mmcdev", dev_no);
+
+	/* Set mmcblk env */
+	sprintf(mmcblk, "/dev/mmcblk%dp2 rootwait rw",
+		mmc_map_to_kernel_blk(dev_no));
+	setenv("mmcroot", mmcblk);
+
+	sprintf(cmd, "mmc dev %d", dev_no);
+	run_command(cmd, 0);
+}
+#endif
+
+#ifdef CONFIG_VIDEO_MXS
+static iomux_v3_cfg_t const lcd_pads[] = {
+	MX6_PAD_LCD_CLK__LCDIF_CLK | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_ENABLE__LCDIF_ENABLE | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_HSYNC__LCDIF_HSYNC | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_VSYNC__LCDIF_VSYNC | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_DATA00__LCDIF_DATA00 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_DATA01__LCDIF_DATA01 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_DATA02__LCDIF_DATA02 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_DATA03__LCDIF_DATA03 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_DATA04__LCDIF_DATA04 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_DATA05__LCDIF_DATA05 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_DATA06__LCDIF_DATA06 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_DATA07__LCDIF_DATA07 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_DATA08__LCDIF_DATA08 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_DATA09__LCDIF_DATA09 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_DATA10__LCDIF_DATA10 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_DATA11__LCDIF_DATA11 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_DATA12__LCDIF_DATA12 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_DATA13__LCDIF_DATA13 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_DATA14__LCDIF_DATA14 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_DATA15__LCDIF_DATA15 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_DATA16__LCDIF_DATA16 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_DATA17__LCDIF_DATA17 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_DATA18__LCDIF_DATA18 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_DATA19__LCDIF_DATA19 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_DATA20__LCDIF_DATA20 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_DATA21__LCDIF_DATA21 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_DATA22__LCDIF_DATA22 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_DATA23__LCDIF_DATA23 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_RESET__GPIO3_IO04 | MUX_PAD_CTRL(NO_PAD_CTRL),
+
+	/*
+	 * PWM1, pin conflicts with ENET1_RX_DATA0
+	 * Use GPIO for Brightness adjustment, duty cycle = period.
+	 */
+	/* MX6_PAD_ENET1_RX_DATA0__GPIO2_IO00 | MUX_PAD_CTRL(NO_PAD_CTRL),*/
+};
+
+struct lcd_panel_info_t {
+	unsigned int lcdif_base_addr;
+	int depth;
+	void (*enable)(struct lcd_panel_info_t const *dev);
+	struct fb_videomode mode;
+};
+
+void do_enable_parallel_lcd(struct lcd_panel_info_t const *dev)
+{
+	enable_lcdif_clock(dev->lcdif_base_addr);
+
+	imx_iomux_v3_setup_multiple_pads(lcd_pads, ARRAY_SIZE(lcd_pads));
+
+	/* Power up the LCD */
+	gpio_direction_output(IMX_GPIO_NR(3, 4) , 1);
+
+	/* Set Brightness to high */
+	/* gpio_direction_output(IMX_GPIO_NR(2, 0) , 1); */
+}
+
+static struct lcd_panel_info_t const displays[] = {{
+	.lcdif_base_addr = LCDIF1_BASE_ADDR,
+	.depth = 24,
+	.enable	= do_enable_parallel_lcd,
+	.mode	= {
+		.name		= "MCIMX28LCD",
+		.xres           = 800,
+		.yres           = 480,
+		.pixclock       = 29850,
+		.left_margin    = 89,
+		.right_margin   = 164,
+		.upper_margin   = 23,
+		.lower_margin   = 10,
+		.hsync_len      = 10,
+		.vsync_len      = 10,
+		.sync           = 0,
+		.vmode          = FB_VMODE_NONINTERLACED
+} } };
+
+int board_video_skip(void)
+{
+	int i;
+	int ret;
+	char const *panel = getenv("panel");
+	if (!panel) {
+		panel = displays[0].mode.name;
+		printf("No panel detected: default to %s\n", panel);
+		i = 0;
+	} else {
+		for (i = 0; i < ARRAY_SIZE(displays); i++) {
+			if (!strcmp(panel, displays[i].mode.name))
+				break;
+		}
+	}
+	if (i < ARRAY_SIZE(displays)) {
+		ret = mxs_lcd_panel_setup(displays[i].mode, displays[i].depth,
+				    displays[i].lcdif_base_addr);
+		if (!ret) {
+			if (displays[i].enable)
+				displays[i].enable(displays+i);
+			printf("Display: %s (%ux%u)\n",
+			       displays[i].mode.name,
+			       displays[i].mode.xres,
+			       displays[i].mode.yres);
+		} else
+			printf("LCD %s cannot be configured: %d\n",
+			       displays[i].mode.name, ret);
+	} else {
+		printf("unsupported panel %s\n", panel);
+		return -EINVAL;
+	}
+
+	return 0;
+}
+#endif
+
+#ifdef CONFIG_FEC_MXC
+int board_eth_init(bd_t *bis)
+{
+	int ret;
+
+	setup_iomux_fec(CONFIG_FEC_ENET_DEV);
+
+	ret = fecmxc_initialize_multi(bis, CONFIG_FEC_ENET_DEV,
+		CONFIG_FEC_MXC_PHYADDR, IMX_FEC_BASE);
+	if (ret)
+		printf("FEC%d MXC: %s:failed\n", CONFIG_FEC_ENET_DEV, __func__);
+
+	return 0;
+}
+
+static int setup_fec(int fec_id)
+{
+	struct iomuxc_gpr_base_regs *const iomuxc_gpr_regs
+		= (struct iomuxc_gpr_base_regs *)IOMUXC_GPR_BASE_ADDR;
+	int ret;
+
+	if (0 == fec_id) {
+		/*
+		 * Use 50M anatop loopback REF_CLK1 for ENET1,
+		 * clear gpr1[13], set gpr1[17]
+		 */
+		clrsetbits_le32(&iomuxc_gpr_regs->gpr[1], IOMUX_GPR1_FEC1_MASK,
+				IOMUX_GPR1_FEC1_CLOCK_MUX1_SEL_MASK);
+		ret = enable_fec_anatop_clock(fec_id, ENET_50MHZ);
+		if (ret)
+			return ret;
+
+	} else {
+		/* clk from phy, set gpr1[14], clear gpr1[18]*/
+		clrsetbits_le32(&iomuxc_gpr_regs->gpr[1], IOMUX_GPR1_FEC2_MASK,
+				IOMUX_GPR1_FEC2_CLOCK_MUX2_SEL_MASK);
+	}
+
+	enable_enet_clk(1);
+
+	return 0;
+}
+
+int board_phy_config(struct phy_device *phydev)
+{
+	if (CONFIG_FEC_ENET_DEV == 0) {
+		phy_write(phydev, MDIO_DEVAD_NONE, 0x16, 0x202);
+		phy_write(phydev, MDIO_DEVAD_NONE, 0x1f, 0x8190);
+	} else if (CONFIG_FEC_ENET_DEV == 1) {
+		phy_write(phydev, MDIO_DEVAD_NONE, 0x16, 0x201);
+		phy_write(phydev, MDIO_DEVAD_NONE, 0x1f, 0x8110);
+	}
+
+	if (phydev->drv->config)
+		phydev->drv->config(phydev);
+
+	return 0;
+}
+#endif
+
+#ifdef CONFIG_POWER
+#define I2C_PMIC	0
+static struct pmic *pfuze;
+int power_init_board(void)
+{
+	int ret;
+	u32 rev_id, value;
+
+	ret = power_pfuze100_init(I2C_PMIC);
+	if (ret)
+		return ret;
+
+	pfuze = pmic_get("PFUZE100");
+	if (!pfuze)
+		return -ENODEV;
+
+	ret = pmic_probe(pfuze);
+	if (ret)
+		return ret;
+
+	ret = pfuze_mode_init(pfuze, APS_PFM);
+	if (ret < 0)
+		return ret;
+
+	pmic_reg_read(pfuze, PFUZE100_DEVICEID, &value);
+	pmic_reg_read(pfuze, PFUZE100_REVID, &rev_id);
+	printf("PMIC: PFUZE200! DEV_ID=0x%x REV_ID=0x%x\n", value, rev_id);
+
+	/*
+	 * Our PFUZE0200 is PMPF0200X0AEP, the Pre-programmed OTP
+	 * Configuration is F0.
+	 * Default VOLT:
+	 * VSNVS_VOLT	|	3.0V
+	 * SW1AB	|	1.375V
+	 * SW2		|	3.3V
+	 * SW3A		|	1.5V
+	 * SW3B		|	1.5V
+	 * VGEN1	|	1.5V
+	 * VGEN2	|	1.5V
+	 * VGEN3	|	2.5V
+	 * VGEN4	|	1.8V
+	 * VGEN5	|	2.8V
+	 * VGEN6	|	3.3V
+	 *
+	 * According to schematic, we need SW3A 1.35V, SW3B 3.3V,
+	 * VGEN1 1.2V, VGEN2 1.5V, VGEN3 2.8V, VGEN4 1.8V,
+	 * VGEN5 3.3V, VGEN6 3.0V.
+	 *
+	 * Here we just use the default VOLT, but not configure
+	 * them, when needed, configure them to our requested voltage.
+	 */
+
+	/* set SW1AB standby volatage 0.975V */
+	pmic_reg_read(pfuze, PFUZE100_SW1ABSTBY, &value);
+	value &= ~0x3f;
+	value |= PFUZE100_SW1ABC_SETP(9750);
+	pmic_reg_write(pfuze, PFUZE100_SW1ABSTBY, value);
+
+	/* set SW1AB/VDDARM step ramp up time from 16us to 4us/25mV */
+	pmic_reg_read(pfuze, PFUZE100_SW1ABCONF, &value);
+	value &= ~0xc0;
+	value |= 0x40;
+	pmic_reg_write(pfuze, PFUZE100_SW1ABCONF, value);
+
+	/* Enable power of VGEN5 3V3 */
+	pmic_reg_read(pfuze, PFUZE100_VGEN5VOL, &value);
+	value &= ~0x1F;
+	value |= 0x1F;
+	pmic_reg_write(pfuze, PFUZE100_VGEN5VOL, value);
+
+	return 0;
+}
+
+#ifdef CONFIG_LDO_BYPASS_CHECK
+void ldo_mode_set(int ldo_bypass)
+{
+	unsigned int value;
+	int is_400M;
+	u32 vddarm;
+
+	struct pmic *p = pfuze;
+
+	if (!p) {
+		printf("No PMIC found!\n");
+		return;
+	}
+
+	/* switch to ldo_bypass mode */
+	if (ldo_bypass) {
+		prep_anatop_bypass();
+		/* decrease VDDARM to 1.275V */
+		pmic_reg_read(pfuze, PFUZE100_SW1ABVOL, &value);
+		value &= ~0x3f;
+		value |= PFUZE100_SW1ABC_SETP(12750);
+		pmic_reg_write(pfuze, PFUZE100_SW1ABVOL, value);
+
+		is_400M = set_anatop_bypass(1);
+		if (is_400M)
+			vddarm = PFUZE100_SW1ABC_SETP(10750);
+		else
+			vddarm = PFUZE100_SW1ABC_SETP(11750);
+
+		pmic_reg_read(pfuze, PFUZE100_SW1ABVOL, &value);
+		value &= ~0x3f;
+		value |= vddarm;
+		pmic_reg_write(pfuze, PFUZE100_SW1ABVOL, value);
+
+		finish_anatop_bypass();
+
+		printf("switch to ldo_bypass mode!\n");
+	}
+}
+#endif
+#endif
+
+int board_early_init_f(void)
+{
+	setup_iomux_uart();
+
+	return 0;
+}
+
+int board_init(void)
+{
+	/* Address of boot parameters */
+	gd->bd->bi_boot_params = PHYS_SDRAM + 0x100;
+
+#ifdef CONFIG_SYS_I2C_MXC
+	setup_i2c(0, CONFIG_SYS_I2C_SPEED, 0x7f, &i2c_pad_info1);
+#endif
+
+#ifdef CONFIG_FEC_MXC
+	setup_fec(CONFIG_FEC_ENET_DEV);
+#endif
+
+#ifdef CONFIG_SYS_USE_SPINOR
+	setup_spinor();
+#endif
+
+#ifdef CONFIG_SYS_USE_NAND
+	setup_gpmi_nand();
+#endif
+
+#ifdef CONFIG_SYS_USE_QSPI
+	board_qspi_init();
+#endif
+
+	return 0;
+}
+
+#ifdef CONFIG_CMD_BMODE
+static const struct boot_mode board_boot_modes[] = {
+	/* 4 bit bus width */
+	{"sd1", MAKE_CFGVAL(0x42, 0x20, 0x00, 0x00)},
+	{"qspi1", MAKE_CFGVAL(0x10, 0x00, 0x00, 0x00)},
+	{NULL,	 0},
+};
+#endif
+
+int board_late_init(void)
+{
+#ifdef CONFIG_CMD_BMODE
+	add_board_boot_modes(board_boot_modes);
+#endif
+
+#ifdef CONFIG_ENV_IS_IN_MMC
+	board_late_mmc_init();
+#endif
+
+	return 0;
+}
+
+u32 get_board_rev(void)
+{
+	return get_cpu_rev();
+}
+
+int checkboard(void)
+{
+	puts("Board: MX6ULL 14X14 DDR3 ARM2\n");
+
+	return 0;
+}
+
+#ifdef CONFIG_USB_EHCI_MX6
+#define USB_OTHERREGS_OFFSET	0x800
+#define UCTRL_PWR_POL		(1 << 9)
+iomux_v3_cfg_t const usb_otg1_pads[] = {
+	MX6_PAD_GPIO1_IO04__USB_OTG1_PWR | MUX_PAD_CTRL(NO_PAD_CTRL),
+	MX6_PAD_GPIO1_IO00__ANATOP_OTG1_ID | MUX_PAD_CTRL(OTG_ID_PAD_CTRL),
+};
+
+/*
+ * Leave it here, but default configuration only supports 1 port now,
+ * because we need sd1 and i2c1
+ */
+iomux_v3_cfg_t const usb_otg2_pads[] = {
+	/* conflict with i2c1_scl */
+	MX6_PAD_GPIO1_IO02__USB_OTG2_PWR | MUX_PAD_CTRL(NO_PAD_CTRL),
+	/* conflict with sd1_vselect */
+	MX6_PAD_GPIO1_IO05__ANATOP_OTG2_ID | MUX_PAD_CTRL(OTG_ID_PAD_CTRL),
+};
+
+int board_usb_phy_mode(int port)
+{
+	return usb_phy_mode(port);
+}
+
+int board_ehci_hcd_init(int port)
+{
+	u32 *usbnc_usb_ctrl;
+
+	if (port > 1)
+		return -EINVAL;
+
+	switch (port) {
+	case 0:
+		imx_iomux_v3_setup_multiple_pads(usb_otg1_pads,
+						 ARRAY_SIZE(usb_otg1_pads));
+		break;
+	case 1:
+		imx_iomux_v3_setup_multiple_pads(usb_otg2_pads,
+						 ARRAY_SIZE(usb_otg2_pads));
+		break;
+	default:
+		printf("MXC USB port %d not yet supported\n", port);
+		return 1;
+	}
+
+	usbnc_usb_ctrl = (u32 *)(USB_BASE_ADDR + USB_OTHERREGS_OFFSET +
+				 port * 4);
+
+	/* Set Power polarity */
+	setbits_le32(usbnc_usb_ctrl, UCTRL_PWR_POL);
+
+	return 0;
+}
+#endif
diff --git a/board/freescale/mx6ull_ddr3_arm2/plugin.S b/board/freescale/mx6ull_ddr3_arm2/plugin.S
new file mode 100644
index 0000000..9cf484c
--- /dev/null
+++ b/board/freescale/mx6ull_ddr3_arm2/plugin.S
@@ -0,0 +1,136 @@
+/*
+ * Copyright (C) 2016 Freescale Semiconductor, Inc.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <config.h>
+
+/* DDR script */
+.macro imx6ull_ddr3_arm2_setting
+	ldr r0, =IOMUXC_BASE_ADDR
+	ldr r1, =0x000C0000
+	str r1, [r0, #0x4B4]
+	ldr r1, =0x00000000
+	str r1, [r0, #0x4AC]
+	ldr r1, =0x00000030
+	str r1, [r0, #0x27C]
+	str r1, [r0, #0x250]
+	str r1, [r0, #0x24C]
+	str r1, [r0, #0x490]
+	str r1, [r0, #0x288]
+
+	ldr r1, =0x00000000
+	str r1, [r0, #0x270]
+
+	ldr r1, =0x00000030
+	str r1, [r0, #0x260]
+	str r1, [r0, #0x264]
+	str r1, [r0, #0x4A0]
+
+	ldr r1, =0x00020000
+	str r1, [r0, #0x494]
+
+	ldr r1, =0x00000030
+	str r1, [r0, #0x280]
+	str r1, [r0, #0x284]
+
+	ldr r1, =0x00020000
+	str r1, [r0, #0x4B0]
+
+	ldr r1, =0x00000030
+	str r1, [r0, #0x498]
+	str r1, [r0, #0x4A4]
+	str r1, [r0, #0x244]
+	str r1, [r0, #0x248]
+
+	ldr r0, =MMDC_P0_BASE_ADDR
+	ldr r1, =0x00008000
+	str r1, [r0, #0x1C]
+	ldr r1, =0xA1390003
+	str r1, [r0, #0x800]
+	ldr r1, =0x00150019
+	str r1, [r0, #0x80C]
+	ldr r1, =0x41550153
+	str r1, [r0, #0x83C]
+	ldr r1, =0x40403A3E
+	str r1, [r0, #0x848]
+	ldr r1, =0x40402F2A
+	str r1, [r0, #0x850]
+	ldr r1, =0x33333333
+	str r1, [r0, #0x81C]
+	str r1, [r0, #0x820]
+	ldr r1, =0xF3333333
+	str r1, [r0, #0x82C]
+	str r1, [r0, #0x830]
+	ldr r1, =0x00922012
+	str r1, [r0, #0x8C0]
+	ldr r1, =0x00000800
+	str r1, [r0, #0x8B8]
+	ldr r1, =0x0002002D
+	str r1, [r0, #0x004]
+	ldr r1, =0x1B333030
+	str r1, [r0, #0x008]
+	ldr r1, =0x676B52F3
+	str r1, [r0, #0x00C]
+	ldr r1, =0xB66D0B63
+	str r1, [r0, #0x010]
+	ldr r1, =0x01FF00DB
+	str r1, [r0, #0x014]
+	ldr r1, =0x00201740
+	str r1, [r0, #0x018]
+	ldr r1, =0x00008000
+	str r1, [r0, #0x01C]
+	ldr r1, =0x000026D2
+	str r1, [r0, #0x02C]
+	ldr r1, =0x006B1023
+	str r1, [r0, #0x030]
+	ldr r1, =0x0000005F
+	str r1, [r0, #0x040]
+	ldr r1, =0x85180000
+	str r1, [r0, #0x000]
+	ldr r1, =0x00400A38
+	str r1, [r0, #0x890]
+	ldr r1, =0x02008032
+	str r1, [r0, #0x01C]
+	ldr r1, =0x00008033
+	str r1, [r0, #0x01C]
+	ldr r1, =0x00048031
+	str r1, [r0, #0x01C]
+	ldr r1, =0x15208030
+	str r1, [r0, #0x01C]
+	ldr r1, =0x04008040
+	str r1, [r0, #0x01C]
+	ldr r1, =0x00000800
+	str r1, [r0, #0x020]
+	ldr r1, =0x00000227
+	str r1, [r0, #0x818]
+	ldr r1, =0x0002552D
+	str r1, [r0, #0x004]
+	ldr r1, =0x00011006
+	str r1, [r0, #0x404]
+	ldr r1, =0x00000000
+	str r1, [r0, #0x01C]
+.endm
+
+.macro imx6_clock_gating
+	ldr r0, =CCM_BASE_ADDR
+	ldr r1, =0xFFFFFFFF
+	str r1, [r0, #0x68]
+	str r1, [r0, #0x6C]
+	str r1, [r0, #0x70]
+	str r1, [r0, #0x74]
+	str r1, [r0, #0x78]
+	str r1, [r0, #0x7C]
+	str r1, [r0, #0x80]
+.endm
+
+.macro imx6_qos_setting
+.endm
+
+.macro imx6_ddr_setting
+	imx6ull_ddr3_arm2_setting
+.endm
+
+/* include the common plugin code here */
+#include <asm/arch/mx6_plugin.S>
diff --git a/common/cmd_read.c b/common/cmd_read.c
index f0fc9bf..e1d14a3 100644
--- a/common/cmd_read.c
+++ b/common/cmd_read.c
@@ -12,7 +12,7 @@
 #include <command.h>
 #include <part.h>
 
-int do_read(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
+int do_raw_read(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
 {
 	char *ep;
 	block_dev_desc_t *dev_desc = NULL;
@@ -75,7 +75,7 @@ int do_read(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
 }
 
 U_BOOT_CMD(
-	read,	6,	0,	do_read,
+	read,	6,	0,	do_raw_read,
 	"Load binary data from a partition",
 	"<interface> <dev[:part]> addr blk# cnt"
 );
diff --git a/common/image-android.c b/common/image-android.c
index 429bf1c..6e38519 100644
--- a/common/image-android.c
+++ b/common/image-android.c
@@ -1,6 +1,8 @@
 /*
  * Copyright (c) 2011 Sebastian Andrzej Siewior <bigeasy@linutronix.de>
  *
+ * Copyright (C) 2016 Freescale Semiconductor, Inc.
+ *
  * SPDX-License-Identifier:	GPL-2.0+
  */
 
@@ -13,6 +15,11 @@
 
 static char andr_tmp_str[ANDR_BOOT_ARGS_SIZE + 1];
 
+#ifdef CONFIG_BRILLO_SUPPORT
+#include <linux/usb/ch9.h>
+#include <linux/usb/gadget.h>
+#include "../drivers/usb/gadget/bootctrl.h"
+#endif
 /**
  * android_image_get_kernel() - processes kernel part of Android boot images
  * @hdr:	Pointer to image header, which is at the start
@@ -78,6 +85,12 @@ int android_image_get_kernel(const struct andr_img_hdr *hdr, int verify,
 					serialnr.high,
 					serialnr.low);
 #endif
+
+#ifdef CONFIG_BRILLO_SUPPORT
+	char suffixStr[64];
+	sprintf(suffixStr, " androidboot.slot_suffix=%s", get_slot_suffix());
+	strcat(commandline, suffixStr);
+#endif
 	setenv("bootargs", commandline);
 	if (os_data) {
 		*os_data = (ulong)hdr;
diff --git a/common/usb_storage.c b/common/usb_storage.c
index ad08dea..1411737 100644
--- a/common/usb_storage.c
+++ b/common/usb_storage.c
@@ -16,8 +16,6 @@
  * BBB support based on /sys/dev/usb/umass.c from
  * FreeBSD.
  *
- * Copyright (C) 2016 Freescale Semiconductor, Inc.
- *
  * SPDX-License-Identifier:	GPL-2.0+
  */
 
@@ -140,7 +138,7 @@ struct us_data {
  * enough free heap space left, but the SCSI READ(10) and WRITE(10) commands are
  * limited to 65535 blocks.
  */
-#define USB_MAX_XFER_BLK	256
+#define USB_MAX_XFER_BLK	65535
 #else
 #define USB_MAX_XFER_BLK	20
 #endif
diff --git a/configs/mx6qarm2_pop_lpddr2_revb_defconfig b/configs/mx6qarm2_pop_lpddr2_revb_defconfig
index 0f6e0c4..b50a9d2 100644
--- a/configs/mx6qarm2_pop_lpddr2_revb_defconfig
+++ b/configs/mx6qarm2_pop_lpddr2_revb_defconfig
@@ -1,4 +1,4 @@
-CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=board/freescale/mx6qarm2/mt128x64mx32.cfg,MX6Q,MX6DQ_POP_LPDDR2,DDR_MB=1024"
+CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=board/freescale/mx6qarm2/mt128x64mx32.cfg,MX6Q,MX6DQ_POP_LPDDR2,DDR_MB=512"
 CONFIG_ARM=y
 CONFIG_TARGET_MX6QARM2=y
 CONFIG_SYS_MALLOC_F=y
diff --git a/configs/mx6ul_14x14_evk_brillo_defconfig b/configs/mx6ul_14x14_evk_brillo_defconfig
new file mode 100644
index 0000000..6b88ee4
--- /dev/null
+++ b/configs/mx6ul_14x14_evk_brillo_defconfig
@@ -0,0 +1,5 @@
+CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=board/freescale/mx6ul_14x14_evk/imximage.cfg,MX6UL,ANDROID_SUPPORT,BRILLO_SUPPORT"
+CONFIG_ARM=y
+CONFIG_TARGET_MX6UL_14X14_EVK=y
+CONFIG_DM=y
+CONFIG_DM_THERMAL=y
diff --git a/configs/mx6ull_ddr3_arm2_defconfig b/configs/mx6ull_ddr3_arm2_defconfig
new file mode 100644
index 0000000..906b9b0
--- /dev/null
+++ b/configs/mx6ull_ddr3_arm2_defconfig
@@ -0,0 +1,9 @@
+CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=board/freescale/mx6ull_ddr3_arm2/imximage.cfg"
+CONFIG_ARM=y
+CONFIG_ARCH_MX6=y
+CONFIG_MX6ULL=y
+CONFIG_TARGET_MX6ULL_DDR3_ARM2=y
+CONFIG_SYS_MALLOC_F=y
+CONFIG_SYS_MALLOC_F_LEN=0x400
+CONFIG_DM=y
+CONFIG_DM_THERMAL=y
diff --git a/drivers/misc/mxc_ocotp.c b/drivers/misc/mxc_ocotp.c
index bdbe0bd..c7cbf97 100644
--- a/drivers/misc/mxc_ocotp.c
+++ b/drivers/misc/mxc_ocotp.c
@@ -7,7 +7,7 @@
  * which is based on Freescale's
  * http://git.freescale.com/git/cgit.cgi/imx/uboot-imx.git/tree/drivers/misc/imx_otp.c?h=imx_v2009.08_1.1.0&id=9aa74e6,
  * which is:
- * Copyright (C) 2011-2015 Freescale Semiconductor, Inc.
+ * Copyright (C) 2011-2016 Freescale Semiconductor, Inc.
  *
  * SPDX-License-Identifier:	GPL-2.0+
  */
@@ -61,6 +61,8 @@
 #define FUSE_BANK_SIZE	0x80
 #ifdef CONFIG_MX6SL
 #define FUSE_BANKS	8
+#elif defined CONFIG_MX6ULL
+#define FUSE_BANKS	9
 #else
 #define FUSE_BANKS	16
 #endif
@@ -76,7 +78,7 @@
 
 /*
  * There is a hole in shadow registers address map of size 0x100
- * between bank 5 and bank 6 on iMX6QP, iMX6DQ, iMX6SDL, iMX6SX and iMX6UL.
+ * between bank 5 and bank 6 on iMX6QP, iMX6DQ, iMX6SDL, iMX6SX, iMX6UL and iMX6ULL.
  * Bank 5 ends at 0x6F0 and Bank 6 starts at 0x800. When reading the fuses,
  * we should account for this hole in address space.
  *
@@ -98,7 +100,10 @@ u32 fuse_bank_physical(int index)
 	if ((index == 0) || is_cpu_type(MXC_CPU_MX6SL) ||
 	    is_cpu_type(MXC_CPU_MX7D))
 		phy_index = index;
-	else if (is_cpu_type(MXC_CPU_MX6UL)) {
+	else if (is_cpu_type(MXC_CPU_MX6UL) || is_cpu_type(MXC_CPU_MX6ULL)) {
+		if (is_cpu_type(MXC_CPU_MX6ULL) && index == 8)
+			index = 7;
+
 		if (index >= 6)
 			phy_index = fuse_bank_physical(5) + (index - 6) + 3;
 		else
@@ -113,11 +118,27 @@ u32 fuse_bank_physical(int index)
 	}
 	return phy_index;
 }
+
+u32 fuse_word_physical(u32 bank, u32 word_index)
+{
+	if (is_cpu_type(MXC_CPU_MX6ULL)) {
+		if (bank == 8)
+			word_index = word_index + 4;
+	}
+
+	return word_index;
+}
 #else
 u32 fuse_bank_physical(int index)
 {
 	return index;
 }
+
+u32 fuse_word_physical(u32 bank, u32 word_index)
+{
+	return word_index;
+}
+
 #endif
 
 static void wait_busy(struct ocotp_regs *regs, unsigned int delay_us)
@@ -143,6 +164,14 @@ static int prepare_access(struct ocotp_regs **regs, u32 bank, u32 word,
 		return -EINVAL;
 	}
 
+	if (is_cpu_type(MXC_CPU_MX6ULL)) {
+		if ((bank == 7 || bank == 8) &&
+		    word >= ARRAY_SIZE((*regs)->bank[0].fuse_regs) >> 3) {
+			printf("mxc_ocotp %s(): Invalid argument on 6ULL\n", caller);
+			return -EINVAL;
+		}
+	}
+
 	enable_ocotp_clk(1);
 
 	wait_busy(*regs, 1);
@@ -177,14 +206,16 @@ int fuse_read(u32 bank, u32 word, u32 *val)
 	struct ocotp_regs *regs;
 	int ret;
 	u32 phy_bank;
+	u32 phy_word;
 
 	ret = prepare_read(&regs, bank, word, val, __func__);
 	if (ret)
 		return ret;
 
 	phy_bank = fuse_bank_physical(bank);
+	phy_word = fuse_word_physical(bank, word);
 
-	*val = readl(&regs->bank[phy_bank].fuse_regs[word << 2]);
+	*val = readl(&regs->bank[phy_bank].fuse_regs[phy_word << 2]);
 
 	return finish_access(regs, __func__);
 }
@@ -326,14 +357,16 @@ int fuse_override(u32 bank, u32 word, u32 val)
 	struct ocotp_regs *regs;
 	int ret;
 	u32 phy_bank;
+	u32 phy_word;
 
 	ret = prepare_write(&regs, bank, word, __func__);
 	if (ret)
 		return ret;
 
 	phy_bank = fuse_bank_physical(bank);
+	phy_word = fuse_word_physical(bank, word);
 
-	writel(val, &regs->bank[phy_bank].fuse_regs[word << 2]);
+	writel(val, &regs->bank[phy_bank].fuse_regs[phy_word << 2]);
 
 	return finish_access(regs, __func__);
 }
diff --git a/drivers/misc/mxc_ocotp.c.orig b/drivers/misc/mxc_ocotp.c.orig
new file mode 100644
index 0000000..bdbe0bd
--- /dev/null
+++ b/drivers/misc/mxc_ocotp.c.orig
@@ -0,0 +1,339 @@
+/*
+ * (C) Copyright 2013 ADVANSEE
+ * Benoît Thébaudeau <benoit.thebaudeau@advansee.com>
+ *
+ * Based on Dirk Behme's
+ * https://github.com/dirkbehme/u-boot-imx6/blob/28b17e9/drivers/misc/imx_otp.c,
+ * which is based on Freescale's
+ * http://git.freescale.com/git/cgit.cgi/imx/uboot-imx.git/tree/drivers/misc/imx_otp.c?h=imx_v2009.08_1.1.0&id=9aa74e6,
+ * which is:
+ * Copyright (C) 2011-2015 Freescale Semiconductor, Inc.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <common.h>
+#include <fuse.h>
+#include <asm/errno.h>
+#include <asm/io.h>
+#include <asm/arch/clock.h>
+#include <asm/arch/imx-regs.h>
+
+#define BO_CTRL_WR_UNLOCK		16
+#define BM_CTRL_WR_UNLOCK		0xffff0000
+#define BV_CTRL_WR_UNLOCK_KEY		0x3e77
+#define BM_CTRL_ERROR			0x00000200
+#define BM_CTRL_BUSY			0x00000100
+#define BO_CTRL_ADDR			0
+#ifdef CONFIG_MX7
+#define BM_CTRL_ADDR			0x0000000f
+#define BM_CTRL_RELOAD			0x00000400
+#else
+#define BM_CTRL_ADDR			0x0000007f
+#endif
+
+#ifdef CONFIG_MX7
+#define BO_TIMING_FSOURCE		12
+#define BM_TIMING_FSOURCE		0x0007f000
+#define BV_TIMING_FSOURCE_NS		1001
+#define BO_TIMING_PROG			0
+#define BM_TIMING_PROG			0x00000fff
+#define BV_TIMING_PROG_US		10
+#else
+#define BO_TIMING_STROBE_READ		16
+#define BM_TIMING_STROBE_READ		0x003f0000
+#define BV_TIMING_STROBE_READ_NS	37
+#define BO_TIMING_RELAX			12
+#define BM_TIMING_RELAX			0x0000f000
+#define BV_TIMING_RELAX_NS		17
+#define BO_TIMING_STROBE_PROG		0
+#define BM_TIMING_STROBE_PROG		0x00000fff
+#define BV_TIMING_STROBE_PROG_US	10
+#endif
+
+#define BM_READ_CTRL_READ_FUSE		0x00000001
+
+#define BF(value, field)		(((value) << BO_##field) & BM_##field)
+
+#define WRITE_POSTAMBLE_US		2
+
+#if defined(CONFIG_MX6) || defined(CONFIG_VF610)
+#define FUSE_BANK_SIZE	0x80
+#ifdef CONFIG_MX6SL
+#define FUSE_BANKS	8
+#else
+#define FUSE_BANKS	16
+#endif
+#elif defined CONFIG_MX7
+#define FUSE_BANK_SIZE	0x40
+#define FUSE_BANKS	16
+#else
+#error "Unsupported architecture\n"
+#endif
+
+#if defined(CONFIG_MX6) || defined(CONFIG_MX7)
+#include <asm/arch/sys_proto.h>
+
+/*
+ * There is a hole in shadow registers address map of size 0x100
+ * between bank 5 and bank 6 on iMX6QP, iMX6DQ, iMX6SDL, iMX6SX and iMX6UL.
+ * Bank 5 ends at 0x6F0 and Bank 6 starts at 0x800. When reading the fuses,
+ * we should account for this hole in address space.
+ *
+ * Similar hole exists between bank 14 and bank 15 of size
+ * 0x80 on iMX6QP, iMX6DQ, iMX6SDL and iMX6SX.
+ * Note: iMX6SL has only 0-7 banks and there is no hole.
+ * Note: iMX6UL doesn't have this one.
+ *
+ * This function is to covert user input to physical bank index.
+ * Only needed when read fuse, because we use register offset, so
+ * need to calculate real register offset.
+ * When write, no need to consider hole, always use the bank/word
+ * index from fuse map.
+ */
+u32 fuse_bank_physical(int index)
+{
+	u32 phy_index;
+
+	if ((index == 0) || is_cpu_type(MXC_CPU_MX6SL) ||
+	    is_cpu_type(MXC_CPU_MX7D))
+		phy_index = index;
+	else if (is_cpu_type(MXC_CPU_MX6UL)) {
+		if (index >= 6)
+			phy_index = fuse_bank_physical(5) + (index - 6) + 3;
+		else
+			phy_index = index;
+	} else {
+		if (index >= 15)
+			phy_index = fuse_bank_physical(14) + (index - 15) + 2;
+		else if (index >= 6)
+			phy_index = fuse_bank_physical(5) + (index - 6) + 3;
+		else
+			phy_index = index;
+	}
+	return phy_index;
+}
+#else
+u32 fuse_bank_physical(int index)
+{
+	return index;
+}
+#endif
+
+static void wait_busy(struct ocotp_regs *regs, unsigned int delay_us)
+{
+	while (readl(&regs->ctrl) & BM_CTRL_BUSY)
+		udelay(delay_us);
+}
+
+static void clear_error(struct ocotp_regs *regs)
+{
+	writel(BM_CTRL_ERROR, &regs->ctrl_clr);
+}
+
+static int prepare_access(struct ocotp_regs **regs, u32 bank, u32 word,
+				int assert, const char *caller)
+{
+	*regs = (struct ocotp_regs *)OCOTP_BASE_ADDR;
+
+	if (bank >= FUSE_BANKS ||
+	    word >= ARRAY_SIZE((*regs)->bank[0].fuse_regs) >> 2 ||
+	    !assert) {
+		printf("mxc_ocotp %s(): Invalid argument\n", caller);
+		return -EINVAL;
+	}
+
+	enable_ocotp_clk(1);
+
+	wait_busy(*regs, 1);
+	clear_error(*regs);
+
+	return 0;
+}
+
+static int finish_access(struct ocotp_regs *regs, const char *caller)
+{
+	u32 err;
+
+	err = !!(readl(&regs->ctrl) & BM_CTRL_ERROR);
+	clear_error(regs);
+
+	if (err) {
+		printf("mxc_ocotp %s(): Access protect error\n", caller);
+		return -EIO;
+	}
+
+	return 0;
+}
+
+static int prepare_read(struct ocotp_regs **regs, u32 bank, u32 word, u32 *val,
+			const char *caller)
+{
+	return prepare_access(regs, bank, word, val != NULL, caller);
+}
+
+int fuse_read(u32 bank, u32 word, u32 *val)
+{
+	struct ocotp_regs *regs;
+	int ret;
+	u32 phy_bank;
+
+	ret = prepare_read(&regs, bank, word, val, __func__);
+	if (ret)
+		return ret;
+
+	phy_bank = fuse_bank_physical(bank);
+
+	*val = readl(&regs->bank[phy_bank].fuse_regs[word << 2]);
+
+	return finish_access(regs, __func__);
+}
+
+#ifdef CONFIG_MX7
+static void set_timing(struct ocotp_regs *regs)
+{
+	u32 ipg_clk;
+	u32 fsource, prog;
+	u32 timing;
+
+	ipg_clk = mxc_get_clock(MXC_IPG_CLK);
+
+	fsource = DIV_ROUND_UP((ipg_clk / 1000) * BV_TIMING_FSOURCE_NS,
+			       1000000) + 1;
+	prog = DIV_ROUND_CLOSEST(ipg_clk * BV_TIMING_PROG_US, 1000000) + 1;
+
+	timing = BF(fsource, TIMING_FSOURCE) | BF(prog, TIMING_PROG);
+
+	clrsetbits_le32(&regs->timing, BM_TIMING_FSOURCE | BM_TIMING_PROG,
+			timing);
+}
+#else
+static void set_timing(struct ocotp_regs *regs)
+{
+	u32 ipg_clk;
+	u32 relax, strobe_read, strobe_prog;
+	u32 timing;
+
+	ipg_clk = mxc_get_clock(MXC_IPG_CLK);
+
+	relax = DIV_ROUND_UP(ipg_clk * BV_TIMING_RELAX_NS, 1000000000) - 1;
+	strobe_read = DIV_ROUND_UP(ipg_clk * BV_TIMING_STROBE_READ_NS,
+					1000000000) + 2 * (relax + 1) - 1;
+	strobe_prog = DIV_ROUND_CLOSEST(ipg_clk * BV_TIMING_STROBE_PROG_US,
+						1000000) + 2 * (relax + 1) - 1;
+
+	timing = BF(strobe_read, TIMING_STROBE_READ) |
+			BF(relax, TIMING_RELAX) |
+			BF(strobe_prog, TIMING_STROBE_PROG);
+
+	clrsetbits_le32(&regs->timing, BM_TIMING_STROBE_READ | BM_TIMING_RELAX |
+			BM_TIMING_STROBE_PROG, timing);
+}
+#endif
+
+static void setup_direct_access(struct ocotp_regs *regs, u32 bank, u32 word,
+				int write)
+{
+	u32 wr_unlock = write ? BV_CTRL_WR_UNLOCK_KEY : 0;
+#ifdef CONFIG_MX7
+	u32 addr = bank;
+#else
+	u32 addr = bank << 3 | word;
+#endif
+
+	set_timing(regs);
+	clrsetbits_le32(&regs->ctrl, BM_CTRL_WR_UNLOCK | BM_CTRL_ADDR,
+			BF(wr_unlock, CTRL_WR_UNLOCK) |
+			BF(addr, CTRL_ADDR));
+}
+
+int fuse_sense(u32 bank, u32 word, u32 *val)
+{
+	struct ocotp_regs *regs;
+	int ret;
+
+	ret = prepare_read(&regs, bank, word, val, __func__);
+	if (ret)
+		return ret;
+
+	setup_direct_access(regs, bank, word, false);
+	writel(BM_READ_CTRL_READ_FUSE, &regs->read_ctrl);
+	wait_busy(regs, 1);
+#ifdef CONFIG_MX7
+	*val = readl((&regs->read_fuse_data0) + (word << 2));
+#else
+	*val = readl(&regs->read_fuse_data);
+#endif
+
+	return finish_access(regs, __func__);
+}
+
+static int prepare_write(struct ocotp_regs **regs, u32 bank, u32 word,
+				const char *caller)
+{
+	return prepare_access(regs, bank, word, true, caller);
+}
+
+int fuse_prog(u32 bank, u32 word, u32 val)
+{
+	struct ocotp_regs *regs;
+	int ret;
+
+	ret = prepare_write(&regs, bank, word, __func__);
+	if (ret)
+		return ret;
+
+	setup_direct_access(regs, bank, word, true);
+#ifdef CONFIG_MX7
+	switch (word) {
+	case 0:
+		writel(0, &regs->data1);
+		writel(0, &regs->data2);
+		writel(0, &regs->data3);
+		writel(val, &regs->data0);
+		break;
+	case 1:
+		writel(val, &regs->data1);
+		writel(0, &regs->data2);
+		writel(0, &regs->data3);
+		writel(0, &regs->data0);
+		break;
+	case 2:
+		writel(0, &regs->data1);
+		writel(val, &regs->data2);
+		writel(0, &regs->data3);
+		writel(0, &regs->data0);
+		break;
+	case 3:
+		writel(0, &regs->data1);
+		writel(0, &regs->data2);
+		writel(val, &regs->data3);
+		writel(0, &regs->data0);
+		break;
+	}
+	wait_busy(regs, BV_TIMING_PROG_US);
+#else
+	writel(val, &regs->data);
+	wait_busy(regs, BV_TIMING_STROBE_PROG_US);
+#endif
+	udelay(WRITE_POSTAMBLE_US);
+
+	return finish_access(regs, __func__);
+}
+
+int fuse_override(u32 bank, u32 word, u32 val)
+{
+	struct ocotp_regs *regs;
+	int ret;
+	u32 phy_bank;
+
+	ret = prepare_write(&regs, bank, word, __func__);
+	if (ret)
+		return ret;
+
+	phy_bank = fuse_bank_physical(bank);
+
+	writel(val, &regs->bank[phy_bank].fuse_regs[word << 2]);
+
+	return finish_access(regs, __func__);
+}
diff --git a/drivers/mtd/nand/mxs_nand.c b/drivers/mtd/nand/mxs_nand.c
index 28f284e..5bba8c5 100644
--- a/drivers/mtd/nand/mxs_nand.c
+++ b/drivers/mtd/nand/mxs_nand.c
@@ -639,45 +639,6 @@ static uint8_t mxs_nand_read_byte(struct mtd_info *mtd)
 	return buf;
 }
 
-static bool mxs_nand_erased_page(struct mtd_info *mtd, struct nand_chip *nand,
-				 uint8_t *buf, int chunk, int page)
-{
-	int gf_len = galois_field;
-	unsigned int flip_bits = 0, flip_bits_noecc = 0;
-	unsigned int threshold;
-	unsigned int ecc_chunkn_size = MXS_NAND_CHUNK_DATA_CHUNK_SIZE;
-	unsigned int base = ecc_chunkn_size * chunk;
-	uint32_t *dma_buf = (uint32_t *)buf;
-	int i;
-
-	threshold = gf_len / 2;
-	if (threshold > ecc_strength)
-		threshold = ecc_strength;
-
-	for (i = 0; i < ecc_chunkn_size; i++) {
-		flip_bits += hweight8(~buf[base + i]);
-		if (flip_bits > threshold)
-			return false;
-	}
-
-	nand->cmdfunc(mtd, NAND_CMD_READ0, 0, page);
-	nand->read_buf(mtd, buf, mtd->writesize);
-
-	for (i = 0; i < mtd->writesize / 4; i++) {
-		flip_bits_noecc += hweight32(~dma_buf[i]);
-		if (flip_bits_noecc > threshold)
-			return false;
-	}
-
-	mtd->ecc_stats.corrected += flip_bits;
-
-	memset(buf, 0xff, mtd->writesize);
-
-	printf("The page(%d) is an erased page(%d,%d,%d,%d).\n", page, chunk, threshold, flip_bits, flip_bits_noecc);
-
-	return true;
-}
-
 /*
  * Read a page from NAND.
  */
@@ -687,14 +648,10 @@ static int mxs_nand_ecc_read_page(struct mtd_info *mtd, struct nand_chip *nand,
 {
 	struct mxs_nand_info *nand_info = nand->priv;
 	struct mxs_dma_desc *d;
-#if defined(CONFIG_MX6QP) || defined(CONFIG_MX7) || defined(CONFIG_MX6UL)
-	struct mxs_bch_regs *bch_regs = (struct mxs_bch_regs *)MXS_BCH_BASE;
-#endif
 	uint32_t channel = MXS_DMA_CHANNEL_AHB_APBH_GPMI0 + nand_info->cur_chip;
 	uint32_t corrected = 0, failed = 0;
 	uint8_t	*status;
 	int i, ret;
-	int flag = 0;
 
 	/* Compile the DMA descriptor - wait for ready. */
 	d = mxs_nand_get_dma_desc(nand_info);
@@ -784,8 +741,6 @@ static int mxs_nand_ecc_read_page(struct mtd_info *mtd, struct nand_chip *nand,
 		goto rtn;
 	}
 
-	mxs_nand_return_dma_descs(nand_info);
-
 	/* Invalidate caches */
 	mxs_nand_inval_data_buf(nand_info);
 
@@ -798,18 +753,10 @@ static int mxs_nand_ecc_read_page(struct mtd_info *mtd, struct nand_chip *nand,
 		if (status[i] == 0x00)
 			continue;
 
-		if (status[i] == 0xff) {
-#if defined(CONFIG_MX6QP) || defined(CONFIG_MX7) || defined(CONFIG_MX6UL)
-			if (readl(&bch_regs->hw_bch_debug1))
-				flag = 1;
-#endif
+		if (status[i] == 0xff)
 			continue;
-		}
 
 		if (status[i] == 0xfe) {
-			if (mxs_nand_erased_page(mtd, nand,
-						 nand_info->data_buf, i, page))
-				break;
 			failed++;
 			continue;
 		}
@@ -836,9 +783,6 @@ static int mxs_nand_ecc_read_page(struct mtd_info *mtd, struct nand_chip *nand,
 
 	memcpy(buf, nand_info->data_buf, mtd->writesize);
 
-	if (flag)
-		memset(buf, 0xff, mtd->writesize);
-
 rtn:
 	mxs_nand_return_dma_descs(nand_info);
 
@@ -1162,12 +1106,6 @@ static int mxs_nand_scan_bbt(struct mtd_info *mtd)
 		<< BCH_FLASHLAYOUT1_GF13_0_GF14_1_OFFSET;
 	writel(tmp, &bch_regs->hw_bch_flash0layout1);
 
-	/* Set erase threshold to ecc strength for mx6ul, mx6qp and mx7 */
-#if defined(CONFIG_MX6QP) || defined(CONFIG_MX7) || defined(CONFIG_MX6UL)
-		writel(BCH_MODE_ERASE_THRESHOLD(ecc_strength),
-		       &bch_regs->hw_bch_mode);
-#endif
-
 	/* Set *all* chip selects to use layout 0 */
 	writel(0, &bch_regs->hw_bch_layoutselect);
 
diff --git a/drivers/usb/gadget/Makefile b/drivers/usb/gadget/Makefile
index 4869867..ad9804a 100644
--- a/drivers/usb/gadget/Makefile
+++ b/drivers/usb/gadget/Makefile
@@ -20,6 +20,8 @@ obj-$(CONFIG_USBDOWNLOAD_GADGET) += g_dnl.o
 obj-$(CONFIG_DFU_FUNCTION) += f_dfu.o
 obj-$(CONFIG_USB_GADGET_MASS_STORAGE) += f_mass_storage.o
 obj-$(CONFIG_CMD_FASTBOOT) += f_fastboot.o
+obj-$(CONFIG_BRILLO_SUPPORT) += bootctrl.o
+obj-$(CONFIG_BCB_SUPPORT) += command.o bcb.o
 endif
 ifdef CONFIG_USB_ETHER
 obj-y += ether.o
diff --git a/drivers/usb/gadget/bcb.c b/drivers/usb/gadget/bcb.c
new file mode 100644
index 0000000..f6ccf91
--- /dev/null
+++ b/drivers/usb/gadget/bcb.c
@@ -0,0 +1,177 @@
+/*
+ * Copyright (C) 2015-2016 Freescale Semiconductor, Inc.
+ *
+ * SPDX-License-Identifier:     GPL-2.0+
+ */
+
+#include "bcb.h"
+#include "bootctrl.h"
+#include <linux/stat.h>
+#include <linux/types.h>
+#include <common.h>
+#include <g_dnl.h>
+static unsigned int g_mmc_id;
+void set_mmc_id(unsigned int id)
+{
+	g_mmc_id = id;
+}
+#define ALIGN_BYTES 64 /*armv7 cache line need 64 bytes aligned */
+static ulong get_block_size(char *ifname, int dev, int part)
+{
+	block_dev_desc_t *dev_desc = NULL;
+	disk_partition_t part_info;
+
+	dev_desc = get_dev(ifname, dev);
+	if (dev_desc == NULL) {
+		printf("Block device %s %d not supported\n", ifname, dev);
+		return 0;
+	}
+
+	if (get_partition_info(dev_desc, part, &part_info)) {
+		printf("Cannot find partition %d\n", part);
+		return 0;
+	}
+
+	return part_info.blksz;
+}
+
+static int do_write(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
+{
+	char *ep;
+	block_dev_desc_t *dev_desc = NULL;
+	int dev;
+	int part = 0;
+	disk_partition_t part_info;
+	ulong offset = 0u;
+	ulong limit = 0u;
+	void *addr;
+	uint blk;
+	uint cnt;
+
+	if (argc != 6) {
+		cmd_usage(cmdtp);
+		return 1;
+	}
+
+	dev = (int)simple_strtoul(argv[2], &ep, 16);
+	if (*ep) {
+		if (*ep != ':') {
+			printf("Invalid block device %s\n", argv[2]);
+			return 1;
+		}
+		part = (int)simple_strtoul(++ep, NULL, 16);
+	}
+
+	dev_desc = get_dev(argv[1], dev);
+	if (dev_desc == NULL) {
+		printf("Block device %s %d not supported\n", argv[1], dev);
+		return 1;
+	}
+
+	addr = (void *)simple_strtoul(argv[3], NULL, 16);
+	blk = simple_strtoul(argv[4], NULL, 16);
+	cnt = simple_strtoul(argv[5], NULL, 16);
+
+	if (part != 0) {
+		if (get_partition_info(dev_desc, part, &part_info)) {
+			printf("Cannot find partition %d\n", part);
+			return 1;
+		}
+		offset = part_info.start;
+		limit = part_info.size;
+	} else {
+		/* Largest address not available in block_dev_desc_t. */
+		limit = ~0;
+	}
+
+	if (cnt + blk > limit) {
+		printf("Write out of range\n");
+		return 1;
+	}
+
+	if (dev_desc->block_write(dev, offset + blk, cnt, addr) < 0) {
+		printf("Error writing blocks\n");
+		return 1;
+	}
+
+	return 0;
+}
+
+U_BOOT_CMD(
+	write,	6,	0,	do_write,
+	"write binary data to a partition",
+	"<interface> <dev[:part]> addr blk# cnt"
+);
+
+int rw_block(bool bread, char **ppblock,
+		uint *pblksize, char *pblock_write, uint offset, uint size)
+{
+	int ret;
+	char *argv[6];
+	char addr_str[20];
+	char cnt_str[8];
+	char devpart_str[8];
+	char block_begin_str[8];
+	ulong blk_size = 0;
+	uint blk_begin = 0;
+	uint blk_end = 0;
+	uint block_cnt = 0;
+	char *p_block = NULL;
+
+	if (bread && ((ppblock == NULL) || (pblksize == NULL)))
+		return -1;
+
+	if (!bread && (pblock_write == NULL))
+		return -1;
+
+	blk_size = get_block_size("mmc", g_mmc_id,
+		CONFIG_ANDROID_MISC_PARTITION_MMC);
+	if (blk_size == 0) {
+		printf("rw_block, get_block_size return 0\n");
+		return -1;
+	}
+
+	blk_begin = offset/blk_size;
+	blk_end = (offset + size)/blk_size;
+	block_cnt = 1 + (blk_end - blk_begin);
+
+
+	sprintf(devpart_str, "0x%x:0x%x", g_mmc_id,
+		CONFIG_ANDROID_MISC_PARTITION_MMC);
+	sprintf(block_begin_str, "0x%x", blk_begin);
+	sprintf(cnt_str, "0x%x", block_cnt);
+
+	argv[0] = "rw"; /* not care */
+	argv[1] = "mmc";
+	argv[2] = devpart_str;
+	argv[3] = addr_str;
+	argv[4] = block_begin_str;
+	argv[5] = cnt_str;
+
+	if (bread) {
+		p_block = (char *)memalign(ALIGN_BYTES, blk_size * block_cnt);
+		if (NULL == p_block) {
+			printf("rw_block, memalign %d bytes failed\n",
+			(int)(blk_size * block_cnt));
+			return -1;
+		}
+		sprintf(addr_str, "0x%x", (unsigned int)p_block);
+		ret = do_raw_read(NULL, 0, 6, argv);
+		if (ret) {
+			free(p_block);
+			printf("do_raw_read failed, ret %d\n", ret);
+			return -1;
+		}
+
+		*ppblock = p_block;
+		*pblksize = (uint)blk_size;
+	} else {
+		sprintf(addr_str, "0x%x", (unsigned int)pblock_write);
+		ret = do_write(NULL, 0, 6, argv);
+		if (ret) {
+			printf("do_write failed, ret %d\n", ret);
+			return -1;
+		}
+	}
+	return 0;
+}
diff --git a/drivers/usb/gadget/bcb.h b/drivers/usb/gadget/bcb.h
new file mode 100644
index 0000000..2512a7f
--- /dev/null
+++ b/drivers/usb/gadget/bcb.h
@@ -0,0 +1,38 @@
+/*
+ * Copyright (C) 2015-2016 Freescale Semiconductor, Inc.
+ *
+ * SPDX-License-Identifier:     GPL-2.0+
+ */
+
+#ifndef BCB_H
+#define BCB_H
+#include <linux/types.h>
+#include <linux/stat.h>
+/* keep same as bootable/recovery/bootloader.h */
+struct bootloader_message {
+	char command[32];
+	char status[32];
+	char recovery[768];
+
+	/* The 'recovery' field used to be 1024 bytes.  It has only ever
+	been used to store the recovery command line, so 768 bytes
+	should be plenty.  We carve off the last 256 bytes to store the
+	stage string (for multistage packages) and possible future
+	expansion. */
+	char stage[32];
+	char slot_suffix[32];
+	char reserved[192];
+};
+
+/* start from bootloader_message.slot_suffix[BOOTCTRL_IDX] */
+#define BOOTCTRL_IDX                            0
+#define MISC_COMMAND_IDX                        0
+#define BOOTCTRL_OFFSET         \
+	(u32)(&(((struct bootloader_message *)0)->slot_suffix[BOOTCTRL_IDX]))
+#define MISC_COMMAND \
+	(u32)(&(((struct bootloader_message *)0)->command[MISC_COMMAND_IDX]))
+int rw_block(bool bread, char **ppblock,
+		uint *pblksize, char *pblock_write, uint offset, uint size);
+
+void set_mmc_id(unsigned int id);
+#endif
diff --git a/drivers/usb/gadget/bootctrl.c b/drivers/usb/gadget/bootctrl.c
new file mode 100644
index 0000000..21a7aee
--- /dev/null
+++ b/drivers/usb/gadget/bootctrl.c
@@ -0,0 +1,346 @@
+/*
+ * Copyright (C) 2015-2016 Freescale Semiconductor, Inc.
+ *
+ * SPDX-License-Identifier:     GPL-2.0+
+ */
+
+#include <common.h>
+#include <g_dnl.h>
+#include <fsl_fastboot.h>
+#include "bootctrl.h"
+#include <linux/types.h>
+#include <linux/stat.h>
+static unsigned int g_slot_selected;
+static const char *g_slot_suffix[SLOT_NUM] = {"_a", "_b"};
+
+static int do_write(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[]);
+
+static int strcmp_l1(const char *s1, const char *s2)
+{
+	if (!s1 || !s2)
+		return -1;
+	return strncmp(s1, s2, strlen(s1));
+}
+
+
+static void dump_slotmeta(struct boot_ctl *ptbootctl)
+{
+	int i;
+
+	if (ptbootctl == NULL)
+		return;
+
+	printf("RecoveryTryRemain %d, crc %u\n",
+		   ptbootctl->recovery_tryremain, ptbootctl->crc);
+
+	for (i = 0; i < SLOT_NUM; i++) {
+		printf("slot %d: pri %d, try %d, suc %d\n", i,
+			   ptbootctl->a_slot_meta[i].priority,
+				ptbootctl->a_slot_meta[i].tryremain,
+				ptbootctl->a_slot_meta[i].bootsuc);
+	}
+
+	return;
+}
+
+const char *get_slot_suffix(void)
+{
+	return g_slot_suffix[g_slot_selected];
+}
+
+static unsigned int slot_find(struct boot_ctl *ptbootctl)
+{
+	unsigned int max_pri = 0;
+	unsigned int slot = -1;
+	int i;
+
+	for (i	= 0; i < SLOT_NUM; i++) {
+		struct slot_meta *pslot_meta = &(ptbootctl->a_slot_meta[i]);
+		if ((pslot_meta->priority > max_pri) &&
+			((pslot_meta->bootsuc > 0) ||
+			(pslot_meta->tryremain > 0))) {
+			max_pri = pslot_meta->priority;
+			slot = i;
+			printf("select_slot slot %d\n", slot);
+		}
+	}
+
+	return slot;
+}
+
+
+
+static int read_bootctl(struct boot_ctl *ptbootctl)
+{
+	int ret = 0;
+	unsigned int crc = 0;
+	char *p_block = NULL;
+	uint offset_in_block = 0;
+	uint blk_size = 0;
+	char *pmagic = NULL;
+
+	if (ptbootctl == NULL)
+		return -1;
+	ret = rw_block(true, &p_block, &blk_size, NULL,
+			BOOTCTRL_OFFSET, sizeof(struct boot_ctl));
+	if (ret) {
+		printf("read_bootctl, rw_block read failed\n");
+		return -1;
+	}
+
+	offset_in_block = BOOTCTRL_OFFSET%blk_size;
+	memcpy(ptbootctl, p_block + offset_in_block, sizeof(struct boot_ctl));
+
+	pmagic = ptbootctl->magic;
+	if (!((pmagic[0] == '\0') && (pmagic[1] == 'F') &&
+	      (pmagic[2] == 'S') && (pmagic[3] == 'L'))) {
+		printf("magic error, %c %c %c %c\n",
+		       pmagic[0], pmagic[1], pmagic[2], pmagic[3]);
+
+		free(p_block);
+		return -1;
+	}
+
+	/* check crc */
+	crc = crc32(0, (unsigned char *)ptbootctl + CRC_DATA_OFFSET,
+		sizeof(struct boot_ctl) - CRC_DATA_OFFSET);
+	if (crc != ptbootctl->crc) {
+		printf("crc check failed, caculated %d, read %d\n",
+		       crc, ptbootctl->crc);
+
+		free(p_block);
+		return -1;
+	}
+
+	free(p_block);
+	return 0;
+}
+
+static int write_bootctl(struct boot_ctl *ptbootctl)
+{
+	int ret = 0;
+	char *p_block = NULL;
+	uint offset_in_block = 0;
+	uint blk_size = 0;
+
+	if (ptbootctl == NULL)
+		return -1;
+
+	ptbootctl->crc = crc32(0, (unsigned char *)ptbootctl + CRC_DATA_OFFSET,
+		sizeof(struct boot_ctl) - CRC_DATA_OFFSET);
+
+	ret = rw_block(true, &p_block, &blk_size, NULL,
+				BOOTCTRL_OFFSET, sizeof(struct boot_ctl));
+	if (ret) {
+		printf("write_bootctl, rw_block read failed\n");
+		return -1;
+	}
+	offset_in_block = BOOTCTRL_OFFSET%blk_size;
+	memcpy(p_block + offset_in_block, ptbootctl, sizeof(struct boot_ctl));
+
+	ret = rw_block(false, NULL, NULL, p_block,
+			BOOTCTRL_OFFSET, sizeof(struct boot_ctl));
+	if (ret) {
+		free(p_block);
+		printf("write_bootctl, rw_block write failed\n");
+		return -1;
+	}
+	free(p_block);
+	return 0;
+}
+
+char *select_slot(void)
+{
+	int i = 0;
+	int ret = 0;
+	unsigned int slot;
+	struct boot_ctl t_bootctl;
+	bool b_need_write = false;
+
+	ret = read_bootctl(&t_bootctl);
+	if (ret) {
+		printf("read_bootctl failed, ret %d\n", ret);
+		return NULL;
+	}
+
+	dump_slotmeta(&t_bootctl);
+
+	slot = slot_find(&t_bootctl);
+	if (slot >= SLOT_NUM) {
+		printf("!!! select_slot, no valid slot\n");
+		return NULL;
+	}
+
+	/* invalid slot, set priority to 0 */
+	for (i	= 0; i < SLOT_NUM; i++) {
+		struct slot_meta *pslot_meta = &(t_bootctl.a_slot_meta[i]);
+		if ((pslot_meta->bootsuc == 0) &&
+			(pslot_meta->tryremain == 0) &&
+			(pslot_meta->priority > 0)) {
+			pslot_meta->priority = 0;
+			b_need_write = true;
+		}
+	}
+
+	if (t_bootctl.recovery_tryremain != 7) {
+		b_need_write = true;
+		t_bootctl.recovery_tryremain = 7;
+	}
+
+	if ((t_bootctl.a_slot_meta[slot].bootsuc == 0) &&
+		(t_bootctl.a_slot_meta[slot].tryremain > 0)) {
+		b_need_write = true;
+		t_bootctl.a_slot_meta[slot].tryremain--;
+	}
+
+	if (b_need_write) {
+		ret = write_bootctl(&t_bootctl);
+		if (ret)
+			printf("!!! write_bootctl failed, ret %d\n", ret);
+	}
+
+	g_slot_selected = slot;
+
+	if (slot == 0)
+		return FASTBOOT_PARTITION_BOOT_A;
+	else
+		return FASTBOOT_PARTITION_BOOT_B;
+}
+
+static unsigned int slotidx_from_suffix(char *suffix)
+{
+	unsigned int slot = -1;
+
+	if (!strcmp(suffix, "_a"))
+		slot = 0;
+	else if (!strcmp(suffix, "_b"))
+		slot = 1;
+
+	return slot;
+}
+
+bool is_sotvar(char *cmd)
+{
+	if (!strcmp_l1("has-slot:", cmd) ||
+		!strcmp_l1("slot-successful:", cmd) ||
+		!strcmp_l1("slot-suffixes", cmd) ||
+		!strcmp_l1("current-slot", cmd) ||
+		!strcmp_l1("slot-unbootable:", cmd) ||
+		!strcmp_l1("slot-retry-count:", cmd)) {
+		return true;
+	}
+
+	return false;
+}
+
+void get_slotvar(char *cmd, char *response, size_t chars_left)
+{
+	int ret;
+	struct boot_ctl t_bootctl;
+	memset(&t_bootctl, 0, sizeof(t_bootctl));
+
+	ret = read_bootctl(&t_bootctl);
+	if (ret) {
+		error("get_slotvar, read_bootctl failed\n");
+		strcpy(response, "get_slotvar read_bootctl failed");
+		return;
+	}
+
+	if (!strcmp_l1("has-slot:", cmd)) {
+		char *ptnname = NULL;
+		ptnname = strchr(cmd, ':') + 1;
+		if (!strcmp(ptnname, "system") || !strcmp(ptnname, "boot"))
+			strncat(response, "yes", chars_left);
+		else
+			strncat(response, "no", chars_left);
+	} else if (!strcmp_l1("current-slot", cmd)) {
+		unsigned int slot = slot_find(&t_bootctl);
+		if (slot < SLOT_NUM)
+			strncat(response, g_slot_suffix[slot], chars_left);
+		else
+			strncat(response, "no valid slot", chars_left);
+	} else if (!strcmp_l1("slot-suffixes", cmd)) {
+		strncat(response, "_a,_b", chars_left);
+	} else if (!strcmp_l1("slot-successful:", cmd)) {
+		char *suffix = strchr(cmd, ':') + 1;
+		unsigned int slot = slotidx_from_suffix(suffix);
+		if (slot >= SLOT_NUM) {
+			strncat(response, "no such slot", chars_left);
+		} else {
+			bool suc = t_bootctl.a_slot_meta[slot].bootsuc;
+			strncat(response, suc ? "yes" : "no", chars_left);
+		}
+	} else if (!strcmp_l1("slot-unbootable:", cmd)) {
+		char *suffix = strchr(cmd, ':') + 1;
+		unsigned int slot = slotidx_from_suffix(suffix);
+		if (slot >= SLOT_NUM) {
+			strncat(response, "no such slot", chars_left);
+		} else {
+			unsigned int pri = t_bootctl.a_slot_meta[slot].priority;
+			strncat(response, pri ? "no" : "yes", chars_left);
+		}
+	} else if (!strcmp_l1("slot-retry-count:", cmd)) {
+		char *suffix = strchr(cmd, ':') + 1;
+		unsigned int slot = slotidx_from_suffix(suffix);
+		if (slot >= SLOT_NUM)
+			strncat(response, "no such slot", chars_left);
+		else
+			sprintf(response, "OKAY%d",
+				t_bootctl.a_slot_meta[slot].tryremain);
+	} else {
+		strncat(response, "no such slot command", chars_left);
+	}
+
+	return;
+}
+
+
+void cb_set_active(struct usb_ep *ep, struct usb_request *req)
+{
+	int ret;
+	int i;
+	unsigned int slot = 0;
+	char *cmd = req->buf;
+	struct boot_ctl t_bootctl;
+
+	memset(&t_bootctl, 0, sizeof(t_bootctl));
+
+	strsep(&cmd, ":");
+	if (!cmd) {
+		error("missing slot suffix\n");
+		fastboot_tx_write_str("FAILmissing slot suffix");
+		return;
+	}
+
+	slot = slotidx_from_suffix(cmd);
+	if (slot >= SLOT_NUM) {
+		fastboot_tx_write_str("FAILerr slot suffix");
+		return;
+	}
+
+	ret = read_bootctl(&t_bootctl);
+	if (ret)
+		fastboot_tx_write_str("FAILReadBootCtl failed");
+
+	t_bootctl.a_slot_meta[slot].bootsuc = 0;
+	t_bootctl.a_slot_meta[slot].priority = 15;
+	t_bootctl.a_slot_meta[slot].tryremain = 7;
+
+	/* low other slot priority */
+	for (i = 0; i < SLOT_NUM; i++) {
+		if (i == slot)
+			continue;
+
+		if (t_bootctl.a_slot_meta[i].priority >= 15)
+			t_bootctl.a_slot_meta[i].priority = 14;
+	}
+
+	ret = write_bootctl(&t_bootctl);
+	if (ret)
+		fastboot_tx_write_str("write_bootctl failed");
+	else
+		fastboot_tx_write_str("OKAY");
+
+	return;
+}
+
diff --git a/drivers/usb/gadget/bootctrl.h b/drivers/usb/gadget/bootctrl.h
new file mode 100644
index 0000000..7712f75
--- /dev/null
+++ b/drivers/usb/gadget/bootctrl.h
@@ -0,0 +1,37 @@
+/*
+ * Copyright (C) 2015-2016 Freescale Semiconductor, Inc.
+ *
+ * SPDX-License-Identifier:     GPL-2.0+
+ */
+
+#ifndef BOOTCTRL_H
+#define BOOTCTRL_H
+
+#include <common.h>
+#include <g_dnl.h>
+#include <linux/types.h>
+#include <linux/stat.h>
+#include "bcb.h"
+
+#define SLOT_NUM (unsigned int)2
+#define CRC_DATA_OFFSET		\
+	(uint32_t)(&(((struct boot_ctl *)0)->a_slot_meta[0]))
+
+struct slot_meta {
+	u8 bootsuc:1;
+	u8 tryremain:3;
+	u8 priority:4;
+};
+
+struct boot_ctl {
+	char magic[4]; /* "\0FSL" */
+	u32 crc;
+	struct slot_meta a_slot_meta[SLOT_NUM];
+	u8 recovery_tryremain;
+};
+char *select_slot(void);
+bool is_sotvar(char *cmd);
+void get_slotvar(char *cmd, char *response, size_t chars_left);
+void cb_set_active(struct usb_ep *ep, struct usb_request *req);
+const char *get_slot_suffix(void);
+#endif
diff --git a/drivers/usb/gadget/command.c b/drivers/usb/gadget/command.c
new file mode 100644
index 0000000..3af3fcf
--- /dev/null
+++ b/drivers/usb/gadget/command.c
@@ -0,0 +1,105 @@
+/*
+ * Copyright (C) 2015-2016 Freescale Semiconductor, Inc.
+ *
+ * SPDX-License-Identifier:     GPL-2.0+
+ */
+
+#include <common.h>
+#include <g_dnl.h>
+#include "bcb.h"
+
+#ifndef CONFIG_FASTBOOT_STORAGE_NAND
+static char command[32];
+static int read_command(char *command)
+{
+	int ret = 0;
+	char *p_block = NULL;
+	uint offset_in_block = 0;
+	uint blk_size = 0;
+
+	if (command == NULL)
+		return -1;
+
+	ret = rw_block(true, &p_block, &blk_size, NULL, MISC_COMMAND, 32);
+	if (ret) {
+		printf("read_bootctl, rw_block read failed\n");
+		return -1;
+	}
+
+	offset_in_block = MISC_COMMAND%blk_size;
+	memcpy(command, p_block + offset_in_block, 32);
+
+	return 0;
+}
+static int write_command(char *bcb_command)
+{
+	int ret = 0;
+	char *p_block = NULL;
+	uint offset_in_block = 0;
+	uint blk_size = 0;
+
+	if (bcb_command == NULL)
+		return -1;
+
+
+	ret = rw_block(true, &p_block, &blk_size, NULL,  MISC_COMMAND, 32);
+	if (ret) {
+		printf("write_bootctl, rw_block read failed\n");
+		return -1;
+	}
+
+	offset_in_block = MISC_COMMAND%blk_size;
+	memcpy(p_block + offset_in_block, bcb_command, 32);
+
+	ret = rw_block(false, NULL, NULL, p_block, MISC_COMMAND, 32);
+	if (ret) {
+		free(p_block);
+		printf("write_bootctl, rw_block write failed\n");
+		return -1;
+	}
+
+	free(p_block);
+	return 0;
+}
+
+int recovery_check_and_clean_command(void)
+{
+	int ret;
+	ret = read_command(command);
+	if (ret < 0) {
+		printf("read command failed\n");
+		return 0;
+	}
+	if (!strcmp(command, "boot-recovery")) {
+		memset(command, 0, 32);
+		write_command(command);
+		return 1;
+	}
+	return 0;
+}
+int fastboot_check_and_clean_command(void)
+{
+	int ret;
+	ret = read_command(command);
+	if (ret < 0) {
+		printf("read command failed\n");
+		return 0;
+	}
+	if (!strcmp(command, "boot-bootloader")) {
+		memset(command, 0, 32);
+		write_command(command);
+		return 1;
+	}
+
+	return 0;
+}
+#else
+int recovery_check_and_clean_command(void)
+{
+	return 0;
+}
+int fastboot_check_and_clean_command(void)
+{
+	return 0;
+}
+#endif
diff --git a/drivers/usb/gadget/f_fastboot.c b/drivers/usb/gadget/f_fastboot.c
index 88c648f..d641ebd 100644
--- a/drivers/usb/gadget/f_fastboot.c
+++ b/drivers/usb/gadget/f_fastboot.c
@@ -8,6 +8,8 @@
  * Copyright 2014 Linaro, Ltd.
  * Rob Herring <robh@kernel.org>
  *
+ * Copyright (C) 2016 Freescale Semiconductor, Inc.
+ *
  * SPDX-License-Identifier:	GPL-2.0+
  */
 #include <config.h>
@@ -36,6 +38,12 @@
 #endif
 #endif
 
+#ifdef CONFIG_BRILLO_SUPPORT
+#include "bootctrl.h"
+#endif
+#ifdef CONFIG_BCB_SUPPORT
+#include "bcb.h"
+#endif
 #define FASTBOOT_VERSION		"0.4"
 
 #define FASTBOOT_INTERFACE_CLASS	0xff
@@ -155,13 +163,19 @@ static struct usb_gadget_strings *fastboot_strings[] = {
 
 /*pentry index internally*/
 enum {
-    PTN_MBR_INDEX = 0,
-    PTN_BOOTLOADER_INDEX,
-    PTN_KERNEL_INDEX,
-    PTN_URAMDISK_INDEX,
-    PTN_SYSTEM_INDEX,
-    PTN_RECOVERY_INDEX,
-    PTN_DATA_INDEX
+	PTN_MBR_INDEX = 0,
+	PTN_BOOTLOADER_INDEX,
+	PTN_KERNEL_INDEX,
+	PTN_URAMDISK_INDEX,
+	PTN_SYSTEM_INDEX,
+	PTN_RECOVERY_INDEX,
+	PTN_DATA_INDEX,
+#ifdef CONFIG_BRILLO_SUPPORT
+	PTN_KERNEL_B_INDEX,
+	PTN_SYSTEM_B_INDEX,
+	PTN_MISC_INDEX,
+#endif
+	PTN_NUM
 };
 
 static unsigned int download_bytes_unpadded;
@@ -811,10 +825,19 @@ static void process_flash_sata(const char *cmdbuf, char *response)
 #if defined(CONFIG_FASTBOOT_STORAGE_MMC)
 static int is_sparse_partition(struct fastboot_ptentry *ptn)
 {
+#ifdef CONFIG_BRILLO_SUPPORT
+	if (ptn && (!strncmp(ptn->name, FASTBOOT_PARTITION_SYSTEM_A,
+			     strlen(FASTBOOT_PARTITION_SYSTEM_A)) ||
+	    !strncmp(ptn->name, FASTBOOT_PARTITION_SYSTEM_B,
+	    strlen(FASTBOOT_PARTITION_SYSTEM_B)) ||
+	    !strncmp(ptn->name, FASTBOOT_PARTITION_DATA,
+	    strlen(FASTBOOT_PARTITION_DATA)))) {
+#else
 	 if (ptn && (!strncmp(ptn->name,
 				 FASTBOOT_PARTITION_SYSTEM, strlen(FASTBOOT_PARTITION_SYSTEM))
 				 || !strncmp(ptn->name,
 				 FASTBOOT_PARTITION_DATA, strlen(FASTBOOT_PARTITION_DATA)))) {
+#endif
 		printf("support sparse flash partition for %s\n", ptn->name);
 		return 1;
 	 } else
@@ -1078,6 +1101,9 @@ static int _fastboot_setup_dev(void)
 		} else if (!strncmp(fastboot_env, "mmc", 3)) {
 			fastboot_devinfo.type = DEV_MMC;
 			fastboot_devinfo.dev_id = _fastboot_get_mmc_no(fastboot_env);
+#ifdef CONFIG_BCB_SUPPORT
+			set_mmc_id(fastboot_devinfo.dev_id);
+#endif
 		}
 	} else {
 		return 1;
@@ -1131,7 +1157,7 @@ static int _fastboot_parts_load_from_ptable(void)
 
 	struct mmc *mmc;
 	block_dev_desc_t *dev_desc;
-	struct fastboot_ptentry ptable[PTN_DATA_INDEX + 1];
+	struct fastboot_ptentry ptable[PTN_NUM];
 
 	/* sata case in env */
 	if (fastboot_devinfo.type == DEV_SATA) {
@@ -1178,7 +1204,7 @@ static int _fastboot_parts_load_from_ptable(void)
 	}
 
 	memset((char *)ptable, 0,
-		    sizeof(struct fastboot_ptentry) * (PTN_DATA_INDEX + 1));
+		    sizeof(struct fastboot_ptentry) * (PTN_NUM));
 	/* MBR */
 	strcpy(ptable[PTN_MBR_INDEX].name, "mbr");
 	ptable[PTN_MBR_INDEX].start = ANDROID_MBR_OFFSET / dev_desc->blksz;
@@ -1192,24 +1218,75 @@ static int _fastboot_parts_load_from_ptable(void)
 				 ANDROID_BOOTLOADER_SIZE / dev_desc->blksz;
 	ptable[PTN_BOOTLOADER_INDEX].partition_id = boot_partition;
 
+#ifdef CONFIG_BRILLO_SUPPORT
 	_fastboot_parts_add_ptable_entry(PTN_KERNEL_INDEX,
-				   CONFIG_ANDROID_BOOT_PARTITION_MMC,
-				   user_partition,
-				   FASTBOOT_PARTITION_BOOT , dev_desc, ptable);
+					 CONFIG_ANDROID_BOOT_PARTITION_MMC,
+					 user_partition,
+					 FASTBOOT_PARTITION_BOOT_A,
+					 dev_desc, ptable);
+
 	_fastboot_parts_add_ptable_entry(PTN_RECOVERY_INDEX,
-				   CONFIG_ANDROID_RECOVERY_PARTITION_MMC,
-				   user_partition,
-				   FASTBOOT_PARTITION_RECOVERY, dev_desc, ptable);
+					 CONFIG_ANDROID_RECOVERY_PARTITION_MMC,
+					 user_partition,
+					 FASTBOOT_PARTITION_RECOVERY,
+					 dev_desc, ptable);
+
 	_fastboot_parts_add_ptable_entry(PTN_SYSTEM_INDEX,
-				   CONFIG_ANDROID_SYSTEM_PARTITION_MMC,
-				   user_partition,
-				   FASTBOOT_PARTITION_SYSTEM, dev_desc, ptable);
+					 CONFIG_ANDROID_SYSTEM_PARTITION_MMC,
+					 user_partition,
+					 FASTBOOT_PARTITION_SYSTEM_A,
+					 dev_desc, ptable);
+
 	_fastboot_parts_add_ptable_entry(PTN_DATA_INDEX,
-				   CONFIG_ANDROID_DATA_PARTITION_MMC,
-				   user_partition,
-				   FASTBOOT_PARTITION_DATA, dev_desc, ptable);
+					 CONFIG_ANDROID_DATA_PARTITION_MMC,
+					 user_partition,
+					 FASTBOOT_PARTITION_DATA,
+					 dev_desc, ptable);
+
+	 _fastboot_parts_add_ptable_entry(PTN_KERNEL_B_INDEX,
+					  CONFIG_ANDROID_BOOT_B_PARTITION_MMC,
+					  user_partition,
+					  FASTBOOT_PARTITION_BOOT_B,
+					  dev_desc, ptable);
+
+	_fastboot_parts_add_ptable_entry(PTN_SYSTEM_B_INDEX,
+					 CONFIG_ANDROID_SYSTEM_B_PARTITION_MMC,
+					 user_partition,
+					 FASTBOOT_PARTITION_SYSTEM_B,
+					 dev_desc, ptable);
+
+	_fastboot_parts_add_ptable_entry(PTN_MISC_INDEX,
+					 CONFIG_ANDROID_MISC_PARTITION_MMC,
+					 user_partition,
+					 FASTBOOT_PARTITION_MISC,
+					 dev_desc, ptable);
+#else
+	_fastboot_parts_add_ptable_entry(PTN_KERNEL_INDEX,
+					 CONFIG_ANDROID_BOOT_PARTITION_MMC,
+					 user_partition,
+					 FASTBOOT_PARTITION_BOOT,
+					 dev_desc, ptable);
+
+	_fastboot_parts_add_ptable_entry(PTN_RECOVERY_INDEX,
+					 CONFIG_ANDROID_RECOVERY_PARTITION_MMC,
+					 user_partition,
+					 FASTBOOT_PARTITION_RECOVERY,
+					 dev_desc, ptable);
+
+	_fastboot_parts_add_ptable_entry(PTN_SYSTEM_INDEX,
+					 CONFIG_ANDROID_SYSTEM_PARTITION_MMC,
+					 user_partition,
+					 FASTBOOT_PARTITION_SYSTEM,
+					 dev_desc, ptable);
 
-	for (i = 0; i <= PTN_DATA_INDEX; i++)
+	_fastboot_parts_add_ptable_entry(PTN_DATA_INDEX,
+					 CONFIG_ANDROID_DATA_PARTITION_MMC,
+					 user_partition,
+					 FASTBOOT_PARTITION_DATA,
+					 dev_desc, ptable);
+#endif
+
+	for (i = 0; i < PTN_NUM; i++)
 		fastboot_flash_add_ptn(&ptable[i]);
 
 	return 0;
@@ -1553,7 +1630,16 @@ int do_boota(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
 
 	if (argc > 2)
 		ptn = argv[2];
-
+#ifdef CONFIG_BRILLO_SUPPORT
+	else {
+		ptn = select_slot();
+		if (ptn == NULL) {
+			printf("no valid slot found, enter to recovery\n");
+			ptn = "recovery";
+		}
+		printf("use slot %s\n", ptn);
+	}
+#endif
 	if (mmcc != -1) {
 #ifdef CONFIG_MMC
 		struct fastboot_ptentry *pte;
@@ -1997,7 +2083,7 @@ static int fastboot_tx_write(const char *buffer, unsigned int buffer_size)
 	return 0;
 }
 
-static int fastboot_tx_write_str(const char *buffer)
+int fastboot_tx_write_str(const char *buffer)
 {
 	return fastboot_tx_write(buffer, strlen(buffer));
 }
@@ -2037,6 +2123,13 @@ static void cb_getvar(struct usb_ep *ep, struct usb_request *req)
 		return;
 	}
 
+#ifdef CONFIG_BRILLO_SUPPORT
+	if (is_sotvar(cmd)) {
+		get_slotvar(cmd, response, chars_left);
+		fastboot_tx_write_str(response);
+		return;
+	}
+#endif
 	if (!strcmp_l1("version", cmd)) {
 		strncat(response, FASTBOOT_VERSION, chars_left);
 	} else if (!strcmp_l1("bootloader-version", cmd)) {
@@ -2361,6 +2454,12 @@ static const struct cmd_dispatch_info cmd_dispatch_info[] = {
 		.cmd = "oem",
 		.cb = cb_oem,
 	},
+#ifdef CONFIG_BRILLO_SUPPORT
+	{
+		.cmd = "set_active",
+		.cb = cb_set_active,
+	},
+#endif
 };
 
 static void rx_handler_command(struct usb_ep *ep, struct usb_request *req)
diff --git a/include/common.h b/include/common.h
index 179392b..e7fefea 100644
--- a/include/common.h
+++ b/include/common.h
@@ -850,6 +850,10 @@ int cpu_disable(int nr);
 int cpu_release(int nr, int argc, char * const argv[]);
 #endif
 
+#ifdef CONFIG_CMD_READ
+int do_raw_read(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[]);
+#endif
+
 /* Define a null map_sysmem() if the architecture doesn't use it */
 # ifndef CONFIG_ARCH_MAP_SYSMEM
 static inline void *map_sysmem(phys_addr_t paddr, unsigned long len)
diff --git a/include/configs/mx6qarm2.h b/include/configs/mx6qarm2.h
index daeca9f..c1b9ed9 100644
--- a/include/configs/mx6qarm2.h
+++ b/include/configs/mx6qarm2.h
@@ -91,11 +91,17 @@
 #define CONFIG_LOADADDR			0x12000000
 #define CONFIG_SYS_TEXT_BASE		0x17800000
 
+#if defined(CONFIG_MX6DQ_POP_LPDDR2)
+#define CONFIG_DEFAULT_FDT_FILE "imx6q-pop-arm2.dtb"
+#else
+#define CONFIG_DEFAULT_FDT_FILE "imx6q-arm2.dtb"
+#endif
+
 #define CONFIG_EXTRA_ENV_SETTINGS \
 	"script=boot.scr\0" \
 	"image=zImage\0" \
 	"console=ttymxc3\0" \
-	"fdt_file=imx6q-arm2.dtb\0" \
+	"fdt_file=" CONFIG_DEFAULT_FDT_FILE "\0" \
 	"fdt_addr=0x18000000\0" \
 	"fdt_high=0xffffffff\0" \
 	"initrd_high=0xffffffff\0" \
@@ -189,7 +195,13 @@
 #define CONFIG_CMDLINE_EDITING
 
 /* Physical Memory Map */
+#if defined(CONFIG_MX6DQ_POP_LPDDR2)
+#define CONFIG_NR_DRAM_BANKS		2
+#define PHYS_SDRAM_0			MMDC0_ARB_BASE_ADDR
+#define PHYS_SDRAM_1			MMDC1_ARB_BASE_ADDR
+#else
 #define CONFIG_NR_DRAM_BANKS		1
+#endif
 #define PHYS_SDRAM			MMDC0_ARB_BASE_ADDR
 
 #define CONFIG_SYS_SDRAM_BASE		PHYS_SDRAM
diff --git a/include/configs/mx6sabre_common.h b/include/configs/mx6sabre_common.h
index 481254f..ebedc50 100644
--- a/include/configs/mx6sabre_common.h
+++ b/include/configs/mx6sabre_common.h
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2012-2016 Freescale Semiconductor, Inc.
+ * Copyright (C) 2012-2015 Freescale Semiconductor, Inc.
  *
  * Configuration settings for the Freescale i.MX6Q SabreSD board.
  *
@@ -402,7 +402,7 @@
 #define CONFIG_ENV_OFFSET              (4 * CONFIG_SYS_FLASH_SECT_SIZE)
 #elif defined(CONFIG_ENV_IS_IN_NAND)
 #undef CONFIG_ENV_SIZE
-#define CONFIG_ENV_OFFSET              (60 << 20)
+#define CONFIG_ENV_OFFSET              (37 << 20)
 #define CONFIG_ENV_SECT_SIZE           (128 << 10)
 #define CONFIG_ENV_SIZE                        CONFIG_ENV_SECT_SIZE
 #elif defined(CONFIG_ENV_IS_IN_SATA)
@@ -436,7 +436,7 @@
 #define CONFIG_BMP_16BPP
 #define CONFIG_VIDEO_LOGO
 #define CONFIG_VIDEO_BMP_LOGO
-#ifdef CONFIG_MX6DL
+#ifdef CONFIG_MX6DL                                                             
 #define CONFIG_IPUV3_CLK 198000000
 #else
 #define CONFIG_IPUV3_CLK 264000000
diff --git a/include/configs/mx6sabreandroid_common.h b/include/configs/mx6sabreandroid_common.h
index d2be182..02d3bf8 100644
--- a/include/configs/mx6sabreandroid_common.h
+++ b/include/configs/mx6sabreandroid_common.h
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2013-2015 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright (C) 2013-2016 Freescale Semiconductor, Inc. All Rights Reserved.
  *
  * SPDX-License-Identifier:	GPL-2.0+
  */
@@ -22,6 +22,8 @@
 #define CONFIG_G_DNL_MANUFACTURER	"FSL"
 
 #define CONFIG_CMD_FASTBOOT
+#define CONFIG_CMD_READ
+#define CONFIG_BCB_SUPPORT
 #define CONFIG_ANDROID_BOOT_IMAGE
 #define CONFIG_FASTBOOT_FLASH
 
@@ -42,6 +44,7 @@
 #define CONFIG_ANDROID_RECOVERY_PARTITION_MMC 2
 #define CONFIG_ANDROID_CACHE_PARTITION_MMC 6
 #define CONFIG_ANDROID_DATA_PARTITION_MMC 4
+#define CONFIG_ANDROID_MISC_PARTITION_MMC 8
 
 #if defined(CONFIG_FASTBOOT_STORAGE_NAND)
 #define ANDROID_FASTBOOT_NAND_PARTS "16m@64m(boot) 16m@80m(recovery) 810m@96m(android_root)ubifs"
@@ -60,6 +63,9 @@
 	"initrd_high=0xffffffff\0" \
 
 #define CONFIG_USB_FASTBOOT_BUF_ADDR   CONFIG_SYS_LOAD_ADDR
+#ifdef CONFIG_FASTBOOT_STORAGE_NAND
+#define CONFIG_USB_FASTBOOT_BUF_SIZE   0x25000000
+#else
 #define CONFIG_USB_FASTBOOT_BUF_SIZE   0x19000000
-
+#endif
 #endif /* MX6_SABRE_ANDROID_COMMON_H */
diff --git a/include/configs/mx6slevkandroid.h b/include/configs/mx6slevkandroid.h
index 3c3b2ce..1f2f0e5 100644
--- a/include/configs/mx6slevkandroid.h
+++ b/include/configs/mx6slevkandroid.h
@@ -1,6 +1,6 @@
 
 /*
- * Copyright (C) 2013-2015 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright (C) 2013-2016 Freescale Semiconductor, Inc. All Rights Reserved.
  *
  * SPDX-License-Identifier:	GPL-2.0+
  */
@@ -25,6 +25,8 @@
 #define CONFIG_G_DNL_MANUFACTURER	"FSL"
 
 #define CONFIG_CMD_FASTBOOT
+#define CONFIG_CMD_READ
+#define CONFIG_BCB_SUPPORT
 #define CONFIG_ANDROID_BOOT_IMAGE
 #define CONFIG_FASTBOOT_FLASH
 
@@ -39,6 +41,7 @@
 #define CONFIG_ANDROID_RECOVERY_PARTITION_MMC 2
 #define CONFIG_ANDROID_CACHE_PARTITION_MMC 6
 #define CONFIG_ANDROID_DATA_PARTITION_MMC 4
+#define CONFIG_ANDROID_MISC_PARTITION_MMC 8
 
 #define CONFIG_CMD_BOOTA
 #define CONFIG_SUPPORT_RAW_INITRD
@@ -68,6 +71,9 @@
 	"initrd_high=0xffffffff\0" \
 
 #define CONFIG_USB_FASTBOOT_BUF_ADDR   CONFIG_SYS_LOAD_ADDR
+#ifdef CONFIG_FASTBOOT_STORAGE_NAND
+#define CONFIG_USB_FASTBOOT_BUF_SIZE   0x25000000
+#else
 #define CONFIG_USB_FASTBOOT_BUF_SIZE   0x19000000
-
+#endif
 #endif
diff --git a/include/configs/mx6sx_arm2.h b/include/configs/mx6sx_arm2.h
index 9c4484c..94c89ea 100644
--- a/include/configs/mx6sx_arm2.h
+++ b/include/configs/mx6sx_arm2.h
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2014-2016 Freescale Semiconductor, Inc.
+ * Copyright (C) 2014-2015 Freescale Semiconductor, Inc.
  *
  * Configuration settings for the Freescale i.MX6SX ARM2 board.
  *
@@ -391,7 +391,7 @@
 #define CONFIG_ENV_SPI_MAX_HZ		CONFIG_SF_DEFAULT_SPEED
 #elif defined(CONFIG_ENV_IS_IN_NAND)
 #undef CONFIG_ENV_SIZE
-#define CONFIG_ENV_OFFSET		(60 << 20)
+#define CONFIG_ENV_OFFSET		(37 << 20)
 #define CONFIG_ENV_SECT_SIZE		(128 << 10)
 #define CONFIG_ENV_SIZE			CONFIG_ENV_SECT_SIZE
 #elif defined(CONFIG_ENV_IS_IN_FLASH)
diff --git a/include/configs/mx6sxsabreauto.h b/include/configs/mx6sxsabreauto.h
index 2032508..276c2fb 100644
--- a/include/configs/mx6sxsabreauto.h
+++ b/include/configs/mx6sxsabreauto.h
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2014-2016 Freescale Semiconductor, Inc.
+ * Copyright (C) 2014-2015 Freescale Semiconductor, Inc.
  *
  * Configuration settings for the Freescale i.MX6SX SABREAUTO board.
  *
@@ -378,7 +378,7 @@
 #define CONFIG_ENV_SPI_MAX_HZ		CONFIG_SF_DEFAULT_SPEED
 #elif defined(CONFIG_ENV_IS_IN_NAND)
 #undef CONFIG_ENV_SIZE
-#define CONFIG_ENV_OFFSET		(60 << 20)
+#define CONFIG_ENV_OFFSET		(37 << 20)
 #define CONFIG_ENV_SECT_SIZE		(128 << 10)
 #define CONFIG_ENV_SIZE			CONFIG_ENV_SECT_SIZE
 #endif
diff --git a/include/configs/mx6sxsabreautoandroid.h b/include/configs/mx6sxsabreautoandroid.h
index e21c456..a03512b 100644
--- a/include/configs/mx6sxsabreautoandroid.h
+++ b/include/configs/mx6sxsabreautoandroid.h
@@ -1,6 +1,6 @@
 
 /*
- * Copyright (C) 2014-2015 Freescale Semiconductor, Inc.
+ * Copyright (C) 2014-2016 Freescale Semiconductor, Inc.
  *
  * SPDX-License-Identifier:	GPL-2.0+
  */
@@ -23,6 +23,8 @@
 #define CONFIG_G_DNL_MANUFACTURER	"FSL"
 
 #define CONFIG_CMD_FASTBOOT
+#define CONFIG_CMD_READ
+#define CONFIG_BCB_SUPPORT
 #define CONFIG_ANDROID_BOOT_IMAGE
 #define CONFIG_FASTBOOT_FLASH
 
@@ -45,6 +47,7 @@
 #define CONFIG_ANDROID_RECOVERY_PARTITION_MMC 2
 #define CONFIG_ANDROID_CACHE_PARTITION_MMC 6
 #define CONFIG_ANDROID_DATA_PARTITION_MMC 4
+#define CONFIG_ANDROID_MISC_PARTITION_MMC 8
 
 #define CONFIG_CMD_BOOTA
 #define CONFIG_SUPPORT_RAW_INITRD
@@ -59,6 +62,9 @@
 	"initrd_high=0xffffffff\0" \
 
 #define CONFIG_USB_FASTBOOT_BUF_ADDR   CONFIG_SYS_LOAD_ADDR
+#ifdef CONFIG_FASTBOOT_STORAGE_NAND
+#define CONFIG_USB_FASTBOOT_BUF_SIZE   0x25000000
+#else
 #define CONFIG_USB_FASTBOOT_BUF_SIZE   0x19000000
-
+#endif
 #endif
diff --git a/include/configs/mx6sxsabresdandroid.h b/include/configs/mx6sxsabresdandroid.h
index 68f86df..41f1297 100644
--- a/include/configs/mx6sxsabresdandroid.h
+++ b/include/configs/mx6sxsabresdandroid.h
@@ -1,6 +1,6 @@
 
 /*
- * Copyright (C) 2014-2015 Freescale Semiconductor, Inc.
+ * Copyright (C) 2014-2016 Freescale Semiconductor, Inc.
  *
  * SPDX-License-Identifier:	GPL-2.0+
  */
@@ -23,6 +23,8 @@
 #define CONFIG_G_DNL_MANUFACTURER	"FSL"
 
 #define CONFIG_CMD_FASTBOOT
+#define CONFIG_CMD_READ
+#define CONFIG_BCB_SUPPORT
 #define CONFIG_ANDROID_BOOT_IMAGE
 #define CONFIG_FASTBOOT_FLASH
 
@@ -37,6 +39,7 @@
 #define CONFIG_ANDROID_RECOVERY_PARTITION_MMC 2
 #define CONFIG_ANDROID_CACHE_PARTITION_MMC 6
 #define CONFIG_ANDROID_DATA_PARTITION_MMC 4
+#define CONFIG_ANDROID_MISC_PARTITION_MMC 8
 
 #define CONFIG_CMD_BOOTA
 #define CONFIG_SUPPORT_RAW_INITRD
@@ -51,7 +54,10 @@
 	"initrd_high=0xffffffff\0" \
 
 #define CONFIG_USB_FASTBOOT_BUF_ADDR   CONFIG_SYS_LOAD_ADDR
+#ifdef CONFIG_FASTBOOT_STORAGE_NAND
+#define CONFIG_USB_FASTBOOT_BUF_SIZE   0x25000000
+#else
 #define CONFIG_USB_FASTBOOT_BUF_SIZE   0x19000000
-
+#endif
 
 #endif
diff --git a/include/configs/mx6ul_14x14_evk.h b/include/configs/mx6ul_14x14_evk.h
index 72104a1..6f3f92a 100644
--- a/include/configs/mx6ul_14x14_evk.h
+++ b/include/configs/mx6ul_14x14_evk.h
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2015 Freescale Semiconductor, Inc.
+ * Copyright (C) 2015-2016 Freescale Semiconductor, Inc.
  *
  * Configuration settings for the Freescale i.MX6UL 14x14 EVK board.
  *
@@ -376,7 +376,7 @@
 #define CONFIG_ENV_SPI_MAX_HZ		CONFIG_SF_DEFAULT_SPEED
 #elif defined(CONFIG_ENV_IS_IN_NAND)
 #undef CONFIG_ENV_SIZE
-#define CONFIG_ENV_OFFSET		(60 << 20)
+#define CONFIG_ENV_OFFSET		(37 << 20)
 #define CONFIG_ENV_SECT_SIZE		(128 << 10)
 #define CONFIG_ENV_SIZE			CONFIG_ENV_SECT_SIZE
 #endif
@@ -430,4 +430,9 @@
 #include "mx6ul_14x14_evk_android.h"
 #endif
 
+#if defined(CONFIG_BRILLO_SUPPORT)
+#include "mx6ul_14x14_evk_brillo.h"
+#endif
+
+
 #endif
diff --git a/include/configs/mx6ul_14x14_evk_android.h b/include/configs/mx6ul_14x14_evk_android.h
index 9d6a267..71c94e0 100644
--- a/include/configs/mx6ul_14x14_evk_android.h
+++ b/include/configs/mx6ul_14x14_evk_android.h
@@ -1,6 +1,6 @@
 
 /*
- * Copyright (C) 2015 Freescale Semiconductor, Inc.
+ * Copyright (C) 2015-2016 Freescale Semiconductor, Inc.
  *
  * SPDX-License-Identifier:	GPL-2.0+
  */
@@ -23,6 +23,7 @@
 #define CONFIG_G_DNL_MANUFACTURER	"FSL"
 
 #define CONFIG_CMD_FASTBOOT
+#define CONFIG_BCB_SUPPORT
 #define CONFIG_ANDROID_BOOT_IMAGE
 #define CONFIG_FASTBOOT_FLASH
 
diff --git a/include/configs/mx6ul_14x14_evk_brillo.h b/include/configs/mx6ul_14x14_evk_brillo.h
index 9b2f9e1..ad1ad93 100644
--- a/include/configs/mx6ul_14x14_evk_brillo.h
+++ b/include/configs/mx6ul_14x14_evk_brillo.h
@@ -1,6 +1,6 @@
 
 /*
- * Copyright (C) 2015 Freescale Semiconductor, Inc.
+ * Copyright (C) 2015-2016 Freescale Semiconductor, Inc.
  *
  * SPDX-License-Identifier:	GPL-2.0+
  */
@@ -10,15 +10,13 @@
 
 #define CONFIG_ANDROID_BOOT_B_PARTITION_MMC 7
 #define CONFIG_ANDROID_SYSTEM_B_PARTITION_MMC 8
-#define CONFIG_ANDROID_SLOTMETA_PARTITION_MMC 9
+#define CONFIG_ANDROID_MISC_PARTITION_MMC 9
 
-
-#define CONFIG_CMD_EXT2
-#define CONFIG_CMD_EXT4
-#define CONFIG_CMD_EXT4_WRITE
 #define CONFIG_CMD_FAT
 #define CONFIG_DOS_PARTITION
 
 #define CONFIG_SYS_BOOTM_LEN 0x1000000
 
+#define CONFIG_CMD_READ
+
 #endif
diff --git a/include/configs/mx6ul_arm2.h b/include/configs/mx6ul_arm2.h
index 23bddca..6515178 100644
--- a/include/configs/mx6ul_arm2.h
+++ b/include/configs/mx6ul_arm2.h
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2015 Freescale Semiconductor, Inc.
+ * Copyright (C) 2015-2016 Freescale Semiconductor, Inc.
  *
  * Configuration settings for the Freescale i.MX6UL ARM2 common.
  *
@@ -14,7 +14,9 @@
 #include "mx6_common.h"
 #include <asm/imx-common/gpio.h>
 
+#ifndef CONFIG_MX6
 #define CONFIG_MX6
+#endif
 #define CONFIG_ROM_UNIFIED_SECTIONS
 #define CONFIG_SYS_GENERIC_BOARD
 #define CONFIG_DISPLAY_CPUINFO
@@ -317,7 +319,7 @@
 #define CONFIG_ENV_OFFSET              (4 * CONFIG_SYS_FLASH_SECT_SIZE)
 #elif defined(CONFIG_ENV_IS_IN_NAND)
 #undef CONFIG_ENV_SIZE
-#define CONFIG_ENV_OFFSET		(60 << 20)
+#define CONFIG_ENV_OFFSET		(37 << 20)
 #define CONFIG_ENV_SECT_SIZE		(128 << 10)
 #define CONFIG_ENV_SIZE			CONFIG_ENV_SECT_SIZE
 #endif
diff --git a/include/configs/mx6ull_ddr3_arm2.h b/include/configs/mx6ull_ddr3_arm2.h
new file mode 100644
index 0000000..e593d25
--- /dev/null
+++ b/include/configs/mx6ull_ddr3_arm2.h
@@ -0,0 +1,70 @@
+/*
+ * Copyright (C) 2016 Freescale Semiconductor, Inc.
+ *
+ * Configuration settings for the Freescale i.MX6UL 14x14 DDR3 ARM2.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+#ifndef __MX6ULL_DDR3_ARM2_CONFIG_H
+#define __MX6ULL_DDR3_ARM2_CONFIG_H
+
+#define CONFIG_DEFAULT_FDT_FILE  "imx6ull-ddr3-arm2.dtb"
+
+#ifdef CONFIG_SYS_BOOT_QSPI
+#define CONFIG_SYS_USE_QSPI
+#define CONFIG_ENV_IS_IN_SPI_FLASH
+#elif defined CONFIG_SYS_BOOT_SPINOR
+#define CONFIG_SYS_USE_SPINOR
+#define CONFIG_ENV_IS_IN_SPI_FLASH
+#elif defined CONFIG_SYS_BOOT_NAND
+#define CONFIG_SYS_USE_NAND
+#define CONFIG_ENV_IS_IN_NAND
+#else
+#define CONFIG_ENV_IS_IN_MMC
+#endif
+
+#define CONFIG_VIDEO
+#define CONFIG_FSL_USDHC
+#define CONFIG_BOOTARGS_CMA_SIZE   ""
+
+#include "mx6ul_arm2.h"
+
+#define PHYS_SDRAM_SIZE			SZ_1G
+
+#ifdef CONFIG_SYS_USE_SPINOR
+#define CONFIG_CMD_SF
+#define CONFIG_SPI_FLASH
+#define CONFIG_SPI_FLASH_STMICRO
+#define CONFIG_MXC_SPI
+#define CONFIG_SF_DEFAULT_BUS  0
+#define CONFIG_SF_DEFAULT_SPEED 20000000
+#define CONFIG_SF_DEFAULT_MODE (SPI_MODE_0)
+#define CONFIG_SF_DEFAULT_CS   0
+#endif
+
+#define CONFIG_CMD_NET
+#ifdef CONFIG_CMD_NET
+#define CONFIG_CMD_PING
+#define CONFIG_CMD_DHCP
+#define CONFIG_CMD_MII
+#define CONFIG_FEC_MXC
+#define CONFIG_MII
+#define CONFIG_FEC_ENET_DEV 1
+
+#if (CONFIG_FEC_ENET_DEV == 0)
+#define IMX_FEC_BASE			ENET_BASE_ADDR
+#define CONFIG_FEC_MXC_PHYADDR          0x1
+#define CONFIG_FEC_XCV_TYPE             RMII
+#elif (CONFIG_FEC_ENET_DEV == 1)
+#define IMX_FEC_BASE			ENET2_BASE_ADDR
+#define CONFIG_FEC_MXC_PHYADDR          0x2
+#define CONFIG_FEC_XCV_TYPE             MII100
+#endif
+#define CONFIG_ETHPRIME                 "FEC"
+
+#define CONFIG_PHYLIB
+#define CONFIG_PHY_MICREL
+#define CONFIG_FEC_DMA_MINALIGN		64
+#endif
+
+#endif
diff --git a/include/configs/mx7d_arm2.h b/include/configs/mx7d_arm2.h
index 70cd1c9..7a1262f 100644
--- a/include/configs/mx7d_arm2.h
+++ b/include/configs/mx7d_arm2.h
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2014-2016 Freescale Semiconductor, Inc.
+ * Copyright (C) 2014-2015 Freescale Semiconductor, Inc.
  *
  * Configuration settings for the Freescale i.MX7D ARM2 board.
  *
@@ -353,7 +353,7 @@
 #define CONFIG_ENV_OFFSET		(4 * CONFIG_SYS_FLASH_SECT_SIZE)
 #elif defined(CONFIG_ENV_IS_IN_NAND)
 #undef CONFIG_ENV_SIZE
-#define CONFIG_ENV_OFFSET		(60 << 20)
+#define CONFIG_ENV_OFFSET		(37 << 20)
 #define CONFIG_ENV_SECT_SIZE		(128 << 10)
 #define CONFIG_ENV_SIZE			CONFIG_ENV_SECT_SIZE
 #endif
diff --git a/include/configs/mx7dsabresd.h b/include/configs/mx7dsabresd.h
index 9d3a9a0..e44c81f 100644
--- a/include/configs/mx7dsabresd.h
+++ b/include/configs/mx7dsabresd.h
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2015-2016 Freescale Semiconductor, Inc.
+ * Copyright (C) 2015 Freescale Semiconductor, Inc.
  *
  * Configuration settings for the Freescale i.MX7D SABRESD board.
  *
@@ -376,7 +376,7 @@
 #define CONFIG_ENV_SPI_MAX_HZ		CONFIG_SF_DEFAULT_SPEED
 #elif defined(CONFIG_ENV_IS_IN_NAND)
 #undef CONFIG_ENV_SIZE
-#define CONFIG_ENV_OFFSET		(60 << 20)
+#define CONFIG_ENV_OFFSET		(37 << 20)
 #define CONFIG_ENV_SECT_SIZE		(128 << 10)
 #define CONFIG_ENV_SIZE			CONFIG_ENV_SECT_SIZE
 #endif
diff --git a/include/configs/mx7dsabresdandroid.h b/include/configs/mx7dsabresdandroid.h
index 3ced17f..74112d8 100644
--- a/include/configs/mx7dsabresdandroid.h
+++ b/include/configs/mx7dsabresdandroid.h
@@ -1,6 +1,6 @@
 
 /*
- * Copyright (C) 2015 Freescale Semiconductor, Inc.
+ * Copyright (C) 2015-2016 Freescale Semiconductor, Inc.
  *
  * SPDX-License-Identifier:	GPL-2.0+
  */
@@ -23,6 +23,8 @@
 #define CONFIG_G_DNL_MANUFACTURER	"FSL"
 
 #define CONFIG_CMD_FASTBOOT
+#define CONFIG_CMD_READ
+#define CONFIG_BCB_SUPPORT
 #define CONFIG_ANDROID_BOOT_IMAGE
 #define CONFIG_FASTBOOT_FLASH
 
@@ -36,6 +38,7 @@
 #define CONFIG_ANDROID_RECOVERY_PARTITION_MMC 2
 #define CONFIG_ANDROID_CACHE_PARTITION_MMC 6
 #define CONFIG_ANDROID_DATA_PARTITION_MMC 4
+#define CONFIG_ANDROID_MISC_PARTITION_MMC 8
 
 #define CONFIG_CMD_BOOTA
 #define CONFIG_SUPPORT_RAW_INITRD
@@ -51,7 +54,10 @@
 
 
 #define CONFIG_USB_FASTBOOT_BUF_ADDR   CONFIG_SYS_LOAD_ADDR
+#ifdef CONFIG_FASTBOOT_STORAGE_NAND
+#define CONFIG_USB_FASTBOOT_BUF_SIZE   0x25000000
+#else
 #define CONFIG_USB_FASTBOOT_BUF_SIZE   0x19000000
-
+#endif
 
 #endif
diff --git a/include/configs/picosom-imx6ul.h b/include/configs/picosom-imx6ul.h
index d0f1526..7c96376 100644
--- a/include/configs/picosom-imx6ul.h
+++ b/include/configs/picosom-imx6ul.h
@@ -330,7 +330,7 @@
 #define CONFIG_ENV_SPI_MAX_HZ		CONFIG_SF_DEFAULT_SPEED
 #elif defined(CONFIG_ENV_IS_IN_NAND)
 #undef CONFIG_ENV_SIZE
-#define CONFIG_ENV_OFFSET		(60 << 20)
+#define CONFIG_ENV_OFFSET		(37 << 20)
 #define CONFIG_ENV_SECT_SIZE		(128 << 10)
 #define CONFIG_ENV_SIZE			CONFIG_ENV_SECT_SIZE
 #endif
diff --git a/include/fsl_fastboot.h b/include/fsl_fastboot.h
index 5a38d99..8301f33 100644
--- a/include/fsl_fastboot.h
+++ b/include/fsl_fastboot.h
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2010-2015 Freescale Semiconductor, Inc.
+ * Copyright (C) 2010-2016 Freescale Semiconductor, Inc.
  *
  * SPDX-License-Identifier:	GPL-2.0+
  */
@@ -33,11 +33,22 @@
 #define FASTBOOT_MMC_USER_PARTITION_ID  0
 #define FASTBOOT_MMC_NONE_PARTITION_ID -1
 
+#ifdef CONFIG_BRILLO_SUPPORT
+#define FASTBOOT_PARTITION_BOOT_A "boot_a"
+#define FASTBOOT_PARTITION_RECOVERY "recovery"
+#define FASTBOOT_PARTITION_SYSTEM_A "system_a"
+#define FASTBOOT_PARTITION_BOOTLOADER "bootloader"
+#define FASTBOOT_PARTITION_DATA "data"
+#define FASTBOOT_PARTITION_BOOT_B "boot_b"
+#define FASTBOOT_PARTITION_SYSTEM_B "system_b"
+#define FASTBOOT_PARTITION_MISC "misc"
+#else
 #define FASTBOOT_PARTITION_BOOT "boot"
 #define FASTBOOT_PARTITION_RECOVERY "recovery"
 #define FASTBOOT_PARTITION_SYSTEM "system"
 #define FASTBOOT_PARTITION_BOOTLOADER "bootloader"
 #define FASTBOOT_PARTITION_DATA "data"
+#endif
 
 enum {
     DEV_SATA,
@@ -147,6 +158,7 @@ void fastboot_flash_dump_ptn(void);
 
 /* Check the board special boot mode reboot to fastboot mode. */
 int fastboot_check_and_clean_flag(void);
+int fastboot_check_and_clean_command(void);
 
 /* Set the flag which reboot to fastboot mode*/
 void fastboot_enable_flag(void);
@@ -169,4 +181,6 @@ void save_parts_values(struct fastboot_ptentry *ptn,
 int check_parts_values(struct fastboot_ptentry *ptn);
 #endif /*CONFIG_FASTBOOT_STORAGE_NAND*/
 
+int fastboot_tx_write_str(const char *buffer);
+
 #endif /* FSL_FASTBOOT_H */
diff --git a/include/recovery.h b/include/recovery.h
index 1e0492a..bd3d010 100644
--- a/include/recovery.h
+++ b/include/recovery.h
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2010-2014 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright (C) 2010-2016 Freescale Semiconductor, Inc. All Rights Reserved.
  *
  * SPDX-License-Identifier:	GPL-2.0+
  */
@@ -14,6 +14,7 @@ struct reco_envs {
 
 void check_recovery_mode(void);
 int recovery_check_and_clean_flag(void);
+int recovery_check_and_clean_command(void);
 int check_recovery_cmd_file(void);
 void board_recovery_setup(void);
 
-- 
2.10.1


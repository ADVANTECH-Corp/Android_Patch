diff --git a/drivers/fastboot/fb_fsl/fb_fsl_command.c b-ORG-bak/drivers/fastboot/fb_fsl/fb_fsl_command.c
index 5cf3bd8..824c3d4 100644
--- a/drivers/fastboot/fb_fsl/fb_fsl_command.c
+++ b-ORG-bak/drivers/fastboot/fb_fsl/fb_fsl_command.c
@@ -831,6 +831,18 @@ static void flash(char *cmd, char *response)
 #if defined(CONFIG_FASTBOOT_LOCK)
 	if (strncmp(cmd, "gpt", 3) == 0) {
 		int gpt_valid = 0;
+		int status, mmc_no;
+		struct blk_desc *dev_desc;
+		mmc_no = fastboot_devinfo.dev_id;
+		dev_desc = blk_get_dev("mmc", mmc_no);
+		if (dev_desc) {
+			if (dev_desc->part_type != PART_TYPE_EFI)
+				dev_desc->part_type = PART_TYPE_EFI;
+		}
+		else {
+			fastboot_fail("", response);
+			return;
+		}
 		gpt_valid = partition_table_valid();
 		/* If gpt is valid, load partitons table into memory.
 		   So if the next command is "fastboot reboot bootloader",
diff --git a/lib/trusty/ql-tipc/keymaster.c b-ORG-bak/lib/trusty/ql-tipc/keymaster.c
index b4fa8ca..6b83db3 100644
--- a/lib/trusty/ql-tipc/keymaster.c
+++ b-ORG-bak/lib/trusty/ql-tipc/keymaster.c
@@ -398,6 +398,10 @@ end:
 int trusty_set_attestation_key(const uint8_t *key, uint32_t key_size,
                                keymaster_algorithm_t algorithm)
 {
+    if (!initialized) {
+        trusty_error("Keymaster TIPC client not initialized!\n");
+        return -1;
+    }
     return trusty_send_attestation_data(KM_SET_ATTESTATION_KEY, key, key_size,
                                         algorithm);
 }
@@ -406,6 +410,10 @@ int trusty_append_attestation_cert_chain(const uint8_t *cert,
                                          uint32_t cert_size,
                                          keymaster_algorithm_t algorithm)
 {
+    if (!initialized) {
+        trusty_error("Keymaster TIPC client not initialized!\n");
+        return -1;
+    }
     return trusty_send_attestation_data(KM_APPEND_ATTESTATION_CERT_CHAIN,
                                         cert, cert_size, algorithm);
 }
@@ -413,6 +421,10 @@ int trusty_append_attestation_cert_chain(const uint8_t *cert,
 int trusty_set_attestation_key_enc(const uint8_t *key, uint32_t key_size,
                                keymaster_algorithm_t algorithm)
 {
+    if (!initialized) {
+        trusty_error("Keymaster TIPC client not initialized!\n");
+        return -1;
+    }
     return trusty_send_attestation_data(KM_SET_ATTESTATION_KEY_ENC, key, key_size,
                                         algorithm);
 }
@@ -421,6 +433,10 @@ int trusty_append_attestation_cert_chain_enc(const uint8_t *cert,
                                          uint32_t cert_size,
                                          keymaster_algorithm_t algorithm)
 {
+    if (!initialized) {
+        trusty_error("Keymaster TIPC client not initialized!\n");
+        return -1;
+    }
     return trusty_send_attestation_data(KM_APPEND_ATTESTATION_CERT_CHAIN_ENC,
                                         cert, cert_size, algorithm);
 }
@@ -501,6 +517,11 @@ int trusty_get_mppubk(uint8_t *mppubk, uint32_t *size)
     int rc = TRUSTY_ERR_GENERIC;
     struct km_get_mppubk_resp resp;
 
+    if (!initialized) {
+        trusty_error("Keymaster TIPC client not initialized!\n");
+        return -1;
+    }
+
     rc = km_send_request(KM_GET_MPPUBK, NULL, 0);
     if (rc < 0) {
         trusty_error("%s: failed (%d) to send km mppubk request\n", __func__, rc);
@@ -532,6 +553,11 @@ int trusty_verify_secure_unlock(uint8_t *unlock_credential,
     uint8_t *req = NULL;
     uint32_t req_size = 0;
 
+    if (!initialized) {
+        trusty_error("Keymaster TIPC client not initialized!\n");
+        return -1;
+    }
+
     struct km_secure_unlock_data secure_unlock_data = {
         .serial_size = serial_size,
         .serial_data = serial,

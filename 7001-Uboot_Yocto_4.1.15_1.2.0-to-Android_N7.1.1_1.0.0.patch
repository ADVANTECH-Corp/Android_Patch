From 0266f39c99fa4d62af7117b431a05b0a88419fc5 Mon Sep 17 00:00:00 2001
From: clayderhua <clayderhua@gmail.com>
Date: Tue, 9 May 2017 14:10:37 +0800
Subject: [PATCH] android patch

---
 .checkpatch.conf                                   |   23 +
 .travis.yml                                        |  220 ++++
 arch/arm/cpu/armv7/mx6/Kconfig                     |   10 +
 arch/arm/cpu/armv7/mx6/clock.c                     |   20 +-
 arch/arm/cpu/armv7/mx6/soc.c                       |   78 +-
 arch/arm/cpu/armv7/mx7/soc.c                       |   57 +-
 arch/arm/imx-common/cpu.c                          |    4 +-
 arch/arm/imx-common/timer.c                        |    9 +-
 arch/arm/include/asm/arch-imx/cpu.h                |    3 +-
 arch/arm/include/asm/arch-mx6/crm_regs.h           |  102 +-
 arch/arm/include/asm/arch-mx6/imx-regs.h           |   18 +-
 arch/arm/include/asm/arch-mx6/mx6-pins.h           |    4 +-
 arch/arm/include/asm/arch-mx6/mx6ull_pins.h        | 1062 ++++++++++++++++++++
 board/freescale/common/recovery.c                  |    2 +-
 board/freescale/mx6qarm2/mt128x64mx32.cfg          |   19 +-
 board/freescale/mx6qarm2/mx6qarm2.c                |  256 +++++
 board/freescale/mx6qsabreauto/mx6qsabreauto.c      |    7 +-
 board/freescale/mx6qsabreauto/plugin.S             |    6 +
 board/freescale/mx6sabresd/mx6qp.cfg               |   16 +-
 board/freescale/mx6sabresd/mx6sabresd.c            |    7 +-
 board/freescale/mx6sabresd/plugin.S                |   24 +-
 board/freescale/mx6slevk/mx6slevk.c                |    8 +-
 board/freescale/mx6sxsabreauto/mx6sxsabreauto.c    |    8 +-
 board/freescale/mx6sxsabresd/mx6sxsabresd.c        |    7 +-
 board/freescale/mx6ul_14x14_evk/mx6ul_14x14_evk.c  |    2 +
 board/freescale/mx6ull_ddr3_arm2/Kconfig           |   12 +
 board/freescale/mx6ull_ddr3_arm2/Makefile          |   10 +
 board/freescale/mx6ull_ddr3_arm2/imximage.cfg      |  114 +++
 .../freescale/mx6ull_ddr3_arm2/mx6ull_ddr3_arm2.c  |  947 +++++++++++++++++
 board/freescale/mx6ull_ddr3_arm2/plugin.S          |  137 +++
 board/freescale/mx7dsabresd/mx7dsabresd.c          |    5 +-
 common/Makefile                                    |    1 +
 common/autoboot.c                                  |    4 +-
 common/cmd_fsl_caam.c                              |  108 ++
 common/cmd_read.c                                  |    4 +-
 common/image-android.c                             |   41 +
 common/image-android.c.orig                        |  157 +++
 common/usb_storage.c                               |    4 +-
 configs/mx6qarm2_pop_lpddr2_revb_defconfig         |    2 +-
 configs/mx6ul_14x14_evk_android_defconfig          |    5 -
 configs/mx6ul_14x14_evk_brillo_defconfig           |    5 +
 configs/mx6ul_14x14_evk_ddr_eol_android_defconfig  |    5 -
 configs/mx6ul_14x14_evk_nand_defconfig             |    5 +
 configs/mx6ull_ddr3_arm2_defconfig                 |    9 +
 configs/mx6ull_ddr3_arm2_emmc_defconfig            |    9 +
 configs/mx6ull_ddr3_arm2_nand_defconfig            |    9 +
 configs/mx6ull_ddr3_arm2_qspi1_defconfig           |    9 +
 configs/mx6ull_ddr3_arm2_spinor_defconfig          |    9 +
 drivers/crypto/Makefile                            |    1 +
 drivers/crypto/fsl_caam.c                          |  459 +++++++++
 drivers/crypto/fsl_caam_internal.h                 |  401 ++++++++
 drivers/misc/mxc_ocotp.c                           |   43 +-
 drivers/misc/mxc_ocotp.c.orig                      |  339 +++++++
 drivers/mmc/mmc_write.c                            |    2 +-
 drivers/usb/gadget/Makefile                        |    3 +
 drivers/usb/gadget/bcb.c                           |  177 ++++
 drivers/usb/gadget/bcb.h                           |   38 +
 drivers/usb/gadget/bootctrl.c                      |  346 +++++++
 drivers/usb/gadget/bootctrl.h                      |   37 +
 drivers/usb/gadget/command.c                       |  158 +++
 drivers/usb/gadget/f_fastboot.c                    |  413 +++++++-
 drivers/usb/gadget/fastboot_lock_unlock.c          |  359 +++++++
 drivers/usb/gadget/fastboot_lock_unlock.h          |   68 ++
 include/common.h                                   |    4 +
 include/configs/mx6qarm2.h                         |   54 +-
 include/configs/mx6qarm2_android.h                 |   83 ++
 include/configs/mx6sabre_common.h                  |    2 +-
 include/configs/mx6sabreandroid_common.h           |   28 +-
 include/configs/mx6slevk.h                         |    4 +-
 include/configs/mx6slevkandroid.h                  |   11 +-
 include/configs/mx6sx_arm2.h                       |    2 +-
 include/configs/mx6sxsabreauto.h                   |    2 +-
 include/configs/mx6sxsabreautoandroid.h            |   28 +-
 include/configs/mx6sxsabresd.h                     |    4 +-
 include/configs/mx6sxsabresdandroid.h              |   26 +-
 include/configs/mx6ul_14x14_evk.h                  |    9 +-
 include/configs/mx6ul_14x14_evk_android.h          |    3 +-
 include/configs/mx6ul_14x14_evk_brillo.h           |   20 +-
 include/configs/mx6ul_arm2.h                       |    6 +-
 include/configs/mx6ull_ddr3_arm2.h                 |   73 ++
 include/configs/mx7d_12x12_ddr3_arm2.h             |    6 +-
 include/configs/mx7d_arm2.h                        |    2 +-
 include/configs/mx7dsabresd.h                      |    2 +-
 include/configs/mx7dsabresdandroid.h               |   11 +-
 include/fsl_caam.h                                 |   74 ++
 include/fsl_fastboot.h                             |   38 +-
 include/mmc.h                                      |    7 +-
 include/recovery.h                                 |    6 +-
 88 files changed, 6662 insertions(+), 270 deletions(-)
 create mode 100644 .checkpatch.conf
 create mode 100644 .travis.yml
 create mode 100644 arch/arm/include/asm/arch-mx6/mx6ull_pins.h
 create mode 100644 board/freescale/mx6ull_ddr3_arm2/Kconfig
 create mode 100644 board/freescale/mx6ull_ddr3_arm2/Makefile
 create mode 100644 board/freescale/mx6ull_ddr3_arm2/imximage.cfg
 create mode 100644 board/freescale/mx6ull_ddr3_arm2/mx6ull_ddr3_arm2.c
 create mode 100644 board/freescale/mx6ull_ddr3_arm2/plugin.S
 create mode 100644 common/cmd_fsl_caam.c
 create mode 100644 common/image-android.c.orig
 delete mode 100644 configs/mx6ul_14x14_evk_android_defconfig
 create mode 100644 configs/mx6ul_14x14_evk_brillo_defconfig
 delete mode 100644 configs/mx6ul_14x14_evk_ddr_eol_android_defconfig
 create mode 100644 configs/mx6ul_14x14_evk_nand_defconfig
 create mode 100644 configs/mx6ull_ddr3_arm2_defconfig
 create mode 100644 configs/mx6ull_ddr3_arm2_emmc_defconfig
 create mode 100644 configs/mx6ull_ddr3_arm2_nand_defconfig
 create mode 100644 configs/mx6ull_ddr3_arm2_qspi1_defconfig
 create mode 100644 configs/mx6ull_ddr3_arm2_spinor_defconfig
 create mode 100644 drivers/crypto/fsl_caam.c
 create mode 100644 drivers/crypto/fsl_caam_internal.h
 create mode 100644 drivers/misc/mxc_ocotp.c.orig
 create mode 100644 drivers/usb/gadget/bcb.c
 create mode 100644 drivers/usb/gadget/bcb.h
 create mode 100644 drivers/usb/gadget/bootctrl.c
 create mode 100644 drivers/usb/gadget/bootctrl.h
 create mode 100644 drivers/usb/gadget/command.c
 create mode 100644 drivers/usb/gadget/fastboot_lock_unlock.c
 create mode 100644 drivers/usb/gadget/fastboot_lock_unlock.h
 create mode 100644 include/configs/mx6qarm2_android.h
 create mode 100644 include/configs/mx6ull_ddr3_arm2.h
 create mode 100644 include/fsl_caam.h

diff --git a/.checkpatch.conf b/.checkpatch.conf
new file mode 100644
index 0000000..35167e1
--- /dev/null
+++ b/.checkpatch.conf
@@ -0,0 +1,23 @@
+# Not Linux, so don't expect a Linux tree.
+--no-tree
+
+# Temporary for false positive in checkpatch
+--ignore COMPLEX_MACRO
+
+# For CONFIG_SYS_I2C_NOPROBES
+--ignore MULTISTATEMENT_MACRO_USE_DO_WHILE
+
+# For simple_strtoul
+--ignore CONSIDER_KSTRTO
+
+# For min/max
+--ignore MINMAX
+
+# enable more tests
+--strict
+
+# Not Linux, so we don't recommend usleep_range() over udelay()
+--ignore USLEEP_RANGE
+
+# Ignore networking block comment style
+--ignore NETWORKING_BLOCK_COMMENT_STYLE
diff --git a/.travis.yml b/.travis.yml
new file mode 100644
index 0000000..4e20e09
--- /dev/null
+++ b/.travis.yml
@@ -0,0 +1,220 @@
+# Copyright Roger Meier <r.meier@siemens.com>
+# SPDX-License-Identifier:	GPL-2.0+
+
+# build U-Boot on Travis CI - https://travis-ci.org/
+
+language: c
+
+cache:
+ - apt
+
+install:
+ # install U-Boot build dependencies
+ - sudo apt-get install -qq cppcheck sloccount sparse bc libsdl-dev build-essential
+ # install latest device tree compiler
+ - git clone --depth=1 https://git.kernel.org/pub/scm/utils/dtc/dtc.git /tmp/dtc
+ - make -j4 -C /tmp/dtc
+ # prepare buildman environment
+ - export BUILDMAN_ROOT="root:"
+ - export BUILDMAN_MIPS="mips:"
+ - export BUILDMAN_PPC="ppc:"
+ - export BUILDMAN_ARM="arm:"
+ - export BUILDMAN_SANDBOX="sandbox:"
+ - echo -e "[toolchain]\n${BUILDMAN_ROOT} /\n" > ~/.buildman
+ - echo -e "${BUILDMAN_MIPS} /opt/eldk-5.4/mips/sysroots/i686-eldk-linux/usr/bin/mips32-linux/\n" >> ~/.buildman
+ - echo -e "${BUILDMAN_PPC} /opt/eldk-5.4/powerpc/sysroots/i686-eldk-linux/usr/bin/powerpc-linux/\n" >> ~/.buildman
+ - echo -e "${BUILDMAN_ARM} /opt/eldk-5.4/armv5te/sysroots/i686-eldk-linux/usr/bin/armv5te-linux-gnueabi/\n" >> ~/.buildman
+ - echo -e "${BUILDMAN_SANDBOX} /usr/bin/gcc\n" >> ~/.buildman
+ - export BUILDMAN_ALIAS="x86:"
+ - export BUILDMAN_ALIAS_ARM="arm:"
+ - echo -e "\n\n[toolchain-alias]\n${BUILDMAN_ALIAS} i386\n" >> ~/.buildman
+ - echo -e "${BUILDMAN_ALIAS_ARM} armv5te\n" >> ~/.buildman
+ - cat ~/.buildman
+
+env:
+  global:
+    - PATH=/tmp/dtc:$PATH
+    - BUILD_DIR=build
+    - CROSS_COMPILE=""
+    - HOSTCC="cc"
+    - HOSTCXX="c++"
+    - TEST_CONFIG_CMD=""
+
+before_script:
+  # install toolchains based on INSTALL_TOOLCHAIN} variable
+  - if [[ "${INSTALL_TOOLCHAIN}" == *arm* ]]; then wget ftp://ftp.denx.de/pub/eldk/5.4/targets/armv5te/eldk-eglibc-i686-arm-toolchain-gmae-5.4.sh ; fi
+  - if [[ "${INSTALL_TOOLCHAIN}" == *arm* ]]; then sh eldk-eglibc-i686-arm-toolchain-gmae-5.4.sh -y ; fi
+  - if [[ "${INSTALL_TOOLCHAIN}" == *arm* ]]; then ls -al /opt/eldk-5.4/armv5te/sysroots/i686-eldk-linux/usr/bin/armv5te-linux-gnueabi ; fi
+  - if [[ "${INSTALL_TOOLCHAIN}" == *avr32* ]]; then ./tools/buildman/buildman --fetch-arch avr32 ; fi
+  - if [[ "${INSTALL_TOOLCHAIN}" == *i386* ]]; then ./tools/buildman/buildman sandbox --fetch-arch i386 ; fi
+  - if [[ "${INSTALL_TOOLCHAIN}" == *m68k* ]]; then ./tools/buildman/buildman --fetch-arch m68k ; fi
+  - if [[ "${INSTALL_TOOLCHAIN}" == *mips* ]]; then wget ftp://ftp.denx.de/pub/eldk/5.4/targets/mips/eldk-eglibc-i686-mips-toolchain-gmae-5.4.sh ; fi
+  - if [[ "${INSTALL_TOOLCHAIN}" == *mips* ]]; then sh eldk-eglibc-i686-mips-toolchain-gmae-5.4.sh -y ; fi
+  - if [[ "${INSTALL_TOOLCHAIN}" == *ppc* ]]; then wget ftp://ftp.denx.de/pub/eldk/5.4/targets/powerpc/eldk-eglibc-i686-powerpc-toolchain-gmae-5.4.sh ; fi
+  - if [[ "${INSTALL_TOOLCHAIN}" == *ppc* ]]; then sh eldk-eglibc-i686-powerpc-toolchain-gmae-5.4.sh -y ; fi
+
+script:
+ # the execution sequence for each test
+ - echo ${TEST_CONFIG_CMD}
+ - ${TEST_CONFIG_CMD}
+ - echo ${TEST_CMD}
+ - ${TEST_CMD}
+
+matrix:
+  include:
+  # we need to build by vendor due to 50min time limit for builds
+  # each env setting here is a dedicated build
+    - env:
+        - TEST_CMD="./MAKEALL -a arm -v atmel"
+          INSTALL_TOOLCHAIN="arm"
+          CROSS_COMPILE="/opt/eldk-5.4/armv5te/sysroots/i686-eldk-linux/usr/bin/armv5te-linux-gnueabi/arm-linux-gnueabi-"
+    - env:
+        - TEST_CMD="./MAKEALL -a arm -v denx"
+          INSTALL_TOOLCHAIN="arm"
+          CROSS_COMPILE="/opt/eldk-5.4/armv5te/sysroots/i686-eldk-linux/usr/bin/armv5te-linux-gnueabi/arm-linux-gnueabi-"
+    - env:
+        - TEST_CMD="./MAKEALL -a arm -v freescale"
+          INSTALL_TOOLCHAIN="arm"
+          CROSS_COMPILE="/opt/eldk-5.4/armv5te/sysroots/i686-eldk-linux/usr/bin/armv5te-linux-gnueabi/arm-linux-gnueabi-"
+    - env:
+        - TEST_CMD="./MAKEALL -a arm -v siemens"
+          INSTALL_TOOLCHAIN="arm"
+          CROSS_COMPILE="/opt/eldk-5.4/armv5te/sysroots/i686-eldk-linux/usr/bin/armv5te-linux-gnueabi/arm-linux-gnueabi-"
+    - env:
+        - TEST_CMD="./MAKEALL -a arm -v ti"
+          INSTALL_TOOLCHAIN="arm"
+          CROSS_COMPILE="/opt/eldk-5.4/armv5te/sysroots/i686-eldk-linux/usr/bin/armv5te-linux-gnueabi/arm-linux-gnueabi-"
+    - env:
+        - TEST_CONFIG_CMD="make sandbox_defconfig"
+          TEST_CMD="make -j4"
+          HOSTCC  = "gcc"
+          HOSTCXX  = "g++"
+    - env:
+        - TEST_CONFIG_CMD="make sandbox_defconfig"
+          TEST_CMD="make -j4"
+          HOSTCC  = "clang"
+          HOSTCXX  = "clang++"
+    - env:
+        - TEST_CMD="./MAKEALL -a mips"
+          INSTALL_TOOLCHAIN="mips"
+          CROSS_COMPILE="/opt/eldk-5.4/mips/sysroots/i686-eldk-linux/usr/bin/mips32-linux/mips-linux-"
+    - env:
+        - TEST_CONFIG_CMD="tools/buildman/buildman --list-tool-chains"
+          TEST_CMD="tools/buildman/buildman --list-error-boards arm1136"
+          INSTALL_TOOLCHAIN="arm"
+    - env:
+        - TEST_CONFIG_CMD="tools/buildman/buildman --list-tool-chains"
+          TEST_CMD="tools/buildman/buildman --list-error-boards arm1176"
+          INSTALL_TOOLCHAIN="arm"
+    - env:
+        - TEST_CONFIG_CMD="tools/buildman/buildman --list-tool-chains"
+          TEST_CMD="tools/buildman/buildman --list-error-boards arm720t"
+          INSTALL_TOOLCHAIN="arm"
+    - env:
+        - TEST_CONFIG_CMD="tools/buildman/buildman --list-tool-chains"
+          TEST_CMD="tools/buildman/buildman --list-error-boards arm920t"
+          INSTALL_TOOLCHAIN="arm"
+    - env:
+        - TEST_CONFIG_CMD="tools/buildman/buildman --list-tool-chains"
+          TEST_CMD="tools/buildman/buildman --list-error-boards atmel -x avr32"
+          INSTALL_TOOLCHAIN="arm"
+    - env:
+        - TEST_CONFIG_CMD="tools/buildman/buildman --list-tool-chains"
+          TEST_CMD="tools/buildman/buildman --list-error-boards avr32"
+          INSTALL_TOOLCHAIN="avr32"
+    - env:
+        - TEST_CONFIG_CMD="tools/buildman/buildman --list-tool-chains"
+          TEST_CMD="tools/buildman/buildman --list-error-boards davinci"
+          INSTALL_TOOLCHAIN="arm"
+    - env:
+        - TEST_CONFIG_CMD="tools/buildman/buildman --list-tool-chains"
+          TEST_CMD="tools/buildman/buildman --list-error-boards denx"
+          INSTALL_TOOLCHAIN="arm"
+    - env:
+        - TEST_CONFIG_CMD="tools/buildman/buildman --list-tool-chains"
+          TEST_CMD="tools/buildman/buildman --list-error-boards freescale -x powerpc,m68k,aarch64"
+          INSTALL_TOOLCHAIN="arm"
+    - env:
+        - TEST_CONFIG_CMD="tools/buildman/buildman --list-tool-chains"
+          TEST_CMD="tools/buildman/buildman --list-error-boards freescale -x arm,m68k,aarch64"
+          INSTALL_TOOLCHAIN="ppc"
+    - env:
+        - TEST_CONFIG_CMD="tools/buildman/buildman --list-tool-chains"
+          TEST_CMD="tools/buildman/buildman --list-error-boards sandbox x86"
+          INSTALL_TOOLCHAIN="i386"
+    - env:
+        - TEST_CONFIG_CMD="tools/buildman/buildman --list-tool-chains"
+          TEST_CMD="tools/buildman/buildman --list-error-boards kirkwood"
+          INSTALL_TOOLCHAIN="arm"
+    - env:
+        - TEST_CONFIG_CMD="tools/buildman/buildman --list-tool-chains"
+          TEST_CMD="tools/buildman/buildman --list-error-boards m68k"
+          INSTALL_TOOLCHAIN="m68k"
+    - env:
+        - TEST_CONFIG_CMD="tools/buildman/buildman --list-tool-chains"
+          TEST_CMD="tools/buildman/buildman mips"
+          INSTALL_TOOLCHAIN="mips"
+    - env:
+        - TEST_CONFIG_CMD="tools/buildman/buildman --list-tool-chains"
+          TEST_CMD="tools/buildman/buildman mpc512x"
+          INSTALL_TOOLCHAIN="ppc"
+    - env:
+        - TEST_CONFIG_CMD="tools/buildman/buildman --list-tool-chains"
+          TEST_CMD="tools/buildman/buildman mpc5xx"
+          INSTALL_TOOLCHAIN="ppc"
+    - env:
+        - TEST_CONFIG_CMD="tools/buildman/buildman --list-tool-chains"
+          TEST_CMD="tools/buildman/buildman mpc5xxx"
+          INSTALL_TOOLCHAIN="ppc"
+    - env:
+        - TEST_CONFIG_CMD="tools/buildman/buildman --list-tool-chains"
+          TEST_CMD="tools/buildman/buildman mpc8260"
+          INSTALL_TOOLCHAIN="ppc"
+    - env:
+        - TEST_CONFIG_CMD="tools/buildman/buildman --list-tool-chains"
+          TEST_CMD="tools/buildman/buildman mpc83xx"
+          INSTALL_TOOLCHAIN="ppc"
+    - env:
+        - TEST_CONFIG_CMD="tools/buildman/buildman --list-tool-chains"
+          TEST_CMD="tools/buildman/buildman mpc85xx"
+          INSTALL_TOOLCHAIN="ppc"
+    - env:
+        - TEST_CONFIG_CMD="tools/buildman/buildman --list-tool-chains"
+          TEST_CMD="tools/buildman/buildman mpc86xx"
+          INSTALL_TOOLCHAIN="ppc"
+    - env:
+        - TEST_CONFIG_CMD="tools/buildman/buildman --list-tool-chains"
+          TEST_CMD="tools/buildman/buildman mpc8xx"
+          INSTALL_TOOLCHAIN="ppc"
+    - env:
+        - TEST_CONFIG_CMD="tools/buildman/buildman --list-tool-chains"
+          TEST_CMD="tools/buildman/buildman --list-error-boards siemens"
+          INSTALL_TOOLCHAIN="arm"
+    - env:
+        - TEST_CONFIG_CMD="tools/buildman/buildman --list-tool-chains"
+          TEST_CMD="tools/buildman/buildman --list-error-boards ti"
+          INSTALL_TOOLCHAIN="arm"
+
+    # QA jobs for code analytics
+    # static code analysis with cppcheck (we can add --enable=all later)
+    - env:
+        - TEST_CMD="cppcheck --force --quiet --inline-suppr ."
+    # search for TODO within source tree
+    - env:
+        - TEST_CMD="grep -r TODO ."
+    # search for FIXME within source tree
+    - env:
+        - TEST_CMD="grep -r FIXME ."
+    # search for HACK within source tree and ignore HACKKIT board
+    - env:
+        - TEST_CMD="grep -r HACK . | grep -v HACKKIT"
+      script:
+        - grep -r HACK . | grep -v HACKKIT
+    # some statistics about the code base
+    - env:
+        - TEST_CMD="sloccount ."
+
+notifications:
+  email: false
+
+# TODO make it perfect ;-r
diff --git a/arch/arm/cpu/armv7/mx6/Kconfig b/arch/arm/cpu/armv7/mx6/Kconfig
index 2161a5e..5e82078 100644
--- a/arch/arm/cpu/armv7/mx6/Kconfig
+++ b/arch/arm/cpu/armv7/mx6/Kconfig
@@ -28,9 +28,18 @@ config MX6SX
 config MX6UL
 	bool
 
+config MX6ULL
+	bool
+	select MX6UL
+
 choice
 	prompt "MX6 board select"
 
+config TARGET_MX6ULL_DDR3_ARM2
+	bool "Support mx6ull_ddr3_arm2"
+	select CPU_V7
+	select MX6ULL
+
 config TARGET_SECOMX6
 	bool "Support secomx6 boards"
 	select CPU_V7
@@ -41,5 +50,6 @@ config SYS_SOC
 	default "mx6"
 
 source "board/seco/Kconfig"
+source "board/freescale/mx6ull_ddr3_arm2/Kconfig"
 
 endif
diff --git a/arch/arm/cpu/armv7/mx6/clock.c b/arch/arm/cpu/armv7/mx6/clock.c
index 5f0037a..1cc910b 100644
--- a/arch/arm/cpu/armv7/mx6/clock.c
+++ b/arch/arm/cpu/armv7/mx6/clock.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2010-2015 Freescale Semiconductor, Inc.
+ * Copyright (C) 2010-2016 Freescale Semiconductor, Inc.
  *
  * SPDX-License-Identifier:	GPL-2.0+
  */
@@ -96,7 +96,13 @@ void enable_usboh3_clk(unsigned char enable)
 #if defined(CONFIG_FEC_MXC) && !defined(CONFIG_MX6SX)
 void enable_enet_clk(unsigned char enable)
 {
-#ifdef CONFIG_MX6UL
+#ifdef CONFIG_MX6ULL
+	u32 mask = MXC_CCM_CCGR0_ENET_CLK_ENABLE_MASK;
+	if (enable)
+		setbits_le32(&imx_ccm->CCGR0, mask);
+	else
+		clrbits_le32(&imx_ccm->CCGR0, mask);
+#elif defined(CONFIG_MX6UL)
 	u32 mask = MXC_CCM_CCGR3_ENET_CLK_ENABLE_MASK;
 	/* Set AHB clk, since enet clock is sourced from AHB and IPG */
 	/* ROM has set AHB, just leave here empty */
@@ -1164,6 +1170,15 @@ void hab_caam_clock_enable(unsigned char enable)
 {
 	u32 reg;
 
+#if defined(CONFIG_MX6ULL)
+	/* CG5, DCP clock */
+	reg = __raw_readl(&imx_ccm->CCGR0);
+	if (enable)
+		reg |= MXC_CCM_CCGR0_DCP_CLK_MASK;
+	else
+		reg &= ~MXC_CCM_CCGR0_DCP_CLK_MASK;
+	__raw_writel(reg, &imx_ccm->CCGR0);
+#else
 	/* CG4 ~ CG6, CAAM clocks */
 	reg = __raw_readl(&imx_ccm->CCGR0);
 	if (enable)
@@ -1175,6 +1190,7 @@ void hab_caam_clock_enable(unsigned char enable)
 			MXC_CCM_CCGR0_CAAM_WRAPPER_ACLK_MASK |
 			MXC_CCM_CCGR0_CAAM_SECURE_MEM_MASK);
 	__raw_writel(reg, &imx_ccm->CCGR0);
+#endif
 
 	/* EMI slow clk */
 	reg = __raw_readl(&imx_ccm->CCGR6);
diff --git a/arch/arm/cpu/armv7/mx6/soc.c b/arch/arm/cpu/armv7/mx6/soc.c
index c725fca..9a4228c 100644
--- a/arch/arm/cpu/armv7/mx6/soc.c
+++ b/arch/arm/cpu/armv7/mx6/soc.c
@@ -2,7 +2,7 @@
  * (C) Copyright 2007
  * Sascha Hauer, Pengutronix
  *
- * (C) Copyright 2009-2015 Freescale Semiconductor, Inc.
+ * (C) Copyright 2009-2016 Freescale Semiconductor, Inc.
  *
  * SPDX-License-Identifier:	GPL-2.0+
  */
@@ -110,13 +110,13 @@ u32 __weak get_board_rev(void)
 void init_aips(void)
 {
 	struct aipstz_regs *aips1, *aips2;
-#ifdef CONFIG_MX6SX
+#if defined(CONFIG_MX6SX) || defined(CONFIG_MX6ULL)
 	struct aipstz_regs *aips3;
 #endif
 
 	aips1 = (struct aipstz_regs *)AIPS1_BASE_ADDR;
 	aips2 = (struct aipstz_regs *)AIPS2_BASE_ADDR;
-#ifdef CONFIG_MX6SX
+#if defined(CONFIG_MX6SX) || defined(CONFIG_MX6ULL)
 	aips3 = (struct aipstz_regs *)AIPS3_CONFIG_BASE_ADDR;
 #endif
 
@@ -145,7 +145,7 @@ void init_aips(void)
 	writel(0x00000000, &aips2->opacr3);
 	writel(0x00000000, &aips2->opacr4);
 
-#ifdef CONFIG_MX6SX
+#if defined(CONFIG_MX6SX) || defined(CONFIG_MX6ULL)
 	/*
 	 * Set all MPROTx to be non-bufferable, trusted for R/W,
 	 * not forced to user-mode.
@@ -469,7 +469,7 @@ int arch_cpu_init(void)
 		set_ahb_rate(132000000);
 #endif
 
-#if defined(CONFIG_MX6UL)
+#if !defined(CONFIG_MX6ULL) && defined(CONFIG_MX6UL)
 	if (is_soc_rev(CHIP_REV_1_0) == 0) {
 		/*
 		 * According to the design team's requirement on i.MX6UL,
@@ -489,6 +489,19 @@ int arch_cpu_init(void)
 	}
 #endif
 
+#ifdef CONFIG_MX6ULL
+	/*
+	 * GPBIT[1:0] is suggested to set to 2'b11:
+	 * 2'b00 : always PUP100K
+	 * 2'b01 : PUP100K when PMIC_ON_REQ or SOC_NOT_FAIL
+	 * 2'b10 : always disable PUP100K
+	 * 2'b11 : PDN100K when SOC_FAIL, PUP100K when SOC_NOT_FAIL
+	 * register offset is different from i.MX6UL, since
+	 * i.MX6UL is fixed by ECO.
+	 */
+	writel(readl(SNVS_LP_BASE_ADDR) | 0x3, SNVS_LP_BASE_ADDR);
+#endif
+
 	/* Set perclk to source from OSC 24MHz */
 #if defined(CONFIG_MX6SL)
 	set_preclk_from_osc();
@@ -741,7 +754,8 @@ void s_init(void)
 	u32 mask528;
 	u32 reg, periph1, periph2;
 
-	if (is_cpu_type(MXC_CPU_MX6SX) || is_cpu_type(MXC_CPU_MX6UL))
+	if (is_cpu_type(MXC_CPU_MX6SX) || is_cpu_type(MXC_CPU_MX6UL) ||
+	    is_cpu_type(MXC_CPU_MX6ULL))
 		return;
 
 	/* Due to hardware limitation, on MX6Q we need to gate/ungate all PFDs
@@ -1041,53 +1055,23 @@ void v7_outer_cache_disable(void)
 #endif /* !CONFIG_SYS_L2CACHE_OFF */
 
 #ifdef CONFIG_FSL_FASTBOOT
-
-#ifdef CONFIG_ANDROID_RECOVERY
-#define ANDROID_RECOVERY_BOOT  (1 << 7)
-/* check if the recovery bit is set by kernel, it can be set by kernel
- * issue a command '# reboot recovery' */
-int recovery_check_and_clean_flag(void)
+#ifdef CONFIG_RESET_CAUSE
+#define ANDROID_NORMAL_BOOT     6
+#define ANDROID_BOOT_REASON_OFFSET  6
+int read_boot_reason()
 {
-	int flag_set = 0;
 	u32 reg;
 	reg = readl(SNVS_BASE_ADDR + SNVS_LPGPR);
-
-	flag_set = !!(reg & ANDROID_RECOVERY_BOOT);
-    printf("check_and_clean: reg %x, flag_set %d\n", reg, flag_set);
-	/* clean it in case looping infinite here.... */
-	if (flag_set) {
-		reg &= ~ANDROID_RECOVERY_BOOT;
-		writel(reg, SNVS_BASE_ADDR + SNVS_LPGPR);
-	}
-
-	return flag_set;
+	if (reg & (1 << ANDROID_NORMAL_BOOT))
+		return ANDROID_NORMAL_BOOT;
+	return 0;
 }
-#endif /*CONFIG_ANDROID_RECOVERY*/
 
-#define ANDROID_FASTBOOT_BOOT  (1 << 8)
-/* check if the recovery bit is set by kernel, it can be set by kernel
- * issue a command '# reboot fastboot' */
-int fastboot_check_and_clean_flag(void)
+void clear_boot_reason()
 {
-	int flag_set = 0;
 	u32 reg;
-
-	reg = readl(SNVS_BASE_ADDR + SNVS_LPGPR);
-
-	flag_set = !!(reg & ANDROID_FASTBOOT_BOOT);
-
-	/* clean it in case looping infinite here.... */
-	if (flag_set) {
-		reg &= ~ANDROID_FASTBOOT_BOOT;
-		writel(reg, SNVS_BASE_ADDR + SNVS_LPGPR);
-	}
-
-	return flag_set;
-}
-
-void fastboot_enable_flag(void)
-{
-	setbits_le32(SNVS_BASE_ADDR + SNVS_LPGPR,
-		ANDROID_FASTBOOT_BOOT);
+	reg &= ~(1 << ANDROID_BOOT_REASON_OFFSET);
+	writel(reg, SNVS_BASE_ADDR + SNVS_LPGPR);
 }
+#endif
 #endif /*CONFIG_FSL_FASTBOOT*/
diff --git a/arch/arm/cpu/armv7/mx7/soc.c b/arch/arm/cpu/armv7/mx7/soc.c
index d718e67..bda4828 100644
--- a/arch/arm/cpu/armv7/mx7/soc.c
+++ b/arch/arm/cpu/armv7/mx7/soc.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2014-2015 Freescale Semiconductor, Inc.
+ * Copyright (C) 2014-2016 Freescale Semiconductor, Inc.
  *
  * SPDX-License-Identifier:	GPL-2.0+
  */
@@ -466,57 +466,24 @@ void reset_misc(void)
 }
 
 #ifdef CONFIG_FSL_FASTBOOT
-
-#ifdef CONFIG_ANDROID_RECOVERY
-#define ANDROID_RECOVERY_BOOT	(1 << 7)
-/*
- * check if the recovery bit is set by kernel, it can be set by kernel
- * issue a command '# reboot recovery'
- */
-int recovery_check_and_clean_flag(void)
+#ifdef CONFIG_RESET_CAUSE
+#define ANDROID_NORMAL_BOOT     6
+#define ANDROID_BOOT_REASON_OFFSET  6
+int read_boot_reason()
 {
-	int flag_set = 0;
 	u32 reg;
 	reg = readl(SNVS_BASE_ADDR + SNVS_LPGPR);
-
-	flag_set = !!(reg & ANDROID_RECOVERY_BOOT);
-	printf("check_and_clean: reg %x, flag_set %d\n", reg, flag_set);
-	/* clean it in case looping infinite here.... */
-	if (flag_set) {
-		reg &= ~ANDROID_RECOVERY_BOOT;
-		writel(reg, SNVS_BASE_ADDR + SNVS_LPGPR);
-	}
-
-	return flag_set;
+	if (reg & (1 << ANDROID_NORMAL_BOOT))
+		return ANDROID_NORMAL_BOOT;
+	return 0;
 }
-#endif /*CONFIG_ANDROID_RECOVERY*/
 
-#define ANDROID_FASTBOOT_BOOT  (1 << 8)
-/*
- * check if the recovery bit is set by kernel, it can be set by kernel
- * issue a command '# reboot fastboot'
- */
-int fastboot_check_and_clean_flag(void)
+void clear_boot_reason()
 {
-	int flag_set = 0;
 	u32 reg;
-
-	reg = readl(SNVS_BASE_ADDR + SNVS_LPGPR);
-
-	flag_set = !!(reg & ANDROID_FASTBOOT_BOOT);
-
-	/* clean it in case looping infinite here.... */
-	if (flag_set) {
-		reg &= ~ANDROID_FASTBOOT_BOOT;
-		writel(reg, SNVS_BASE_ADDR + SNVS_LPGPR);
-	}
-
-	return flag_set;
+	reg &= ~(1 << ANDROID_BOOT_REASON_OFFSET);
+	writel(reg, SNVS_BASE_ADDR + SNVS_LPGPR);
 }
+#endif
 
-void fastboot_enable_flag(void)
-{
-	setbits_le32(SNVS_BASE_ADDR + SNVS_LPGPR,
-		ANDROID_FASTBOOT_BOOT);
-}
 #endif /*CONFIG_FSL_FASTBOOT*/
diff --git a/arch/arm/imx-common/cpu.c b/arch/arm/imx-common/cpu.c
index 8eb6a5a..0afa93f 100644
--- a/arch/arm/imx-common/cpu.c
+++ b/arch/arm/imx-common/cpu.c
@@ -2,7 +2,7 @@
  * (C) Copyright 2007
  * Sascha Hauer, Pengutronix
  *
- * (C) Copyright 2009-2015 Freescale Semiconductor, Inc.
+ * (C) Copyright 2009-2016 Freescale Semiconductor, Inc.
  *
  * SPDX-License-Identifier:	GPL-2.0+
  */
@@ -153,6 +153,8 @@ const char *get_imx_type(u32 imxtype)
 		return "6SX";   /* SoloX version of the mx6 */
 	case MXC_CPU_MX6UL:
 		return "6UL";	/* UL version of the mx6 */
+	case MXC_CPU_MX6ULL:
+		return "6ULL";	/* ULL version of the mx6 */
 	case MXC_CPU_MX51:
 		return "51";
 	case MXC_CPU_MX53:
diff --git a/arch/arm/imx-common/timer.c b/arch/arm/imx-common/timer.c
index 6fea6fe..e1b6f01 100644
--- a/arch/arm/imx-common/timer.c
+++ b/arch/arm/imx-common/timer.c
@@ -2,7 +2,7 @@
  * (C) Copyright 2007
  * Sascha Hauer, Pengutronix
  *
- * (C) Copyright 2009-2015 Freescale Semiconductor, Inc.
+ * (C) Copyright 2009-2016 Freescale Semiconductor, Inc.
  *
  * SPDX-License-Identifier:	GPL-2.0+
  */
@@ -46,7 +46,7 @@ static inline int gpt_has_clk_source_osc(void)
 	if (((is_cpu_type(MXC_CPU_MX6Q) || is_cpu_type(MXC_CPU_MX6D)) &&
 	     (is_soc_rev(CHIP_REV_1_0) > 0)) || is_cpu_type(MXC_CPU_MX6DL) ||
 	      is_cpu_type(MXC_CPU_MX6SOLO) || is_cpu_type(MXC_CPU_MX6SX) ||
-	      is_cpu_type(MXC_CPU_MX6UL))
+	      is_cpu_type(MXC_CPU_MX6UL) || is_cpu_type(MXC_CPU_MX6ULL))
 		return 1;
 
 	return 0;
@@ -110,12 +110,13 @@ int timer_init(void)
 	if (gpt_has_clk_source_osc()) {
 		i |= GPTCR_CLKSOURCE_OSC | GPTCR_TEN;
 
-		/* For DL/S, SX, UL, set 24Mhz OSC Enable bit and prescaler */
+		/* For DL/S, SX, UL, ULL set 24Mhz OSC Enable bit and prescaler */
 		if (is_cpu_type(MXC_CPU_MX6DL) ||
 		    is_cpu_type(MXC_CPU_MX6SOLO) ||
 		    is_cpu_type(MXC_CPU_MX6SX) ||
 		    is_cpu_type(MXC_CPU_MX7D) ||
-		    is_cpu_type(MXC_CPU_MX6UL)) {
+		    is_cpu_type(MXC_CPU_MX6UL) ||
+		    is_cpu_type(MXC_CPU_MX6ULL)) {
 			i |= GPTCR_24MEN;
 
 			/* Produce 3Mhz clock */
diff --git a/arch/arm/include/asm/arch-imx/cpu.h b/arch/arm/include/asm/arch-imx/cpu.h
index d198906..4ea743b 100644
--- a/arch/arm/include/asm/arch-imx/cpu.h
+++ b/arch/arm/include/asm/arch-imx/cpu.h
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2014-2015 Freescale Semiconductor, Inc.
+ * Copyright (C) 2014-2016 Freescale Semiconductor, Inc.
  *
  * SPDX-License-Identifier:	GPL-2.0+
  */
@@ -11,6 +11,7 @@
 #define MXC_CPU_MX6SX		0x62
 #define MXC_CPU_MX6Q		0x63
 #define MXC_CPU_MX6UL		0x64
+#define MXC_CPU_MX6ULL		0x65
 #define MXC_CPU_MX6SOLO		0x66 /* dummy */
 #define MXC_CPU_MX6D		0x67
 #define MXC_CPU_MX7D		0x72
diff --git a/arch/arm/include/asm/arch-mx6/crm_regs.h b/arch/arm/include/asm/arch-mx6/crm_regs.h
index 0c79842..724ee62 100644
--- a/arch/arm/include/asm/arch-mx6/crm_regs.h
+++ b/arch/arm/include/asm/arch-mx6/crm_regs.h
@@ -1,5 +1,5 @@
 /*
- * Copyright 2011-2015 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2011-2016 Freescale Semiconductor, Inc. All Rights Reserved.
  *
  * SPDX-License-Identifier:	GPL-2.0+
  */
@@ -430,7 +430,16 @@ struct mxc_ccm_reg {
 #define MXC_CCM_CSCDR1_UART_CLK_PODF_OFFSET		0
 
 /* Define the bits in register CS1CDR */
-#ifndef CONFIG_MX6UL
+#if defined(CONFIG_MX6UL) && !defined(CONFIG_MX6ULL)
+#define MXC_CCM_CS1CDR_SAI3_CLK_PRED_MASK		(0x7 << 22)
+#define MXC_CCM_CS1CDR_SAI3_CLK_PRED_OFFSET		22
+#define MXC_CCM_CS1CDR_SAI3_CLK_PODF_MASK		(0x3F << 16)
+#define MXC_CCM_CS1CDR_SAI3_CLK_PODF_OFFSET		16
+#define MXC_CCM_CS1CDR_SAI1_CLK_PRED_MASK		(0x7 << 6)
+#define MXC_CCM_CS1CDR_SAI1_CLK_PRED_OFFSET		6
+#define MXC_CCM_CS1CDR_SAI1_CLK_PODF_MASK		0x3F
+#define MXC_CCM_CS1CDR_SAI1_CLK_PODF_OFFSET		0
+#else
 #define MXC_CCM_CS1CDR_ESAI_CLK_PODF_MASK		(0x3F << 25)
 #define MXC_CCM_CS1CDR_ESAI_CLK_PODF_OFFSET		25
 #define MXC_CCM_CS1CDR_ESAI_CLK_PRED_MASK		(0x3 << 9)
@@ -443,15 +452,6 @@ struct mxc_ccm_reg {
 #define MXC_CCM_CS1CDR_SSI1_CLK_PRED_OFFSET		6
 #define MXC_CCM_CS1CDR_SSI1_CLK_PODF_MASK		0x3F
 #define MXC_CCM_CS1CDR_SSI1_CLK_PODF_OFFSET		0
-#else
-#define MXC_CCM_CS1CDR_SAI3_CLK_PRED_MASK		(0x7 << 22)
-#define MXC_CCM_CS1CDR_SAI3_CLK_PRED_OFFSET		22
-#define MXC_CCM_CS1CDR_SAI3_CLK_PODF_MASK		(0x3F << 16)
-#define MXC_CCM_CS1CDR_SAI3_CLK_PODF_OFFSET		16
-#define MXC_CCM_CS1CDR_SAI1_CLK_PRED_MASK		(0x7 << 6)
-#define MXC_CCM_CS1CDR_SAI1_CLK_PRED_OFFSET		6
-#define MXC_CCM_CS1CDR_SAI1_CLK_PODF_MASK		0x3F
-#define MXC_CCM_CS1CDR_SAI1_CLK_PODF_OFFSET		0
 #endif
 
 /* Define the bits in register CS2CDR */
@@ -530,7 +530,14 @@ struct mxc_ccm_reg {
 #endif
 
 /* Define the bits in register CHSCCDR */
-#ifdef CONFIG_MX6UL
+#ifdef CONFIG_MX6ULL
+#define MXC_CCM_CHSCCDR_EPDC_PRE_CLK_SEL_MASK		(0x7 << 15)
+#define MXC_CCM_CHSCCDR_EPDC_PRE_CLK_SEL_OFFSET		15
+#define MXC_CCM_CHSCCDR_EPDC_PODF_MASK			(0x7 << 12)
+#define MXC_CCM_CHSCCDR_EPDC_PODF_OFFSET			12
+#define MXC_CCM_CHSCCDR_EPDC_CLK_SEL_MASK		(0x7 << 9)
+#define MXC_CCM_CHSCCDR_EPDC_CLK_SEL_OFFSET		9
+#elif defined(CONFIG_MX6UL)
 #define MXC_CCM_CHSCCDR_SIM_PRE_CLK_SEL_MASK		(0x7 << 15)
 #define MXC_CCM_CHSCCDR_SIM_PRE_CLK_SEL_OFFSET		15
 #define MXC_CCM_CHSCCDR_SIM_PODF_MASK			(0x7 << 12)
@@ -733,12 +740,20 @@ struct mxc_ccm_reg {
 #define MXC_CCM_CCGR0_APBHDMA_MASK			(3 << MXC_CCM_CCGR0_APBHDMA_OFFSET)
 #define MXC_CCM_CCGR0_ASRC_OFFSET			6
 #define MXC_CCM_CCGR0_ASRC_MASK				(3 << MXC_CCM_CCGR0_ASRC_OFFSET)
+
+#ifdef CONFIG_MX6ULL
+#define MXC_CCM_CCGR0_DCP_CLK_OFFSET		10
+#define MXC_CCM_CCGR0_DCP_CLK_MASK		(3 << MXC_CCM_CCGR0_DCP_CLK_OFFSET)
+#define MXC_CCM_CCGR0_ENET_CLK_ENABLE_OFFSET		12
+#define MXC_CCM_CCGR0_ENET_CLK_ENABLE_MASK		(3 << MXC_CCM_CCGR0_ENET_CLK_ENABLE_OFFSET)
+#else
 #define MXC_CCM_CCGR0_CAAM_SECURE_MEM_OFFSET		8
 #define MXC_CCM_CCGR0_CAAM_SECURE_MEM_MASK		(3 << MXC_CCM_CCGR0_CAAM_SECURE_MEM_OFFSET)
 #define MXC_CCM_CCGR0_CAAM_WRAPPER_ACLK_OFFSET		10
 #define MXC_CCM_CCGR0_CAAM_WRAPPER_ACLK_MASK		(3 << MXC_CCM_CCGR0_CAAM_WRAPPER_ACLK_OFFSET)
 #define MXC_CCM_CCGR0_CAAM_WRAPPER_IPG_OFFSET		12
 #define MXC_CCM_CCGR0_CAAM_WRAPPER_IPG_MASK		(3 << MXC_CCM_CCGR0_CAAM_WRAPPER_IPG_OFFSET)
+#endif
 #define MXC_CCM_CCGR0_CAN1_OFFSET			14
 #define MXC_CCM_CCGR0_CAN1_MASK				(3 << MXC_CCM_CCGR0_CAN1_OFFSET)
 #define MXC_CCM_CCGR0_CAN1_SERIAL_OFFSET		16
@@ -839,17 +854,24 @@ struct mxc_ccm_reg {
 #define MXC_CCM_CCGR1_GPIO5_CLK_ENABLE_MASK		3 << (MXC_CCM_CCGR1_GPIO5_CLK_ENABLE_OFFSET)
 #endif
 
-#ifndef CONFIG_MX6SX
+#if !defined(CONFIG_MX6SX) && !defined(CONFIG_MX6UL)
 #define MXC_CCM_CCGR2_HDMI_TX_IAHBCLK_OFFSET		0
 #define MXC_CCM_CCGR2_HDMI_TX_IAHBCLK_MASK		(3 << MXC_CCM_CCGR2_HDMI_TX_IAHBCLK_OFFSET)
-#else
-#define MXC_CCM_CCGR2_CSI_OFFSET			2
-#define MXC_CCM_CCGR2_CSI_MASK				(3 << MXC_CCM_CCGR2_CSI_OFFSET)
-#endif
-#if !defined(CONFIG_MX6SX) && !defined(CONFIG_MX6UL)
 #define MXC_CCM_CCGR2_HDMI_TX_ISFRCLK_OFFSET		4
 #define MXC_CCM_CCGR2_HDMI_TX_ISFRCLK_MASK		(3 << MXC_CCM_CCGR2_HDMI_TX_ISFRCLK_OFFSET)
 #endif
+#if defined(CONFIG_MX6ULL)
+#define MXC_CCM_CCGR2_ESAI_CLK_OFFSET		0
+#define MXC_CCM_CCGR2_ESAI_CLK_MASK		(3 << MXC_CCM_CCGR2_ESAI_CLK_OFFSET)
+#define MXC_CCM_CCGR2_IOMUXC_SNVS_CLK_OFFSET		4
+#define MXC_CCM_CCGR2_IOMUXC_SNVS_CLK_MASK		(3 << MXC_CCM_CCGR2_IOMUXC_SNVS_CLK_OFFSET)
+#endif
+
+#if defined(CONFIG_MX6SX) || defined(CONFIG_MX6UL)
+#define MXC_CCM_CCGR2_CSI_OFFSET			2
+#define MXC_CCM_CCGR2_CSI_MASK				(3 << MXC_CCM_CCGR2_CSI_OFFSET)
+#endif
+
 #define MXC_CCM_CCGR2_I2C1_SERIAL_OFFSET		6
 #define MXC_CCM_CCGR2_I2C1_SERIAL_MASK			(3 << MXC_CCM_CCGR2_I2C1_SERIAL_OFFSET)
 #define MXC_CCM_CCGR2_I2C2_SERIAL_OFFSET		8
@@ -887,8 +909,13 @@ struct mxc_ccm_reg {
 #ifdef CONFIG_MX6UL
 #define MXC_CCM_CCGR3_UART5_CLK_ENABLE_OFFSET			2
 #define MXC_CCM_CCGR3_UART5_CLK_ENABLE_MASK			(3 << MXC_CCM_CCGR3_UART5_CLK_ENABLE_OFFSET)
+#ifdef CONFIG_MX6ULL
+#define MXC_CCM_CCGR3_EPDC_CLK_ENABLE_OFFSET			4
+#define MXC_CCM_CCGR3_EPDC_CLK_ENABLE_MASK			(3 << MXC_CCM_CCGR3_EPDC_CLK_ENABLE_OFFSET)
+#else
 #define MXC_CCM_CCGR3_ENET_CLK_ENABLE_OFFSET			4
 #define MXC_CCM_CCGR3_ENET_CLK_ENABLE_MASK			(3 << MXC_CCM_CCGR3_ENET_CLK_ENABLE_OFFSET)
+#endif
 #define MXC_CCM_CCGR3_UART6_CLK_ENABLE_OFFSET			6
 #define MXC_CCM_CCGR3_UART6_CLK_ENABLE_MASK			(3 << MXC_CCM_CCGR3_UART6_CLK_ENABLE_OFFSET)
 #define MXC_CCM_CCGR3_UART6_CLK_ENABLE_OFFSET			6
@@ -924,17 +951,19 @@ struct mxc_ccm_reg {
 #define MXC_CCM_CCGR3_IPU2_IPU_DI1_OFFSET			10
 #define MXC_CCM_CCGR3_IPU2_IPU_DI1_MASK				(3 << MXC_CCM_CCGR3_IPU2_IPU_DI1_OFFSET)
 #endif
-#define MXC_CCM_CCGR3_LDB_DI0_OFFSET				12
-#define MXC_CCM_CCGR3_LDB_DI0_MASK				(3 << MXC_CCM_CCGR3_LDB_DI0_OFFSET)
-#if defined(CONFIG_MX6SX) || defined(CONFIG_MX6UL)
+
+#define MXC_CCM_CCGR3_GPIO4_CLK_OFFSET				12
+#define MXC_CCM_CCGR3_GPIO4_CLK_MASK				(3 << MXC_CCM_CCGR3_GPIO4_CLK_OFFSET)
 #define MXC_CCM_CCGR3_QSPI1_OFFSET				14
 #define MXC_CCM_CCGR3_QSPI1_MASK				(3 << MXC_CCM_CCGR3_QSPI1_OFFSET)
-#else
+
+#define MXC_CCM_CCGR3_LDB_DI0_OFFSET				12
+#define MXC_CCM_CCGR3_LDB_DI0_MASK				(3 << MXC_CCM_CCGR3_LDB_DI0_OFFSET)
 #define MXC_CCM_CCGR3_LDB_DI1_OFFSET				14
 #define MXC_CCM_CCGR3_LDB_DI1_MASK				(3 << MXC_CCM_CCGR3_LDB_DI1_OFFSET)
 #define MXC_CCM_CCGR3_MIPI_CORE_CFG_OFFSET			16
 #define MXC_CCM_CCGR3_MIPI_CORE_CFG_MASK			(3 << MXC_CCM_CCGR3_MIPI_CORE_CFG_OFFSET)
-#endif
+
 #ifdef CONFIG_MX6UL
 #define MXC_CCM_CCGR3_WDOG1_CLK_ENABLE_OFFSET			16
 #define MXC_CCM_CCGR3_WDOG1_CLK_ENABLE_MASK			(3 << MXC_CCM_CCGR3_WDOG1_CLK_ENABLE_OFFSET)
@@ -963,14 +992,12 @@ struct mxc_ccm_reg {
 #define MXC_CCM_CCGR3_OCRAM_OFFSET				28
 #define MXC_CCM_CCGR3_OCRAM_MASK				(3 << MXC_CCM_CCGR3_OCRAM_OFFSET)
 #endif
-#ifndef CONFIG_MX6SX
-#ifdef CONFIG_MX6UL
-#define MXC_CCM_CCGR3_GPIO4_CLK_OFFSET				30
-#define MXC_CCM_CCGR3_GPIO4_CLK_MASK				(3 << MXC_CCM_CCGR3_GPIO4_CLK_OFFSET)
-#else
+#if !defined(CONFIG_MX6SX) && !defined(CONFIG_MX6UL)
 #define MXC_CCM_CCGR3_OPENVGAXICLK_OFFSET			30
 #define MXC_CCM_CCGR3_OPENVGAXICLK_MASK				(3 << MXC_CCM_CCGR3_OPENVGAXICLK_OFFSET)
-#endif
+#elif defined(CONFIG_MX6ULL)
+#define MXC_CCM_CCGR3_IOMUXC_SNVS_GPR_CLK_OFFSET			30
+#define MXC_CCM_CCGR3_IOMUXC_SNVS_GPR_CLK_MASK				(3 << MXC_CCM_CCGR3_IOMUXC_SNVS_GPR_CLK_OFFSET)
 #endif
 
 #define MXC_CCM_CCGR4_PCIE_OFFSET				0
@@ -1079,10 +1106,15 @@ struct mxc_ccm_reg {
 #define MXC_CCM_CCGR6_USDHC2_OFFSET		4
 #define MXC_CCM_CCGR6_USDHC2_MASK		(3 << MXC_CCM_CCGR6_USDHC2_OFFSET)
 #ifdef CONFIG_MX6UL
-#define MXC_CCM_CCGR6_BCH_OFFSET		6
-#define MXC_CCM_CCGR6_BCH_MASK			(3 << MXC_CCM_CCGR6_BCH_OFFSET)
-#define MXC_CCM_CCGR6_GPMI_OFFSET		8
-#define MXC_CCM_CCGR6_GPMI_MASK			(3 << MXC_CCM_CCGR6_GPMI_OFFSET)
+#ifdef CONFIG_MX6ULL
+#define MXC_CCM_CCGR6_IPMUX4_CLK_OFFSET		8
+#define MXC_CCM_CCGR6_IPMUX4_CLK_MASK			(3 << MXC_CCM_CCGR6_IPMUX4_CLK_OFFSET)
+#else
+#define MXC_CCM_CCGR6_SIM1_CLK_OFFSET		6
+#define MXC_CCM_CCGR6_SIM1_CLK_MASK			(3 << MXC_CCM_CCGR6_SIM1_CLK_OFFSET)
+#define MXC_CCM_CCGR6_SIM2_CLK_OFFSET		8
+#define MXC_CCM_CCGR6_SIM2_CLK_MASK			(3 << MXC_CCM_CCGR6_SIM2_CLK_OFFSET)
+#endif
 #else
 #define MXC_CCM_CCGR6_USDHC3_OFFSET		6
 #define MXC_CCM_CCGR6_USDHC3_MASK		(3 << MXC_CCM_CCGR6_USDHC3_OFFSET)
@@ -1094,6 +1126,10 @@ struct mxc_ccm_reg {
 #ifdef CONFIG_MX6UL
 #define MXC_CCM_CCGR6_PWM8_OFFSET		16
 #define MXC_CCM_CCGR6_PWM8_MASK			(3 << MXC_CCM_CCGR6_PWM8_OFFSET)
+#ifdef CONFIG_MX6ULL
+#define MXC_CCM_CCGR6_AIPS_TZ3_CLK_OFFSET		18
+#define MXC_CCM_CCGR6_AIPS_TZ3_CLK_MASK			(3 << MXC_CCM_CCGR6_AIPS_TZ3_CLK_OFFSET)
+#endif
 #define MXC_CCM_CCGR6_WDOG3_OFFSET		20
 #define MXC_CCM_CCGR6_WDOG3_MASK		(3 << MXC_CCM_CCGR6_WDOG3_OFFSET)
 #define MXC_CCM_CCGR6_ANADIG_OFFSET		22
diff --git a/arch/arm/include/asm/arch-mx6/imx-regs.h b/arch/arm/include/asm/arch-mx6/imx-regs.h
index 72a9374..73bb291 100644
--- a/arch/arm/include/asm/arch-mx6/imx-regs.h
+++ b/arch/arm/include/asm/arch-mx6/imx-regs.h
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2011-2015 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright (C) 2011-2016 Freescale Semiconductor, Inc. All Rights Reserved.
  *
  * SPDX-License-Identifier:	GPL-2.0+
  */
@@ -163,7 +163,11 @@
 
 #define UART1_BASE                  (ATZ1_BASE_ADDR + 0x20000)
 #if defined(CONFIG_MX6UL)
+#if defined(CONFIG_MX6ULL)
+#define ESAI1_BASE_ADDR             (ATZ1_BASE_ADDR + 0x24000)
+#else
 #define UART8_IPS_BASE_ADDR         (ATZ1_BASE_ADDR + 0x24000)
+#endif
 #define SAI1_BASE_ADDR              (ATZ1_BASE_ADDR + 0x28000)
 #define SAI2_BASE_ADDR              (ATZ1_BASE_ADDR + 0x2C000)
 #define SAI3_BASE_ADDR              (ATZ1_BASE_ADDR + 0x30000)
@@ -219,10 +223,12 @@
 #define GPC_BASE_ADDR               (AIPS1_OFF_BASE_ADDR + 0x5C000)
 #define IOMUXC_BASE_ADDR            (AIPS1_OFF_BASE_ADDR + 0x60000)
 #define IOMUXC_GPR_BASE_ADDR        (AIPS1_OFF_BASE_ADDR + 0x64000)
+
 #if defined(CONFIG_MX6SL)
 #define CSI_BASE_ADDR               (AIPS1_OFF_BASE_ADDR + 0x64000)
 #define SIPIX_BASE_ADDR             (AIPS1_OFF_BASE_ADDR + 0x68000)
 #define SDMA_PORT_HOST_BASE_ADDR    (AIPS1_OFF_BASE_ADDR + 0x6C000)
+#define EPDC_BASE_ADDR              (AIPS1_OFF_BASE_ADDR + 0x74000)
 
 #elif defined(CONFIG_MX6SX)
 #define CANFD1_BASE_ADDR            (AIPS1_OFF_BASE_ADDR + 0x68000)
@@ -243,8 +249,8 @@
 #define DCIC1_BASE_ADDR             (AIPS1_OFF_BASE_ADDR + 0x64000)
 #define DCIC2_BASE_ADDR             (AIPS1_OFF_BASE_ADDR + 0x68000)
 #define DMA_REQ_PORT_HOST_BASE_ADDR (AIPS1_OFF_BASE_ADDR + 0x6C000)
-#endif
 #define EPDC_BASE_ADDR              (AIPS1_OFF_BASE_ADDR + 0x74000)
+#endif
 
 #define AIPS2_ON_BASE_ADDR          (ATZ2_BASE_ADDR + 0x7C000)
 #define AIPS2_OFF_BASE_ADDR         (ATZ2_BASE_ADDR + 0x80000)
@@ -378,6 +384,14 @@
 #define PWM6_BASE_ADDR              (AIPS3_ARB_BASE_ADDR + 0xA8000)
 #define PWM7_BASE_ADDR              (AIPS3_ARB_BASE_ADDR + 0xAC000)
 #define PWM8_BASE_ADDR              (AIPS3_ARB_BASE_ADDR + 0xB0000)
+#elif defined(CONFIG_MX6ULL)
+#define AIPS3_CONFIG_BASE_ADDR      (AIPS3_ARB_BASE_ADDR + 0x7C000)
+#define DCP_BASE_ADDR      			(AIPS3_ARB_BASE_ADDR + 0x80000)
+#define RNGB_BASE_ADDR      		(AIPS3_ARB_BASE_ADDR + 0x84000)
+#define UART8_IPS_BASE_ADDR      	(AIPS3_ARB_BASE_ADDR + 0x88000)
+#define EPDC_BASE_ADDR              (AIPS3_ARB_BASE_ADDR + 0x8C000)
+#define IOMUXC_SNVS_BASE_ADDR       (AIPS3_ARB_BASE_ADDR + 0x90000)
+#define SNVS_GPR_BASE_ADDR       	(AIPS3_ARB_BASE_ADDR + 0x94000)
 #endif
 
 #define CHIP_REV_1_0                 0x10
diff --git a/arch/arm/include/asm/arch-mx6/mx6-pins.h b/arch/arm/include/asm/arch-mx6/mx6-pins.h
index 05b5b35..2363080 100644
--- a/arch/arm/include/asm/arch-mx6/mx6-pins.h
+++ b/arch/arm/include/asm/arch-mx6/mx6-pins.h
@@ -1,6 +1,6 @@
 /*
  * Copyright (C) 2013 Boundary Devices Inc.
- * Copyright (C) 2015 Freescale Semiconductor, Inc.
+ * Copyright (C) 2015-2016 Freescale Semiconductor, Inc.
  *
  * SPDX-License-Identifier:	GPL-2.0+
  */
@@ -38,6 +38,8 @@ enum {
 #include "mx6sl_pins.h"
 #elif defined(CONFIG_MX6SX)
 #include "mx6sx_pins.h"
+#elif defined(CONFIG_MX6ULL)
+#include "mx6ull_pins.h"
 #elif defined(CONFIG_MX6UL)
 #include "mx6ul_pins.h"
 #else
diff --git a/arch/arm/include/asm/arch-mx6/mx6ull_pins.h b/arch/arm/include/asm/arch-mx6/mx6ull_pins.h
new file mode 100644
index 0000000..8b62bd9
--- /dev/null
+++ b/arch/arm/include/asm/arch-mx6/mx6ull_pins.h
@@ -0,0 +1,1062 @@
+/*
+ * Copyright (C) 2014-2016 Freescale Semiconductor, Inc.
+ *
+ * SPDX-License-Identifier:     GPL-2.0+
+ */
+
+#ifndef __ASM_ARCH_IMX6ULL_PINS_H__
+#define __ASM_ARCH_IMX6ULL_PINS_H__
+
+#include <asm/imx-common/iomux-v3.h>
+
+enum {
+	/*
+	 * The TAMPER Pin can be used for GPIO, which depends on
+	 * TAMPER_PIN_DISABLE[1:0] settings.
+	 */
+	MX6_PAD_SNVS_TAMPER0__GPIO5_IO00                       = IOMUX_PAD(0x02A8, 0x001C, 5, 0x0000, 0, 0),
+	MX6_PAD_SNVS_TAMPER1__GPIO5_IO01                       = IOMUX_PAD(0x02AC, 0x0020, 5, 0x0000, 0, 0),
+	MX6_PAD_SNVS_TAMPER2__GPIO5_IO02                       = IOMUX_PAD(0x02B0, 0x0024, 5, 0x0000, 0, 0),
+	MX6_PAD_SNVS_TAMPER3__GPIO5_IO03                       = IOMUX_PAD(0x02B4, 0x0028, 5, 0x0000, 0, 0),
+	MX6_PAD_SNVS_TAMPER4__GPIO5_IO04                       = IOMUX_PAD(0x02B8, 0x002C, 5, 0x0000, 0, 0),
+	MX6_PAD_SNVS_TAMPER5__GPIO5_IO05                       = IOMUX_PAD(0x02BC, 0x0030, 5, 0x0000, 0, 0),
+	MX6_PAD_SNVS_TAMPER6__GPIO5_IO06                       = IOMUX_PAD(0x02C0, 0x0034, 5, 0x0000, 0, 0),
+	MX6_PAD_SNVS_TAMPER7__GPIO5_IO07                       = IOMUX_PAD(0x02C4, 0x0038, 5, 0x0000, 0, 0),
+	MX6_PAD_SNVS_TAMPER8__GPIO5_IO08                       = IOMUX_PAD(0x02C8, 0x003C, 5, 0x0000, 0, 0),
+	MX6_PAD_SNVS_TAMPER9__GPIO5_IO09                       = IOMUX_PAD(0x02CC, 0x0040, 5, 0x0000, 0, 0),
+
+	MX6_PAD_JTAG_MOD__SJC_MOD                             = IOMUX_PAD(0x02D0, 0x0044, 0, 0x0000, 0, 0),
+	MX6_PAD_JTAG_MOD__GPT2_CLK                            = IOMUX_PAD(0x02D0, 0x0044, 1, 0x05A0, 0, 0),
+	MX6_PAD_JTAG_MOD__SPDIF_OUT                           = IOMUX_PAD(0x02D0, 0x0044, 2, 0x0000, 0, 0),
+	MX6_PAD_JTAG_MOD__ENET1_REF_CLK_25M                   = IOMUX_PAD(0x02D0, 0x0044, 3, 0x0000, 0, 0),
+	MX6_PAD_JTAG_MOD__CCM_PMIC_RDY                        = IOMUX_PAD(0x02D0, 0x0044, 4, 0x04C0, 0, 0),
+	MX6_PAD_JTAG_MOD__GPIO1_IO10                          = IOMUX_PAD(0x02D0, 0x0044, 5, 0x0000, 0, 0),
+	MX6_PAD_JTAG_MOD__SDMA_EXT_EVENT00                    = IOMUX_PAD(0x02D0, 0x0044, 6, 0x0610, 0, 0),
+
+	MX6_PAD_JTAG_TMS__SJC_TMS                             = IOMUX_PAD(0x02D4, 0x0048, 0, 0x0000, 0, 0),
+	MX6_PAD_JTAG_TMS__GPT2_CAPTURE1                       = IOMUX_PAD(0x02D4, 0x0048, 1, 0x0598, 0, 0),
+	MX6_PAD_JTAG_TMS__SAI2_MCLK                           = IOMUX_PAD(0x02D4, 0x0048, 2, 0x05F0, 0, 0),
+	MX6_PAD_JTAG_TMS__CCM_CLKO1                           = IOMUX_PAD(0x02D4, 0x0048, 3, 0x0000, 0, 0),
+	MX6_PAD_JTAG_TMS__CCM_WAIT                            = IOMUX_PAD(0x02D4, 0x0048, 4, 0x0000, 0, 0),
+	MX6_PAD_JTAG_TMS__GPIO1_IO11                          = IOMUX_PAD(0x02D4, 0x0048, 5, 0x0000, 0, 0),
+	MX6_PAD_JTAG_TMS__SDMA_EXT_EVENT01                    = IOMUX_PAD(0x02D4, 0x0048, 6, 0x0614, 0, 0),
+	MX6_PAD_JTAG_TMS__EPIT1_OUT                           = IOMUX_PAD(0x02D4, 0x0048, 8, 0x0000, 0, 0),
+
+	MX6_PAD_JTAG_TDO__SJC_TDO                             = IOMUX_PAD(0x02D8, 0x004C, 0, 0x0000, 0, 0),
+	MX6_PAD_JTAG_TDO__GPT2_CAPTURE2                       = IOMUX_PAD(0x02D8, 0x004C, 1, 0x059C, 0, 0),
+	MX6_PAD_JTAG_TDO__SAI2_TX_SYNC                        = IOMUX_PAD(0x02D8, 0x004C, 2, 0x05FC, 0, 0),
+	MX6_PAD_JTAG_TDO__CCM_CLKO2                           = IOMUX_PAD(0x02D8, 0x004C, 3, 0x0000, 0, 0),
+	MX6_PAD_JTAG_TDO__CCM_STOP                            = IOMUX_PAD(0x02D8, 0x004C, 4, 0x0000, 0, 0),
+	MX6_PAD_JTAG_TDO__GPIO1_IO12                          = IOMUX_PAD(0x02D8, 0x004C, 5, 0x0000, 0, 0),
+	MX6_PAD_JTAG_TDO__MQS_RIGHT                           = IOMUX_PAD(0x02D8, 0x004C, 6, 0x0000, 0, 0),
+	MX6_PAD_JTAG_TDO__EPIT2_OUT                           = IOMUX_PAD(0x02D8, 0x004C, 8, 0x0000, 0, 0),
+
+	MX6_PAD_JTAG_TDI__SJC_TDI                             = IOMUX_PAD(0x02DC, 0x0050, 0, 0x0000, 0, 0),
+	MX6_PAD_JTAG_TDI__GPT2_COMPARE1                       = IOMUX_PAD(0x02DC, 0x0050, 1, 0x0000, 0, 0),
+	MX6_PAD_JTAG_TDI__SAI2_TX_BCLK                        = IOMUX_PAD(0x02DC, 0x0050, 2, 0x05F8, 0, 0),
+	MX6_PAD_JTAG_TDI__PWM6_OUT                            = IOMUX_PAD(0x02DC, 0x0050, 4, 0x0000, 0, 0),
+	MX6_PAD_JTAG_TDI__GPIO1_IO13                          = IOMUX_PAD(0x02DC, 0x0050, 5, 0x0000, 0, 0),
+	MX6_PAD_JTAG_TDI__MQS_LEFT                            = IOMUX_PAD(0x02DC, 0x0050, 6, 0x0000, 0, 0),
+	MX6_PAD_JTAG_TDI__SIM1_POWER_FAIL                     = IOMUX_PAD(0x02DC, 0x0050, 8, 0x0000, 0, 0),
+
+	MX6_PAD_JTAG_TCK__SJC_TCK                             = IOMUX_PAD(0x02E0, 0x0054, 0, 0x0000, 0, 0),
+	MX6_PAD_JTAG_TCK__GPT2_COMPARE2                       = IOMUX_PAD(0x02E0, 0x0054, 1, 0x0000, 0, 0),
+	MX6_PAD_JTAG_TCK__SAI2_RX_DATA                        = IOMUX_PAD(0x02E0, 0x0054, 2, 0x05F4, 0, 0),
+	MX6_PAD_JTAG_TCK__PWM7_OUT                            = IOMUX_PAD(0x02E0, 0x0054, 4, 0x0000, 0, 0),
+	MX6_PAD_JTAG_TCK__GPIO1_IO14                          = IOMUX_PAD(0x02E0, 0x0054, 5, 0x0000, 0, 0),
+	MX6_PAD_JTAG_TCK__SIM2_POWER_FAIL                     = IOMUX_PAD(0x02E0, 0x0054, 8, 0x0000, 0, 0),
+
+	MX6_PAD_JTAG_TRST_B__SJC_TRSTB                        = IOMUX_PAD(0x02E4, 0x0058, 0, 0x0000, 0, 0),
+	MX6_PAD_JTAG_TRST_B__GPT2_COMPARE3                    = IOMUX_PAD(0x02E4, 0x0058, 1, 0x0000, 0, 0),
+	MX6_PAD_JTAG_TRST_B__SAI2_TX_DATA                     = IOMUX_PAD(0x02E4, 0x0058, 2, 0x0000, 0, 0),
+	MX6_PAD_JTAG_TRST_B__PWM8_OUT                         = IOMUX_PAD(0x02E4, 0x0058, 4, 0x0000, 0, 0),
+	MX6_PAD_JTAG_TRST_B__GPIO1_IO15                       = IOMUX_PAD(0x02E4, 0x0058, 5, 0x0000, 0, 0),
+	MX6_PAD_JTAG_TRST_B__CAAM_RNG_OSC_OBS                 = IOMUX_PAD(0x02E4, 0x0058, 8, 0x0000, 0, 0),
+
+	MX6_PAD_GPIO1_IO00__I2C2_SCL                          = IOMUX_PAD(0x02E8, 0x005C, IOMUX_CONFIG_SION | 0, 0x05AC, 1, 0),
+	MX6_PAD_GPIO1_IO00__GPT1_CAPTURE1                     = IOMUX_PAD(0x02E8, 0x005C, 1, 0x058C, 0, 0),
+	MX6_PAD_GPIO1_IO00__ANATOP_OTG1_ID                    = IOMUX_PAD(0x02E8, 0x005C, 2, 0x04B8, 0, 0),
+	MX6_PAD_GPIO1_IO00__ENET1_REF_CLK1                    = IOMUX_PAD(0x02E8, 0x005C, 3, 0x0574, 0, 0),
+	MX6_PAD_GPIO1_IO00__MQS_RIGHT                         = IOMUX_PAD(0x02E8, 0x005C, 4, 0x0000, 0, 0),
+	MX6_PAD_GPIO1_IO00__GPIO1_IO00                        = IOMUX_PAD(0x02E8, 0x005C, 5, 0x0000, 0, 0),
+	MX6_PAD_GPIO1_IO00__ENET1_1588_EVENT0_IN              = IOMUX_PAD(0x02E8, 0x005C, 6, 0x0000, 0, 0),
+	MX6_PAD_GPIO1_IO00__SRC_SYSTEM_RESET                  = IOMUX_PAD(0x02E8, 0x005C, 7, 0x0000, 0, 0),
+	MX6_PAD_GPIO1_IO00__WDOG3_WDOG_B                      = IOMUX_PAD(0x02E8, 0x005C, 8, 0x0000, 0, 0),
+
+	MX6_PAD_GPIO1_IO01__I2C2_SDA                          = IOMUX_PAD(0x02EC, 0x0060, IOMUX_CONFIG_SION | 0, 0x05B0, 1, 0),
+	MX6_PAD_GPIO1_IO01__GPT1_COMPARE1                     = IOMUX_PAD(0x02EC, 0x0060, 1, 0x0000, 0, 0),
+	MX6_PAD_GPIO1_IO01__USB_OTG1_OC                       = IOMUX_PAD(0x02EC, 0x0060, 2, 0x0664, 0, 0),
+	MX6_PAD_GPIO1_IO01__ENET2_REF_CLK2                    = IOMUX_PAD(0x02EC, 0x0060, 3, 0x057C, 0, 0),
+	MX6_PAD_GPIO1_IO01__MQS_LEFT                          = IOMUX_PAD(0x02EC, 0x0060, 4, 0x0000, 0, 0),
+	MX6_PAD_GPIO1_IO01__GPIO1_IO01                        = IOMUX_PAD(0x02EC, 0x0060, 5, 0x0000, 0, 0),
+	MX6_PAD_GPIO1_IO01__ENET1_1588_EVENT0_OUT             = IOMUX_PAD(0x02EC, 0x0060, 6, 0x0000, 0, 0),
+	MX6_PAD_GPIO1_IO01__SRC_EARLY_RESET                   = IOMUX_PAD(0x02EC, 0x0060, 7, 0x0000, 0, 0),
+	MX6_PAD_GPIO1_IO01__WDOG1_WDOG_B                      = IOMUX_PAD(0x02EC, 0x0060, 8, 0x0000, 0, 0),
+
+	MX6_PAD_GPIO1_IO02__I2C1_SCL                          = IOMUX_PAD(0x02F0, 0x0064, IOMUX_CONFIG_SION | 0, 0x05A4, 0, 0),
+	MX6_PAD_GPIO1_IO02__GPT1_COMPARE2                     = IOMUX_PAD(0x02F0, 0x0064, 1, 0x0000, 0, 0),
+	MX6_PAD_GPIO1_IO02__USB_OTG2_PWR                      = IOMUX_PAD(0x02F0, 0x0064, 2, 0x0000, 0, 0),
+	MX6_PAD_GPIO1_IO02__ENET1_REF_CLK_25M                 = IOMUX_PAD(0x02F0, 0x0064, 3, 0x0000, 0, 0),
+	MX6_PAD_GPIO1_IO02__USDHC1_WP                         = IOMUX_PAD(0x02F0, 0x0064, 4, 0x066C, 0, 0),
+	MX6_PAD_GPIO1_IO02__GPIO1_IO02                        = IOMUX_PAD(0x02F0, 0x0064, 5, 0x0000, 0, 0),
+	MX6_PAD_GPIO1_IO02__SDMA_EXT_EVENT00                  = IOMUX_PAD(0x02F0, 0x0064, 6, 0x0610, 1, 0),
+	MX6_PAD_GPIO1_IO02__SRC_ANY_PU_RESET                  = IOMUX_PAD(0x02F0, 0x0064, 7, 0x0000, 0, 0),
+	MX6_PAD_GPIO1_IO02__UART1_DCE_TX                      = IOMUX_PAD(0x02F0, 0x0064, 8, 0x0000, 0, 0),
+	MX6_PAD_GPIO1_IO02__UART1_DTE_RX                      = IOMUX_PAD(0x02F0, 0x0064, 8, 0x0624, 0, 0),
+
+	MX6_PAD_GPIO1_IO03__I2C1_SDA                          = IOMUX_PAD(0x02F4, 0x0068, IOMUX_CONFIG_SION | 0, 0x05A8, 1, 0),
+	MX6_PAD_GPIO1_IO03__GPT1_COMPARE3                     = IOMUX_PAD(0x02F4, 0x0068, 1, 0x0000, 0, 0),
+	MX6_PAD_GPIO1_IO03__USB_OTG2_OC                       = IOMUX_PAD(0x02F4, 0x0068, 2, 0x0660, 0, 0),
+	MX6_PAD_GPIO1_IO03__USDHC1_CD_B                       = IOMUX_PAD(0x02F4, 0x0068, 4, 0x0668, 0, 0),
+	MX6_PAD_GPIO1_IO03__GPIO1_IO03                        = IOMUX_PAD(0x02F4, 0x0068, 5, 0x0000, 0, 0),
+	MX6_PAD_GPIO1_IO03__CCM_DI0_EXT_CLK                   = IOMUX_PAD(0x02F4, 0x0068, 6, 0x0000, 0, 0),
+	MX6_PAD_GPIO1_IO03__SRC_TESTER_ACK                    = IOMUX_PAD(0x02F4, 0x0068, 7, 0x0000, 0, 0),
+	MX6_PAD_GPIO1_IO03__UART1_DCE_RX                      = IOMUX_PAD(0x02F4, 0x0068, 8, 0x0624, 1, 0),
+	MX6_PAD_GPIO1_IO03__UART1_DTE_TX                      = IOMUX_PAD(0x02F4, 0x0068, 8, 0x0000, 0, 0),
+
+	MX6_PAD_GPIO1_IO04__ENET1_REF_CLK1                    = IOMUX_PAD(0x02F8, 0x006C, 0, 0x0574, 1, 0),
+	MX6_PAD_GPIO1_IO04__PWM3_OUT                          = IOMUX_PAD(0x02F8, 0x006C, 1, 0x0000, 0, 0),
+	MX6_PAD_GPIO1_IO04__USB_OTG1_PWR                      = IOMUX_PAD(0x02F8, 0x006C, 2, 0x0000, 0, 0),
+	MX6_PAD_GPIO1_IO04__USDHC1_RESET_B                    = IOMUX_PAD(0x02F8, 0x006C, 4, 0x0000, 0, 0),
+	MX6_PAD_GPIO1_IO04__GPIO1_IO04                        = IOMUX_PAD(0x02F8, 0x006C, 5, 0x0000, 0, 0),
+	MX6_PAD_GPIO1_IO04__ENET2_1588_EVENT0_IN              = IOMUX_PAD(0x02F8, 0x006C, 6, 0x0000, 0, 0),
+	MX6_PAD_GPIO1_IO04__UART5_DCE_TX                      = IOMUX_PAD(0x02F8, 0x006C, 8, 0x0000, 0, 0),
+	MX6_PAD_GPIO1_IO04__UART5_DTE_RX                      = IOMUX_PAD(0x02F8, 0x006C, 8, 0x0644, 2, 0),
+
+	MX6_PAD_GPIO1_IO05__ENET2_REF_CLK2                    = IOMUX_PAD(0x02FC, 0x0070, 0, 0x057C, 1, 0),
+	MX6_PAD_GPIO1_IO05__PWM4_OUT                          = IOMUX_PAD(0x02FC, 0x0070, 1, 0x0000, 0, 0),
+	MX6_PAD_GPIO1_IO05__ANATOP_OTG2_ID                    = IOMUX_PAD(0x02FC, 0x0070, 2, 0x04BC, 0, 0),
+	MX6_PAD_GPIO1_IO05__CSI_FIELD                         = IOMUX_PAD(0x02FC, 0x0070, 3, 0x0530, 0, 0),
+	MX6_PAD_GPIO1_IO05__USDHC1_VSELECT                    = IOMUX_PAD(0x02FC, 0x0070, 4, 0x0000, 0, 0),
+	MX6_PAD_GPIO1_IO05__GPIO1_IO05                        = IOMUX_PAD(0x02FC, 0x0070, 5, 0x0000, 0, 0),
+	MX6_PAD_GPIO1_IO05__ENET2_1588_EVENT0_OUT             = IOMUX_PAD(0x02FC, 0x0070, 6, 0x0000, 0, 0),
+	MX6_PAD_GPIO1_IO05__UART5_DCE_RX                      = IOMUX_PAD(0x02FC, 0x0070, 8, 0x0644, 3, 0),
+	MX6_PAD_GPIO1_IO05__UART5_DTE_TX                      = IOMUX_PAD(0x02FC, 0x0070, 8, 0x0000, 0, 0),
+
+	MX6_PAD_GPIO1_IO06__ENET1_MDIO                        = IOMUX_PAD(0x0300, 0x0074, 0, 0x0578, 0, 0),
+	MX6_PAD_GPIO1_IO06__ENET2_MDIO                        = IOMUX_PAD(0x0300, 0x0074, 1, 0x0580, 0, 0),
+	MX6_PAD_GPIO1_IO06__USB_OTG_PWR_WAKE                  = IOMUX_PAD(0x0300, 0x0074, 2, 0x0000, 0, 0),
+	MX6_PAD_GPIO1_IO06__CSI_MCLK                          = IOMUX_PAD(0x0300, 0x0074, 3, 0x0000, 0, 0),
+	MX6_PAD_GPIO1_IO06__USDHC2_WP                         = IOMUX_PAD(0x0300, 0x0074, 4, 0x069C, 0, 0),
+	MX6_PAD_GPIO1_IO06__GPIO1_IO06                        = IOMUX_PAD(0x0300, 0x0074, 5, 0x0000, 0, 0),
+	MX6_PAD_GPIO1_IO06__CCM_WAIT                          = IOMUX_PAD(0x0300, 0x0074, 6, 0x0000, 0, 0),
+	MX6_PAD_GPIO1_IO06__CCM_REF_EN_B                      = IOMUX_PAD(0x0300, 0x0074, 7, 0x0000, 0, 0),
+	MX6_PAD_GPIO1_IO06__UART1_DCE_CTS                     = IOMUX_PAD(0x0300, 0x0074, 8, 0x0000, 0, 0),
+	MX6_PAD_GPIO1_IO06__UART1_DTE_RTS                     = IOMUX_PAD(0x0300, 0x0074, 8, 0x0620, 0, 0),
+
+	MX6_PAD_GPIO1_IO07__ENET1_MDC                         = IOMUX_PAD(0x0304, 0x0078, 0, 0x0000, 0, 0),
+	MX6_PAD_GPIO1_IO07__ENET2_MDC                         = IOMUX_PAD(0x0304, 0x0078, 1, 0x0000, 0, 0),
+	MX6_PAD_GPIO1_IO07__USB_OTG_HOST_MODE                 = IOMUX_PAD(0x0304, 0x0078, 2, 0x0000, 0, 0),
+	MX6_PAD_GPIO1_IO07__CSI_PIXCLK                        = IOMUX_PAD(0x0304, 0x0078, 3, 0x0528, 0, 0),
+	MX6_PAD_GPIO1_IO07__USDHC2_CD_B                       = IOMUX_PAD(0x0304, 0x0078, 4, 0x0674, 1, 0),
+	MX6_PAD_GPIO1_IO07__GPIO1_IO07                        = IOMUX_PAD(0x0304, 0x0078, 5, 0x0000, 0, 0),
+	MX6_PAD_GPIO1_IO07__CCM_STOP                          = IOMUX_PAD(0x0304, 0x0078, 6, 0x0000, 0, 0),
+	MX6_PAD_GPIO1_IO07__UART1_DCE_RTS                     = IOMUX_PAD(0x0304, 0x0078, 8, 0x0620, 1, 0),
+	MX6_PAD_GPIO1_IO07__UART1_DTE_CTS                     = IOMUX_PAD(0x0304, 0x0078, 8, 0x0000, 0, 0),
+
+	MX6_PAD_GPIO1_IO08__PWM1_OUT                          = IOMUX_PAD(0x0308, 0x007C, 0, 0x0000, 0, 0),
+	MX6_PAD_GPIO1_IO08__WDOG1_WDOG_B                      = IOMUX_PAD(0x0308, 0x007C, 1, 0x0000, 0, 0),
+	MX6_PAD_GPIO1_IO08__SPDIF_OUT                         = IOMUX_PAD(0x0308, 0x007C, 2, 0x0000, 0, 0),
+	MX6_PAD_GPIO1_IO08__CSI_VSYNC                         = IOMUX_PAD(0x0308, 0x007C, 3, 0x052C, 1, 0),
+	MX6_PAD_GPIO1_IO08__USDHC2_VSELECT                    = IOMUX_PAD(0x0308, 0x007C, 4, 0x0000, 0, 0),
+	MX6_PAD_GPIO1_IO08__GPIO1_IO08                        = IOMUX_PAD(0x0308, 0x007C, 5, 0x0000, 0, 0),
+	MX6_PAD_GPIO1_IO08__CCM_PMIC_RDY                      = IOMUX_PAD(0x0308, 0x007C, 6, 0x04C0, 1, 0),
+	MX6_PAD_GPIO1_IO08__UART5_DCE_RTS                     = IOMUX_PAD(0x0308, 0x007C, 8, 0x0640, 1, 0),
+	MX6_PAD_GPIO1_IO08__UART5_DTE_CTS                     = IOMUX_PAD(0x0308, 0x007C, 8, 0x0000, 0, 0),
+
+	MX6_PAD_GPIO1_IO09__PWM2_OUT                          = IOMUX_PAD(0x030C, 0x0080, 0, 0x0000, 0, 0),
+	MX6_PAD_GPIO1_IO09__WDOG1_WDOG_ANY                    = IOMUX_PAD(0x030C, 0x0080, 1, 0x0000, 0, 0),
+	MX6_PAD_GPIO1_IO09__SPDIF_IN                          = IOMUX_PAD(0x030C, 0x0080, 2, 0x0618, 0, 0),
+	MX6_PAD_GPIO1_IO09__CSI_HSYNC                         = IOMUX_PAD(0x030C, 0x0080, 3, 0x0524, 1, 0),
+	MX6_PAD_GPIO1_IO09__USDHC2_RESET_B                    = IOMUX_PAD(0x030C, 0x0080, 4, 0x0000, 0, 0),
+	MX6_PAD_GPIO1_IO09__GPIO1_IO09                        = IOMUX_PAD(0x030C, 0x0080, 5, 0x0000, 0, 0),
+	MX6_PAD_GPIO1_IO09__USDHC1_RESET_B                    = IOMUX_PAD(0x030C, 0x0080, 6, 0x0000, 0, 0),
+	MX6_PAD_GPIO1_IO09__UART5_DCE_CTS                     = IOMUX_PAD(0x030C, 0x0080, 8, 0x0000, 0, 0),
+	MX6_PAD_GPIO1_IO09__UART5_DTE_RTS                     = IOMUX_PAD(0x030C, 0x0080, 8, 0x0640, 2, 0),
+
+	MX6_PAD_UART1_TX_DATA__UART1_DCE_TX                   = IOMUX_PAD(0x0310, 0x0084, 0, 0x0000, 0, 0),
+
+	MX6_PAD_UART1_TX_DATA__UART1_DTE_RX                   = IOMUX_PAD(0x0310, 0x0084, 0, 0x0624, 2, 0),
+	MX6_PAD_UART1_TX_DATA__ENET1_RDATA02                  = IOMUX_PAD(0x0310, 0x0084, 1, 0x0000, 0, 0),
+	MX6_PAD_UART1_TX_DATA__I2C3_SCL                       = IOMUX_PAD(0x0310, 0x0084, IOMUX_CONFIG_SION | 2, 0x05B4, 0, 0),
+	MX6_PAD_UART1_TX_DATA__CSI_DATA02                     = IOMUX_PAD(0x0310, 0x0084, 3, 0x04C4, 1, 0),
+	MX6_PAD_UART1_TX_DATA__GPT1_COMPARE1                  = IOMUX_PAD(0x0310, 0x0084, 4, 0x0000, 0, 0),
+	MX6_PAD_UART1_TX_DATA__GPIO1_IO16                     = IOMUX_PAD(0x0310, 0x0084, 5, 0x0000, 0, 0),
+	MX6_PAD_UART1_TX_DATA__SPDIF_OUT                      = IOMUX_PAD(0x0310, 0x0084, 8, 0x0000, 0, 0),
+
+	MX6_PAD_UART1_RX_DATA__UART1_DCE_RX                   = IOMUX_PAD(0x0314, 0x0088, 0, 0x0624, 3, 0),
+
+	MX6_PAD_UART1_RX_DATA__UART1_DTE_TX                   = IOMUX_PAD(0x0314, 0x0088, 0, 0x0000, 0, 0),
+	MX6_PAD_UART1_RX_DATA__ENET1_RDATA03                  = IOMUX_PAD(0x0314, 0x0088, 1, 0x0000, 0, 0),
+	MX6_PAD_UART1_RX_DATA__I2C3_SDA                       = IOMUX_PAD(0x0314, 0x0088, IOMUX_CONFIG_SION | 2, 0x05B8, 0, 0),
+	MX6_PAD_UART1_RX_DATA__CSI_DATA03                     = IOMUX_PAD(0x0314, 0x0088, 3, 0x04C8, 1, 0),
+	MX6_PAD_UART1_RX_DATA__GPT1_CLK                       = IOMUX_PAD(0x0314, 0x0088, 4, 0x0594, 0, 0),
+	MX6_PAD_UART1_RX_DATA__GPIO1_IO17                     = IOMUX_PAD(0x0314, 0x0088, 5, 0x0000, 0, 0),
+	MX6_PAD_UART1_RX_DATA__SPDIF_IN                       = IOMUX_PAD(0x0314, 0x0088, 8, 0x0618, 1, 0),
+
+	MX6_PAD_UART1_CTS_B__UART1_DCE_CTS                    = IOMUX_PAD(0x0318, 0x008C, 0, 0x0000, 0, 0),
+
+	MX6_PAD_UART1_CTS_B__UART1_DTE_RTS                    = IOMUX_PAD(0x0318, 0x008C, 0, 0x0620, 2, 0),
+	MX6_PAD_UART1_CTS_B__ENET1_RX_CLK                     = IOMUX_PAD(0x0318, 0x008C, 1, 0x0000, 0, 0),
+	MX6_PAD_UART1_CTS_B__USDHC1_WP                        = IOMUX_PAD(0x0318, 0x008C, 2, 0x066C, 1, 0),
+	MX6_PAD_UART1_CTS_B__CSI_DATA04                       = IOMUX_PAD(0x0318, 0x008C, 3, 0x04D8, 0, 0),
+	MX6_PAD_UART1_CTS_B__ENET2_1588_EVENT1_IN             = IOMUX_PAD(0x0318, 0x008C, 4, 0x0000, 0, 0),
+	MX6_PAD_UART1_CTS_B__GPIO1_IO18                       = IOMUX_PAD(0x0318, 0x008C, 5, 0x0000, 0, 0),
+	MX6_PAD_UART1_CTS_B__USDHC2_WP                        = IOMUX_PAD(0x0318, 0x008C, 8, 0x069C, 1, 0),
+
+	MX6_PAD_UART1_RTS_B__UART1_DCE_RTS                    = IOMUX_PAD(0x031C, 0x0090, 0, 0x0620, 3, 0),
+
+	MX6_PAD_UART1_RTS_B__UART1_DTE_CTS                    = IOMUX_PAD(0x031C, 0x0090, 0, 0x0000, 0, 0),
+	MX6_PAD_UART1_RTS_B__ENET1_TX_ER                      = IOMUX_PAD(0x031C, 0x0090, 1, 0x0000, 0, 0),
+	MX6_PAD_UART1_RTS_B__USDHC1_CD_B                      = IOMUX_PAD(0x031C, 0x0090, 2, 0x0668, 1, 0),
+	MX6_PAD_UART1_RTS_B__CSI_DATA05                       = IOMUX_PAD(0x031C, 0x0090, 3, 0x04CC, 1, 0),
+	MX6_PAD_UART1_RTS_B__ENET2_1588_EVENT1_OUT            = IOMUX_PAD(0x031C, 0x0090, 4, 0x0000, 0, 0),
+	MX6_PAD_UART1_RTS_B__GPIO1_IO19                       = IOMUX_PAD(0x031C, 0x0090, 5, 0x0000, 0, 0),
+	MX6_PAD_UART1_RTS_B__USDHC2_CD_B                      = IOMUX_PAD(0x031C, 0x0090, 8, 0x0674, 2, 0),
+
+	MX6_PAD_UART2_TX_DATA__UART2_DCE_TX                   = IOMUX_PAD(0x0320, 0x0094, 0, 0x0000, 0, 0),
+
+	MX6_PAD_UART2_TX_DATA__UART2_DTE_RX                   = IOMUX_PAD(0x0320, 0x0094, 0, 0x062C, 0, 0),
+	MX6_PAD_UART2_TX_DATA__ENET1_TDATA02                  = IOMUX_PAD(0x0320, 0x0094, 1, 0x0000, 0, 0),
+	MX6_PAD_UART2_TX_DATA__I2C4_SCL                       = IOMUX_PAD(0x0320, 0x0094, IOMUX_CONFIG_SION | 2, 0x05BC, 0, 0),
+	MX6_PAD_UART2_TX_DATA__CSI_DATA06                     = IOMUX_PAD(0x0320, 0x0094, 3, 0x04DC, 0, 0),
+	MX6_PAD_UART2_TX_DATA__GPT1_CAPTURE1                  = IOMUX_PAD(0x0320, 0x0094, 4, 0x058C, 1, 0),
+	MX6_PAD_UART2_TX_DATA__GPIO1_IO20                     = IOMUX_PAD(0x0320, 0x0094, 5, 0x0000, 0, 0),
+	MX6_PAD_UART2_TX_DATA__ECSPI3_SS0                     = IOMUX_PAD(0x0320, 0x0094, 8, 0x0560, 0, 0),
+
+	MX6_PAD_UART2_RX_DATA__UART2_DCE_RX                   = IOMUX_PAD(0x0324, 0x0098, 0, 0x062C, 1, 0),
+
+	MX6_PAD_UART2_RX_DATA__UART2_DTE_TX                   = IOMUX_PAD(0x0324, 0x0098, 0, 0x0000, 0, 0),
+	MX6_PAD_UART2_RX_DATA__ENET1_TDATA03                  = IOMUX_PAD(0x0324, 0x0098, 1, 0x0000, 0, 0),
+	MX6_PAD_UART2_RX_DATA__I2C4_SDA                       = IOMUX_PAD(0x0324, 0x0098, IOMUX_CONFIG_SION | 2, 0x05C0, 0, 0),
+	MX6_PAD_UART2_RX_DATA__CSI_DATA07                     = IOMUX_PAD(0x0324, 0x0098, 3, 0x04E0, 0, 0),
+	MX6_PAD_UART2_RX_DATA__GPT1_CAPTURE2                  = IOMUX_PAD(0x0324, 0x0098, 4, 0x0590, 0, 0),
+	MX6_PAD_UART2_RX_DATA__GPIO1_IO21                     = IOMUX_PAD(0x0324, 0x0098, 5, 0x0000, 0, 0),
+	MX6_PAD_UART2_RX_DATA__SJC_DONE                       = IOMUX_PAD(0x0324, 0x0098, 7, 0x0000, 0, 0),
+	MX6_PAD_UART2_RX_DATA__ECSPI3_SCLK                    = IOMUX_PAD(0x0324, 0x0098, 8, 0x0554, 0, 0),
+
+	MX6_PAD_UART2_CTS_B__UART2_DCE_CTS                    = IOMUX_PAD(0x0328, 0x009C, 0, 0x0000, 0, 0),
+
+	MX6_PAD_UART2_CTS_B__UART2_DTE_RTS                    = IOMUX_PAD(0x0328, 0x009C, 0, 0x0628, 0, 0),
+	MX6_PAD_UART2_CTS_B__ENET1_CRS                        = IOMUX_PAD(0x0328, 0x009C, 1, 0x0000, 0, 0),
+	MX6_PAD_UART2_CTS_B__FLEXCAN2_TX                      = IOMUX_PAD(0x0328, 0x009C, 2, 0x0000, 0, 0),
+	MX6_PAD_UART2_CTS_B__CSI_DATA08                       = IOMUX_PAD(0x0328, 0x009C, 3, 0x04E4, 0, 0),
+	MX6_PAD_UART2_CTS_B__GPT1_COMPARE2                    = IOMUX_PAD(0x0328, 0x009C, 4, 0x0000, 0, 0),
+	MX6_PAD_UART2_CTS_B__GPIO1_IO22                       = IOMUX_PAD(0x0328, 0x009C, 5, 0x0000, 0, 0),
+	MX6_PAD_UART2_CTS_B__SJC_DE_B                         = IOMUX_PAD(0x0328, 0x009C, 7, 0x0000, 0, 0),
+	MX6_PAD_UART2_CTS_B__ECSPI3_MOSI                      = IOMUX_PAD(0x0328, 0x009C, 8, 0x055C, 0, 0),
+
+	MX6_PAD_UART2_RTS_B__UART2_DCE_RTS                    = IOMUX_PAD(0x032C, 0x00A0, 0, 0x0628, 1, 0),
+
+	MX6_PAD_UART2_RTS_B__UART2_DTE_CTS                    = IOMUX_PAD(0x032C, 0x00A0, 0, 0x0000, 0, 0),
+	MX6_PAD_UART2_RTS_B__ENET1_COL                        = IOMUX_PAD(0x032C, 0x00A0, 1, 0x0000, 0, 0),
+	MX6_PAD_UART2_RTS_B__FLEXCAN2_RX                      = IOMUX_PAD(0x032C, 0x00A0, 2, 0x0588, 0, 0),
+	MX6_PAD_UART2_RTS_B__CSI_DATA09                       = IOMUX_PAD(0x032C, 0x00A0, 3, 0x04E8, 0, 0),
+	MX6_PAD_UART2_RTS_B__GPT1_COMPARE3                    = IOMUX_PAD(0x032C, 0x00A0, 4, 0x0000, 0, 0),
+	MX6_PAD_UART2_RTS_B__GPIO1_IO23                       = IOMUX_PAD(0x032C, 0x00A0, 5, 0x0000, 0, 0),
+	MX6_PAD_UART2_RTS_B__SJC_FAIL                         = IOMUX_PAD(0x032C, 0x00A0, 7, 0x0000, 0, 0),
+	MX6_PAD_UART2_RTS_B__ECSPI3_MISO                      = IOMUX_PAD(0x032C, 0x00A0, 8, 0x0558, 0, 0),
+
+	MX6_PAD_UART3_TX_DATA__UART3_DCE_TX                   = IOMUX_PAD(0x0330, 0x00A4, 0, 0x0000, 0, 0),
+
+	MX6_PAD_UART3_TX_DATA__UART3_DTE_RX                   = IOMUX_PAD(0x0330, 0x00A4, 0, 0x0634, 0, 0),
+	MX6_PAD_UART3_TX_DATA__ENET2_RDATA02                  = IOMUX_PAD(0x0330, 0x00A4, 1, 0x0000, 0, 0),
+	MX6_PAD_UART3_TX_DATA__SIM1_PORT0_PD                  = IOMUX_PAD(0x0330, 0x00A4, 2, 0x0000, 0, 0),
+	MX6_PAD_UART3_TX_DATA__CSI_DATA01                     = IOMUX_PAD(0x0330, 0x00A4, 3, 0x04D4, 0, 0),
+	MX6_PAD_UART3_TX_DATA__UART2_DCE_CTS                  = IOMUX_PAD(0x0330, 0x00A4, 4, 0x0000, 0, 0),
+	MX6_PAD_UART3_TX_DATA__UART2_DTE_RTS                  = IOMUX_PAD(0x0330, 0x00A4, 4, 0x0628, 2, 0),
+	MX6_PAD_UART3_TX_DATA__GPIO1_IO24                     = IOMUX_PAD(0x0330, 0x00A4, 5, 0x0000, 0, 0),
+	MX6_PAD_UART3_TX_DATA__SJC_JTAG_ACT                   = IOMUX_PAD(0x0330, 0x00A4, 7, 0x0000, 0, 0),
+	MX6_PAD_UART3_TX_DATA__ANATOP_OTG1_ID                 = IOMUX_PAD(0x0330, 0x00A4, 8, 0x04B8, 1, 0),
+
+	MX6_PAD_UART3_RX_DATA__UART3_DCE_RX                   = IOMUX_PAD(0x0334, 0x00A8, 0, 0x0634, 1, 0),
+
+	MX6_PAD_UART3_RX_DATA__UART3_DTE_TX                   = IOMUX_PAD(0x0334, 0x00A8, 0, 0x0000, 0, 0),
+	MX6_PAD_UART3_RX_DATA__ENET2_RDATA03                  = IOMUX_PAD(0x0334, 0x00A8, 1, 0x0000, 0, 0),
+	MX6_PAD_UART3_RX_DATA__SIM2_PORT0_PD                  = IOMUX_PAD(0x0334, 0x00A8, 2, 0x0000, 0, 0),
+	MX6_PAD_UART3_RX_DATA__CSI_DATA00                     = IOMUX_PAD(0x0334, 0x00A8, 3, 0x04D0, 0, 0),
+	MX6_PAD_UART3_RX_DATA__UART2_DCE_RTS                  = IOMUX_PAD(0x0334, 0x00A8, 4, 0x0628, 3, 0),
+	MX6_PAD_UART3_RX_DATA__UART2_DTE_CTS                  = IOMUX_PAD(0x0334, 0x00A8, 4, 0x0000, 0, 0),
+	MX6_PAD_UART3_RX_DATA__GPIO1_IO25                     = IOMUX_PAD(0x0334, 0x00A8, 5, 0x0000, 0, 0),
+	MX6_PAD_UART3_RX_DATA__EPIT1_OUT                      = IOMUX_PAD(0x0334, 0x00A8, 8, 0x0000, 0, 0),
+
+	MX6_PAD_UART3_CTS_B__UART3_DCE_CTS                    = IOMUX_PAD(0x0338, 0x00AC, 0, 0x0000, 0, 0),
+
+	MX6_PAD_UART3_CTS_B__UART3_DTE_RTS                    = IOMUX_PAD(0x0338, 0x00AC, 0, 0x0630, 0, 0),
+	MX6_PAD_UART3_CTS_B__ENET2_RX_CLK                     = IOMUX_PAD(0x0338, 0x00AC, IOMUX_CONFIG_SION | 1, 0x0000, 0, 0),
+	MX6_PAD_UART3_CTS_B__FLEXCAN1_TX                      = IOMUX_PAD(0x0338, 0x00AC, 2, 0x0000, 0, 0),
+	MX6_PAD_UART3_CTS_B__CSI_DATA10                       = IOMUX_PAD(0x0338, 0x00AC, 3, 0x04EC, 0, 0),
+	MX6_PAD_UART3_CTS_B__ENET1_1588_EVENT1_IN             = IOMUX_PAD(0x0338, 0x00AC, 4, 0x0000, 0, 0),
+	MX6_PAD_UART3_CTS_B__GPIO1_IO26                       = IOMUX_PAD(0x0338, 0x00AC, 5, 0x0000, 0, 0),
+	MX6_PAD_UART3_CTS_B__EPIT2_OUT                        = IOMUX_PAD(0x0338, 0x00AC, 8, 0x0000, 0, 0),
+
+	MX6_PAD_UART3_RTS_B__UART3_DCE_RTS                    = IOMUX_PAD(0x033C, 0x00B0, 0, 0x0630, 1, 0),
+
+	MX6_PAD_UART3_RTS_B__UART3_DTE_CTS                    = IOMUX_PAD(0x033C, 0x00B0, 0, 0x0000, 0, 0),
+	MX6_PAD_UART3_RTS_B__ENET2_TX_ER                      = IOMUX_PAD(0x033C, 0x00B0, 1, 0x0000, 0, 0),
+	MX6_PAD_UART3_RTS_B__FLEXCAN1_RX                      = IOMUX_PAD(0x033C, 0x00B0, 2, 0x0584, 0, 0),
+	MX6_PAD_UART3_RTS_B__CSI_DATA11                       = IOMUX_PAD(0x033C, 0x00B0, 3, 0x04F0, 0, 0),
+	MX6_PAD_UART3_RTS_B__ENET1_1588_EVENT1_OUT            = IOMUX_PAD(0x033C, 0x00B0, 4, 0x0000, 0, 0),
+	MX6_PAD_UART3_RTS_B__GPIO1_IO27                       = IOMUX_PAD(0x033C, 0x00B0, 5, 0x0000, 0, 0),
+	MX6_PAD_UART3_RTS_B__WDOG1_WDOG_B                     = IOMUX_PAD(0x033C, 0x00B0, 8, 0x0000, 0, 0),
+
+	MX6_PAD_UART4_TX_DATA__UART4_DCE_TX                   = IOMUX_PAD(0x0340, 0x00B4, 0, 0x0000, 0, 0),
+
+	MX6_PAD_UART4_TX_DATA__UART4_DTE_RX                   = IOMUX_PAD(0x0340, 0x00B4, 0, 0x063C, 0, 0),
+	MX6_PAD_UART4_TX_DATA__ENET2_TDATA02                  = IOMUX_PAD(0x0340, 0x00B4, 1, 0x0000, 0, 0),
+	MX6_PAD_UART4_TX_DATA__I2C1_SCL                       = IOMUX_PAD(0x0340, 0x00B4, IOMUX_CONFIG_SION | 2, 0x05A4, 1, 0),
+	MX6_PAD_UART4_TX_DATA__CSI_DATA12                     = IOMUX_PAD(0x0340, 0x00B4, 3, 0x04F4, 0, 0),
+	MX6_PAD_UART4_TX_DATA__CSU_CSU_ALARM_AUT02            = IOMUX_PAD(0x0340, 0x00B4, 4, 0x0000, 0, 0),
+	MX6_PAD_UART4_TX_DATA__GPIO1_IO28                     = IOMUX_PAD(0x0340, 0x00B4, 5, 0x0000, 0, 0),
+	MX6_PAD_UART4_TX_DATA__ECSPI2_SCLK                    = IOMUX_PAD(0x0340, 0x00B4, 8, 0x0544, 1, 0),
+
+	MX6_PAD_UART4_RX_DATA__UART4_DCE_RX                   = IOMUX_PAD(0x0344, 0x00B8, 0, 0x063C, 1, 0),
+
+	MX6_PAD_UART4_RX_DATA__UART4_DTE_TX                   = IOMUX_PAD(0x0344, 0x00B8, 0, 0x0000, 0, 0),
+	MX6_PAD_UART4_RX_DATA__ENET2_TDATA03                  = IOMUX_PAD(0x0344, 0x00B8, 1, 0x0000, 0, 0),
+	MX6_PAD_UART4_RX_DATA__I2C1_SDA                       = IOMUX_PAD(0x0344, 0x00B8, IOMUX_CONFIG_SION | 2, 0x05A8, 2, 0),
+	MX6_PAD_UART4_RX_DATA__CSI_DATA13                     = IOMUX_PAD(0x0344, 0x00B8, 3, 0x04F8, 0, 0),
+	MX6_PAD_UART4_RX_DATA__CSU_CSU_ALARM_AUT01            = IOMUX_PAD(0x0344, 0x00B8, 4, 0x0000, 0, 0),
+	MX6_PAD_UART4_RX_DATA__GPIO1_IO29                     = IOMUX_PAD(0x0344, 0x00B8, 5, 0x0000, 0, 0),
+	MX6_PAD_UART4_RX_DATA__ECSPI2_SS0                     = IOMUX_PAD(0x0344, 0x00B8, 8, 0x0550, 1, 0),
+	MX6_PAD_UART5_TX_DATA__GPIO1_IO30                     = IOMUX_PAD(0x0348, 0x00BC, 5, 0x0000, 0, 0),
+	MX6_PAD_UART5_TX_DATA__ECSPI2_MOSI                    = IOMUX_PAD(0x0348, 0x00BC, 8, 0x054C, 0, 0),
+
+	MX6_PAD_UART5_TX_DATA__UART5_DCE_TX                   = IOMUX_PAD(0x0348, 0x00BC, 0, 0x0000, 0, 0),
+
+	MX6_PAD_UART5_TX_DATA__UART5_DTE_RX                   = IOMUX_PAD(0x0348, 0x00BC, 0, 0x0644, 4, 0),
+	MX6_PAD_UART5_TX_DATA__ENET2_CRS                      = IOMUX_PAD(0x0348, 0x00BC, 1, 0x0000, 0, 0),
+	MX6_PAD_UART5_TX_DATA__I2C2_SCL                       = IOMUX_PAD(0x0348, 0x00BC, IOMUX_CONFIG_SION | 2, 0x05AC, 2, 0),
+	MX6_PAD_UART5_TX_DATA__CSI_DATA14                     = IOMUX_PAD(0x0348, 0x00BC, 3, 0x04FC, 0, 0),
+	MX6_PAD_UART5_TX_DATA__CSU_CSU_ALARM_AUT00            = IOMUX_PAD(0x0348, 0x00BC, 4, 0x0000, 0, 0),
+
+	MX6_PAD_UART5_RX_DATA__UART5_DCE_RX                   = IOMUX_PAD(0x034C, 0x00C0, 0, 0x0644, 5, 0),
+
+	MX6_PAD_UART5_RX_DATA__UART5_DTE_TX                   = IOMUX_PAD(0x034C, 0x00C0, 0, 0x0000, 0, 0),
+	MX6_PAD_UART5_RX_DATA__ENET2_COL                      = IOMUX_PAD(0x034C, 0x00C0, 1, 0x0000, 0, 0),
+	MX6_PAD_UART5_RX_DATA__I2C2_SDA                       = IOMUX_PAD(0x034C, 0x00C0, IOMUX_CONFIG_SION | 2, 0x05B0, 2, 0),
+	MX6_PAD_UART5_RX_DATA__CSI_DATA15                     = IOMUX_PAD(0x034C, 0x00C0, 3, 0x0500, 0, 0),
+	MX6_PAD_UART5_RX_DATA__CSU_CSU_INT_DEB                = IOMUX_PAD(0x034C, 0x00C0, 4, 0x0000, 0, 0),
+	MX6_PAD_UART5_RX_DATA__GPIO1_IO31                     = IOMUX_PAD(0x034C, 0x00C0, 5, 0x0000, 0, 0),
+	MX6_PAD_UART5_RX_DATA__ECSPI2_MISO                    = IOMUX_PAD(0x034C, 0x00C0, 8, 0x0548, 1, 0),
+
+	MX6_PAD_ENET1_RX_DATA0__ENET1_RDATA00                 = IOMUX_PAD(0x0350, 0x00C4, 0, 0x0000, 0, 0),
+	MX6_PAD_ENET1_RX_DATA0__UART4_DCE_RTS                 = IOMUX_PAD(0x0350, 0x00C4, 1, 0x0638, 0, 0),
+	MX6_PAD_ENET1_RX_DATA0__UART4_DTE_CTS                 = IOMUX_PAD(0x0350, 0x00C4, 1, 0x0000, 0, 0),
+	MX6_PAD_ENET1_RX_DATA0__PWM1_OUT                      = IOMUX_PAD(0x0350, 0x00C4, 2, 0x0000, 0, 0),
+	MX6_PAD_ENET1_RX_DATA0__CSI_DATA16                    = IOMUX_PAD(0x0350, 0x00C4, 3, 0x0504, 0, 0),
+	MX6_PAD_ENET1_RX_DATA0__FLEXCAN1_TX                   = IOMUX_PAD(0x0350, 0x00C4, 4, 0x0000, 0, 0),
+	MX6_PAD_ENET1_RX_DATA0__GPIO2_IO00                    = IOMUX_PAD(0x0350, 0x00C4, 5, 0x0000, 0, 0),
+	MX6_PAD_ENET1_RX_DATA0__KPP_ROW00                     = IOMUX_PAD(0x0350, 0x00C4, 6, 0x05D0, 0, 0),
+	MX6_PAD_ENET1_RX_DATA0__USDHC1_LCTL                   = IOMUX_PAD(0x0350, 0x00C4, 8, 0x0000, 0, 0),
+
+	MX6_PAD_ENET1_RX_DATA1__ENET1_RDATA01                 = IOMUX_PAD(0x0354, 0x00C8, 0, 0x0000, 0, 0),
+	MX6_PAD_ENET1_RX_DATA1__UART4_DCE_CTS                 = IOMUX_PAD(0x0354, 0x00C8, 1, 0x0000, 0, 0),
+	MX6_PAD_ENET1_RX_DATA1__UART4_DTE_RTS                 = IOMUX_PAD(0x0354, 0x00C8, 1, 0x0638, 1, 0),
+	MX6_PAD_ENET1_RX_DATA1__PWM2_OUT                      = IOMUX_PAD(0x0354, 0x00C8, 2, 0x0000, 0, 0),
+	MX6_PAD_ENET1_RX_DATA1__CSI_DATA17                    = IOMUX_PAD(0x0354, 0x00C8, 3, 0x0508, 0, 0),
+	MX6_PAD_ENET1_RX_DATA1__FLEXCAN1_RX                   = IOMUX_PAD(0x0354, 0x00C8, 4, 0x0584, 1, 0),
+	MX6_PAD_ENET1_RX_DATA1__GPIO2_IO01                    = IOMUX_PAD(0x0354, 0x00C8, 5, 0x0000, 0, 0),
+	MX6_PAD_ENET1_RX_DATA1__KPP_COL00                     = IOMUX_PAD(0x0354, 0x00C8, 6, 0x05C4, 0, 0),
+	MX6_PAD_ENET1_RX_DATA1__USDHC2_LCTL                   = IOMUX_PAD(0x0354, 0x00C8, 8, 0x0000, 0, 0),
+
+	MX6_PAD_ENET1_RX_EN__ENET1_RX_EN                      = IOMUX_PAD(0x0358, 0x00CC, 0, 0x0000, 0, 0),
+	MX6_PAD_ENET1_RX_EN__UART5_DCE_RTS                    = IOMUX_PAD(0x0358, 0x00CC, 1, 0x0640, 3, 0),
+	MX6_PAD_ENET1_RX_EN__UART5_DTE_CTS                    = IOMUX_PAD(0x0358, 0x00CC, 1, 0x0000, 0, 0),
+	MX6_PAD_ENET1_RX_EN__CSI_DATA18                       = IOMUX_PAD(0x0358, 0x00CC, 3, 0x050C, 0, 0),
+	MX6_PAD_ENET1_RX_EN__FLEXCAN2_TX                      = IOMUX_PAD(0x0358, 0x00CC, 4, 0x0000, 0, 0),
+	MX6_PAD_ENET1_RX_EN__GPIO2_IO02                       = IOMUX_PAD(0x0358, 0x00CC, 5, 0x0000, 0, 0),
+	MX6_PAD_ENET1_RX_EN__KPP_ROW01                        = IOMUX_PAD(0x0358, 0x00CC, 6, 0x05D4, 0, 0),
+	MX6_PAD_ENET1_RX_EN__USDHC1_VSELECT                   = IOMUX_PAD(0x0358, 0x00CC, 8, 0x0000, 0, 0),
+
+	MX6_PAD_ENET1_TX_DATA0__ENET1_TDATA00                 = IOMUX_PAD(0x035C, 0x00D0, 0, 0x0000, 0, 0),
+	MX6_PAD_ENET1_TX_DATA0__UART5_DCE_CTS                 = IOMUX_PAD(0x035C, 0x00D0, 1, 0x0000, 0, 0),
+	MX6_PAD_ENET1_TX_DATA0__UART5_DTE_RTS                 = IOMUX_PAD(0x035C, 0x00D0, 1, 0x0640, 4, 0),
+	MX6_PAD_ENET1_TX_DATA0__CSI_DATA19                    = IOMUX_PAD(0x035C, 0x00D0, 3, 0x0510, 0, 0),
+	MX6_PAD_ENET1_TX_DATA0__FLEXCAN2_RX                   = IOMUX_PAD(0x035C, 0x00D0, 4, 0x0588, 1, 0),
+	MX6_PAD_ENET1_TX_DATA0__GPIO2_IO03                    = IOMUX_PAD(0x035C, 0x00D0, 5, 0x0000, 0, 0),
+	MX6_PAD_ENET1_TX_DATA0__KPP_COL01                     = IOMUX_PAD(0x035C, 0x00D0, 6, 0x05C8, 0, 0),
+	MX6_PAD_ENET1_TX_DATA0__USDHC2_VSELECT                = IOMUX_PAD(0x035C, 0x00D0, 8, 0x0000, 0, 0),
+
+	MX6_PAD_ENET1_TX_DATA1__ENET1_TDATA01                 = IOMUX_PAD(0x0360, 0x00D4, 0, 0x0000, 0, 0),
+	MX6_PAD_ENET1_TX_DATA1__UART6_DCE_CTS                 = IOMUX_PAD(0x0360, 0x00D4, 1, 0x0000, 0, 0),
+	MX6_PAD_ENET1_TX_DATA1__UART6_DTE_RTS                 = IOMUX_PAD(0x0360, 0x00D4, 1, 0x0648, 2, 0),
+	MX6_PAD_ENET1_TX_DATA1__PWM5_OUT                      = IOMUX_PAD(0x0360, 0x00D4, 2, 0x0000, 0, 0),
+	MX6_PAD_ENET1_TX_DATA1__CSI_DATA20                    = IOMUX_PAD(0x0360, 0x00D4, 3, 0x0514, 0, 0),
+	MX6_PAD_ENET1_TX_DATA1__ENET2_MDIO                    = IOMUX_PAD(0x0360, 0x00D4, 4, 0x0580, 1, 0),
+	MX6_PAD_ENET1_TX_DATA1__GPIO2_IO04                    = IOMUX_PAD(0x0360, 0x00D4, 5, 0x0000, 0, 0),
+	MX6_PAD_ENET1_TX_DATA1__KPP_ROW02                     = IOMUX_PAD(0x0360, 0x00D4, 6, 0x05D8, 0, 0),
+	MX6_PAD_ENET1_TX_DATA1__WDOG1_WDOG_RST_B_DEB          = IOMUX_PAD(0x0360, 0x00D4, 8, 0x0000, 0, 0),
+
+	MX6_PAD_ENET1_TX_EN__ENET1_TX_EN                      = IOMUX_PAD(0x0364, 0x00D8, 0, 0x0000, 0, 0),
+	MX6_PAD_ENET1_TX_EN__UART6_DCE_RTS                    = IOMUX_PAD(0x0364, 0x00D8, 1, 0x0648, 3, 0),
+	MX6_PAD_ENET1_TX_EN__UART6_DTE_CTS                    = IOMUX_PAD(0x0364, 0x00D8, 1, 0x0000, 0, 0),
+	MX6_PAD_ENET1_TX_EN__PWM6_OUT                         = IOMUX_PAD(0x0364, 0x00D8, 2, 0x0000, 0, 0),
+	MX6_PAD_ENET1_TX_EN__CSI_DATA21                       = IOMUX_PAD(0x0364, 0x00D8, 3, 0x0518, 0, 0),
+	MX6_PAD_ENET1_TX_EN__ENET2_MDC                        = IOMUX_PAD(0x0364, 0x00D8, 4, 0x0000, 0, 0),
+	MX6_PAD_ENET1_TX_EN__GPIO2_IO05                       = IOMUX_PAD(0x0364, 0x00D8, 5, 0x0000, 0, 0),
+	MX6_PAD_ENET1_TX_EN__KPP_COL02                        = IOMUX_PAD(0x0364, 0x00D8, 6, 0x05CC, 0, 0),
+	MX6_PAD_ENET1_TX_EN__WDOG2_WDOG_RST_B_DEB             = IOMUX_PAD(0x0364, 0x00D8, 8, 0x0000, 0, 0),
+
+	MX6_PAD_ENET1_TX_CLK__ENET1_TX_CLK                    = IOMUX_PAD(0x0368, 0x00DC, 0, 0x0000, 0, 0),
+	MX6_PAD_ENET1_TX_CLK__UART7_DCE_CTS                   = IOMUX_PAD(0x0368, 0x00DC, 1, 0x0000, 0, 0),
+	MX6_PAD_ENET1_TX_CLK__UART7_DTE_RTS                   = IOMUX_PAD(0x0368, 0x00DC, 1, 0x0650, 0, 0),
+	MX6_PAD_ENET1_TX_CLK__PWM7_OUT                        = IOMUX_PAD(0x0368, 0x00DC, 2, 0x0000, 0, 0),
+	MX6_PAD_ENET1_TX_CLK__CSI_DATA22                      = IOMUX_PAD(0x0368, 0x00DC, 3, 0x051C, 0, 0),
+	MX6_PAD_ENET1_TX_CLK__ENET1_REF_CLK1                  = IOMUX_PAD(0x0368, 0x00DC, IOMUX_CONFIG_SION | 4, 0x0574, 2, 0),
+	MX6_PAD_ENET1_TX_CLK__GPIO2_IO06                      = IOMUX_PAD(0x0368, 0x00DC, 5, 0x0000, 0, 0),
+	MX6_PAD_ENET1_TX_CLK__KPP_ROW03                       = IOMUX_PAD(0x0368, 0x00DC, 6, 0x0000, 0, 0),
+	MX6_PAD_ENET1_TX_CLK__GPT1_CLK                        = IOMUX_PAD(0x0368, 0x00DC, 8, 0x0594, 1, 0),
+
+	MX6_PAD_ENET1_RX_ER__ENET1_RX_ER                      = IOMUX_PAD(0x036C, 0x00E0, 0, 0x0000, 0, 0),
+	MX6_PAD_ENET1_RX_ER__UART7_DCE_RTS                    = IOMUX_PAD(0x036C, 0x00E0, 1, 0x0650, 1, 0),
+	MX6_PAD_ENET1_RX_ER__UART7_DTE_CTS                    = IOMUX_PAD(0x036C, 0x00E0, 1, 0x0000, 0, 0),
+	MX6_PAD_ENET1_RX_ER__PWM8_OUT                         = IOMUX_PAD(0x036C, 0x00E0, 2, 0x0000, 0, 0),
+	MX6_PAD_ENET1_RX_ER__CSI_DATA23                       = IOMUX_PAD(0x036C, 0x00E0, 3, 0x0520, 0, 0),
+	MX6_PAD_ENET1_RX_ER__EIM_CRE                          = IOMUX_PAD(0x036C, 0x00E0, 4, 0x0000, 0, 0),
+	MX6_PAD_ENET1_RX_ER__GPIO2_IO07                       = IOMUX_PAD(0x036C, 0x00E0, 5, 0x0000, 0, 0),
+	MX6_PAD_ENET1_RX_ER__KPP_COL03                        = IOMUX_PAD(0x036C, 0x00E0, 6, 0x0000, 0, 0),
+	MX6_PAD_ENET1_RX_ER__GPT1_CAPTURE2                    = IOMUX_PAD(0x036C, 0x00E0, 8, 0x0590, 1, 0),
+
+	MX6_PAD_ENET2_RX_DATA0__ENET2_RDATA00                 = IOMUX_PAD(0x0370, 0x00E4, 0, 0x0000, 0, 0),
+	MX6_PAD_ENET2_RX_DATA0__UART6_DCE_TX                  = IOMUX_PAD(0x0370, 0x00E4, 1, 0x0000, 0, 0),
+	MX6_PAD_ENET2_RX_DATA0__UART6_DTE_RX                  = IOMUX_PAD(0x0370, 0x00E4, 1, 0x064C, 1, 0),
+	MX6_PAD_ENET2_RX_DATA0__SIM1_PORT0_TRXD               = IOMUX_PAD(0x0370, 0x00E4, 2, 0x0000, 0, 0),
+	MX6_PAD_ENET2_RX_DATA0__I2C3_SCL                      = IOMUX_PAD(0x0370, 0x00E4, IOMUX_CONFIG_SION | 3, 0x05B4, 1, 0),
+	MX6_PAD_ENET2_RX_DATA0__ENET1_MDIO                    = IOMUX_PAD(0x0370, 0x00E4, 4, 0x0578, 1, 0),
+	MX6_PAD_ENET2_RX_DATA0__GPIO2_IO08                    = IOMUX_PAD(0x0370, 0x00E4, 5, 0x0000, 0, 0),
+	MX6_PAD_ENET2_RX_DATA0__KPP_ROW04                     = IOMUX_PAD(0x0370, 0x00E4, 6, 0x0000, 0, 0),
+	MX6_PAD_ENET2_RX_DATA0__USB_OTG1_PWR                  = IOMUX_PAD(0x0370, 0x00E4, 8, 0x0000, 0, 0),
+
+	MX6_PAD_ENET2_RX_DATA1__ENET2_RDATA01                 = IOMUX_PAD(0x0374, 0x00E8, 0, 0x0000, 0, 0),
+	MX6_PAD_ENET2_RX_DATA1__UART6_DCE_RX                  = IOMUX_PAD(0x0374, 0x00E8, 1, 0x064C, 2, 0),
+	MX6_PAD_ENET2_RX_DATA1__UART6_DTE_TX                  = IOMUX_PAD(0x0374, 0x00E8, 1, 0x0000, 0, 0),
+	MX6_PAD_ENET2_RX_DATA1__SIM1_PORT0_CLK                = IOMUX_PAD(0x0374, 0x00E8, 2, 0x0000, 0, 0),
+	MX6_PAD_ENET2_RX_DATA1__I2C3_SDA                      = IOMUX_PAD(0x0374, 0x00E8, IOMUX_CONFIG_SION | 3, 0x05B8, 1, 0),
+	MX6_PAD_ENET2_RX_DATA1__ENET1_MDC                     = IOMUX_PAD(0x0374, 0x00E8, 4, 0x0000, 0, 0),
+	MX6_PAD_ENET2_RX_DATA1__GPIO2_IO09                    = IOMUX_PAD(0x0374, 0x00E8, 5, 0x0000, 0, 0),
+	MX6_PAD_ENET2_RX_DATA1__KPP_COL04                     = IOMUX_PAD(0x0374, 0x00E8, 6, 0x0000, 0, 0),
+	MX6_PAD_ENET2_RX_DATA1__USB_OTG1_OC                   = IOMUX_PAD(0x0374, 0x00E8, 8, 0x0664, 1, 0),
+
+	MX6_PAD_ENET2_RX_EN__ENET2_RX_EN                      = IOMUX_PAD(0x0378, 0x00EC, 0, 0x0000, 0, 0),
+	MX6_PAD_ENET2_RX_EN__UART7_DCE_TX                     = IOMUX_PAD(0x0378, 0x00EC, 1, 0x0000, 0, 0),
+	MX6_PAD_ENET2_RX_EN__UART7_DTE_RX                     = IOMUX_PAD(0x0378, 0x00EC, 1, 0x0654, 0, 0),
+	MX6_PAD_ENET2_RX_EN__SIM1_PORT0_RST_B                 = IOMUX_PAD(0x0378, 0x00EC, 2, 0x0000, 0, 0),
+	MX6_PAD_ENET2_RX_EN__I2C4_SCL                         = IOMUX_PAD(0x0378, 0x00EC, IOMUX_CONFIG_SION | 3, 0x05BC, 1, 0),
+	MX6_PAD_ENET2_RX_EN__EIM_ADDR26                       = IOMUX_PAD(0x0378, 0x00EC, 4, 0x0000, 0, 0),
+	MX6_PAD_ENET2_RX_EN__GPIO2_IO10                       = IOMUX_PAD(0x0378, 0x00EC, 5, 0x0000, 0, 0),
+	MX6_PAD_ENET2_RX_EN__KPP_ROW05                        = IOMUX_PAD(0x0378, 0x00EC, 6, 0x0000, 0, 0),
+	MX6_PAD_ENET2_RX_EN__ENET1_REF_CLK_25M                = IOMUX_PAD(0x0378, 0x00EC, 8, 0x0000, 0, 0),
+
+	MX6_PAD_ENET2_TX_DATA0__ENET2_TDATA00                 = IOMUX_PAD(0x037C, 0x00F0, 0, 0x0000, 0, 0),
+	MX6_PAD_ENET2_TX_DATA0__UART7_DCE_RX                  = IOMUX_PAD(0x037C, 0x00F0, 1, 0x0654, 1, 0),
+	MX6_PAD_ENET2_TX_DATA0__UART7_DTE_TX                  = IOMUX_PAD(0x037C, 0x00F0, 1, 0x0000, 0, 0),
+	MX6_PAD_ENET2_TX_DATA0__SIM1_PORT0_SVEN               = IOMUX_PAD(0x037C, 0x00F0, 2, 0x0000, 0, 0),
+	MX6_PAD_ENET2_TX_DATA0__I2C4_SDA                      = IOMUX_PAD(0x037C, 0x00F0, IOMUX_CONFIG_SION | 3, 0x05C0, 1, 0),
+	MX6_PAD_ENET2_TX_DATA0__EIM_EB_B02                    = IOMUX_PAD(0x037C, 0x00F0, 4, 0x0000, 0, 0),
+	MX6_PAD_ENET2_TX_DATA0__GPIO2_IO11                    = IOMUX_PAD(0x037C, 0x00F0, 5, 0x0000, 0, 0),
+	MX6_PAD_ENET2_TX_DATA0__KPP_COL05                     = IOMUX_PAD(0x037C, 0x00F0, 6, 0x0000, 0, 0),
+
+	MX6_PAD_ENET2_TX_DATA1__ENET2_TDATA01                 = IOMUX_PAD(0x0380, 0x00F4, 0, 0x0000, 0, 0),
+	MX6_PAD_ENET2_TX_DATA1__UART8_DCE_TX                  = IOMUX_PAD(0x0380, 0x00F4, 1, 0x0000, 0, 0),
+	MX6_PAD_ENET2_TX_DATA1__UART8_DTE_RX                  = IOMUX_PAD(0x0380, 0x00F4, 1, 0x065C, 0, 0),
+	MX6_PAD_ENET2_TX_DATA1__SIM2_PORT0_TRXD               = IOMUX_PAD(0x0380, 0x00F4, 2, 0x0000, 0, 0),
+	MX6_PAD_ENET2_TX_DATA1__ECSPI4_SCLK                   = IOMUX_PAD(0x0380, 0x00F4, 3, 0x0564, 0, 0),
+	MX6_PAD_ENET2_TX_DATA1__EIM_EB_B03                    = IOMUX_PAD(0x0380, 0x00F4, 4, 0x0000, 0, 0),
+	MX6_PAD_ENET2_TX_DATA1__GPIO2_IO12                    = IOMUX_PAD(0x0380, 0x00F4, 5, 0x0000, 0, 0),
+	MX6_PAD_ENET2_TX_DATA1__KPP_ROW06                     = IOMUX_PAD(0x0380, 0x00F4, 6, 0x0000, 0, 0),
+	MX6_PAD_ENET2_TX_DATA1__USB_OTG2_PWR                  = IOMUX_PAD(0x0380, 0x00F4, 8, 0x0000, 0, 0),
+
+	MX6_PAD_ENET2_TX_EN__ENET2_TX_EN                      = IOMUX_PAD(0x0384, 0x00F8, 0, 0x0000, 0, 0),
+	MX6_PAD_ENET2_TX_EN__UART8_DCE_RX                     = IOMUX_PAD(0x0384, 0x00F8, 1, 0x065C, 1, 0),
+	MX6_PAD_ENET2_TX_EN__UART8_DTE_TX                     = IOMUX_PAD(0x0384, 0x00F8, 1, 0x0000, 0, 0),
+	MX6_PAD_ENET2_TX_EN__SIM2_PORT0_CLK                   = IOMUX_PAD(0x0384, 0x00F8, 2, 0x0000, 0, 0),
+	MX6_PAD_ENET2_TX_EN__ECSPI4_MOSI                      = IOMUX_PAD(0x0384, 0x00F8, 3, 0x056C, 0, 0),
+	MX6_PAD_ENET2_TX_EN__EIM_ACLK_FREERUN                 = IOMUX_PAD(0x0384, 0x00F8, 4, 0x0000, 0, 0),
+	MX6_PAD_ENET2_TX_EN__GPIO2_IO13                       = IOMUX_PAD(0x0384, 0x00F8, 5, 0x0000, 0, 0),
+	MX6_PAD_ENET2_TX_EN__KPP_COL06                        = IOMUX_PAD(0x0384, 0x00F8, 6, 0x0000, 0, 0),
+	MX6_PAD_ENET2_TX_EN__USB_OTG2_OC                      = IOMUX_PAD(0x0384, 0x00F8, 8, 0x0660, 1, 0),
+
+	MX6_PAD_ENET2_TX_CLK__ENET2_TX_CLK                    = IOMUX_PAD(0x0388, 0x00FC, IOMUX_CONFIG_SION | 0, 0x0000, 0, 0),
+	MX6_PAD_ENET2_TX_CLK__UART8_DCE_CTS                   = IOMUX_PAD(0x0388, 0x00FC, 1, 0x0000, 0, 0),
+	MX6_PAD_ENET2_TX_CLK__UART8_DTE_RTS                   = IOMUX_PAD(0x0388, 0x00FC, 1, 0x0658, 0, 0),
+	MX6_PAD_ENET2_TX_CLK__SIM2_PORT0_RST_B                = IOMUX_PAD(0x0388, 0x00FC, 2, 0x0000, 0, 0),
+	MX6_PAD_ENET2_TX_CLK__ECSPI4_MISO                     = IOMUX_PAD(0x0388, 0x00FC, 3, 0x0568, 0, 0),
+	MX6_PAD_ENET2_TX_CLK__ENET2_REF_CLK2                  = IOMUX_PAD(0x0388, 0x00FC, IOMUX_CONFIG_SION | 4, 0x057C, 2, 0),
+	MX6_PAD_ENET2_TX_CLK__GPIO2_IO14                      = IOMUX_PAD(0x0388, 0x00FC, 5, 0x0000, 0, 0),
+	MX6_PAD_ENET2_TX_CLK__KPP_ROW07                       = IOMUX_PAD(0x0388, 0x00FC, 6, 0x0000, 0, 0),
+	MX6_PAD_ENET2_TX_CLK__ANATOP_OTG2_ID                  = IOMUX_PAD(0x0388, 0x00FC, 8, 0x04BC, 1, 0),
+
+	MX6_PAD_ENET2_RX_ER__ENET2_RX_ER                      = IOMUX_PAD(0x038C, 0x0100, 0, 0x0000, 0, 0),
+	MX6_PAD_ENET2_RX_ER__UART8_DCE_RTS                    = IOMUX_PAD(0x038C, 0x0100, 1, 0x0658, 1, 0),
+	MX6_PAD_ENET2_RX_ER__UART8_DTE_CTS                    = IOMUX_PAD(0x038C, 0x0100, 1, 0x0000, 0, 0),
+	MX6_PAD_ENET2_RX_ER__SIM2_PORT0_SVEN                  = IOMUX_PAD(0x038C, 0x0100, 2, 0x0000, 0, 0),
+	MX6_PAD_ENET2_RX_ER__ECSPI4_SS0                       = IOMUX_PAD(0x038C, 0x0100, 3, 0x0570, 0, 0),
+	MX6_PAD_ENET2_RX_ER__EIM_ADDR25                       = IOMUX_PAD(0x038C, 0x0100, 4, 0x0000, 0, 0),
+	MX6_PAD_ENET2_RX_ER__GPIO2_IO15                       = IOMUX_PAD(0x038C, 0x0100, 5, 0x0000, 0, 0),
+	MX6_PAD_ENET2_RX_ER__KPP_COL07                        = IOMUX_PAD(0x038C, 0x0100, 6, 0x0000, 0, 0),
+	MX6_PAD_ENET2_RX_ER__WDOG1_WDOG_ANY                   = IOMUX_PAD(0x038C, 0x0100, 8, 0x0000, 0, 0),
+
+	MX6_PAD_LCD_CLK__LCDIF_CLK                            = IOMUX_PAD(0x0390, 0x0104, 0, 0x0000, 0, 0),
+	MX6_PAD_LCD_CLK__LCDIF_WR_RWN                         = IOMUX_PAD(0x0390, 0x0104, 1, 0x0000, 0, 0),
+	MX6_PAD_LCD_CLK__UART4_DCE_TX                         = IOMUX_PAD(0x0390, 0x0104, 2, 0x0000, 0, 0),
+	MX6_PAD_LCD_CLK__UART4_DTE_RX                         = IOMUX_PAD(0x0390, 0x0104, 2, 0x063C, 2, 0),
+	MX6_PAD_LCD_CLK__SAI3_MCLK                            = IOMUX_PAD(0x0390, 0x0104, 3, 0x0600, 0, 0),
+	MX6_PAD_LCD_CLK__EIM_CS2_B                            = IOMUX_PAD(0x0390, 0x0104, 4, 0x0000, 0, 0),
+	MX6_PAD_LCD_CLK__GPIO3_IO00                           = IOMUX_PAD(0x0390, 0x0104, 5, 0x0000, 0, 0),
+	MX6_PAD_LCD_CLK__WDOG1_WDOG_RST_B_DEB                 = IOMUX_PAD(0x0390, 0x0104, 8, 0x0000, 0, 0),
+
+	MX6_PAD_LCD_ENABLE__LCDIF_ENABLE                      = IOMUX_PAD(0x0394, 0x0108, 0, 0x0000, 0, 0),
+	MX6_PAD_LCD_ENABLE__LCDIF_RD_E                        = IOMUX_PAD(0x0394, 0x0108, 1, 0x0000, 0, 0),
+	MX6_PAD_LCD_ENABLE__UART4_DCE_RX                      = IOMUX_PAD(0x0394, 0x0108, 2, 0x063C, 3, 0),
+	MX6_PAD_LCD_ENABLE__UART4_DTE_TX                      = IOMUX_PAD(0x0394, 0x0108, 2, 0x0000, 0, 0),
+	MX6_PAD_LCD_ENABLE__SAI3_TX_SYNC                      = IOMUX_PAD(0x0394, 0x0108, 3, 0x060C, 0, 0),
+	MX6_PAD_LCD_ENABLE__EIM_CS3_B                         = IOMUX_PAD(0x0394, 0x0108, 4, 0x0000, 0, 0),
+	MX6_PAD_LCD_ENABLE__GPIO3_IO01                        = IOMUX_PAD(0x0394, 0x0108, 5, 0x0000, 0, 0),
+	MX6_PAD_LCD_ENABLE__ECSPI2_RDY                        = IOMUX_PAD(0x0394, 0x0108, 8, 0x0000, 0, 0),
+
+	MX6_PAD_LCD_HSYNC__LCDIF_HSYNC                        = IOMUX_PAD(0x0398, 0x010C, 0, 0x05DC, 0, 0),
+	MX6_PAD_LCD_HSYNC__LCDIF_RS                           = IOMUX_PAD(0x0398, 0x010C, 1, 0x0000, 0, 0),
+	MX6_PAD_LCD_HSYNC__UART4_DCE_CTS                      = IOMUX_PAD(0x0398, 0x010C, 2, 0x0000, 0, 0),
+	MX6_PAD_LCD_HSYNC__UART4_DTE_RTS                      = IOMUX_PAD(0x0398, 0x010C, 2, 0x0638, 2, 0),
+	MX6_PAD_LCD_HSYNC__SAI3_TX_BCLK                       = IOMUX_PAD(0x0398, 0x010C, 3, 0x0608, 0, 0),
+	MX6_PAD_LCD_HSYNC__WDOG3_WDOG_RST_B_DEB               = IOMUX_PAD(0x0398, 0x010C, 4, 0x0000, 0, 0),
+	MX6_PAD_LCD_HSYNC__GPIO3_IO02                         = IOMUX_PAD(0x0398, 0x010C, 5, 0x0000, 0, 0),
+	MX6_PAD_LCD_HSYNC__ECSPI2_SS1                         = IOMUX_PAD(0x0398, 0x010C, 8, 0x0000, 0, 0),
+
+	MX6_PAD_LCD_VSYNC__LCDIF_VSYNC                        = IOMUX_PAD(0x039C, 0x0110, 0, 0x0000, 0, 0),
+	MX6_PAD_LCD_VSYNC__LCDIF_BUSY                         = IOMUX_PAD(0x039C, 0x0110, 1, 0x05DC, 1, 0),
+	MX6_PAD_LCD_VSYNC__UART4_DCE_RTS                      = IOMUX_PAD(0x039C, 0x0110, 2, 0x0638, 3, 0),
+	MX6_PAD_LCD_VSYNC__UART4_DTE_CTS                      = IOMUX_PAD(0x039C, 0x0110, 2, 0x0000, 0, 0),
+	MX6_PAD_LCD_VSYNC__SAI3_RX_DATA                       = IOMUX_PAD(0x039C, 0x0110, 3, 0x0604, 0, 0),
+	MX6_PAD_LCD_VSYNC__WDOG2_WDOG_B                       = IOMUX_PAD(0x039C, 0x0110, 4, 0x0000, 0, 0),
+	MX6_PAD_LCD_VSYNC__GPIO3_IO03                         = IOMUX_PAD(0x039C, 0x0110, 5, 0x0000, 0, 0),
+	MX6_PAD_LCD_VSYNC__ECSPI2_SS2                         = IOMUX_PAD(0x039C, 0x0110, 8, 0x0000, 0, 0),
+
+	MX6_PAD_LCD_RESET__LCDIF_RESET                        = IOMUX_PAD(0x03A0, 0x0114, 0, 0x0000, 0, 0),
+	MX6_PAD_LCD_RESET__LCDIF_CS                           = IOMUX_PAD(0x03A0, 0x0114, 1, 0x0000, 0, 0),
+	MX6_PAD_LCD_RESET__CA7_MX6ULL_EVENTI                  = IOMUX_PAD(0x03A0, 0x0114, 2, 0x0000, 0, 0),
+	MX6_PAD_LCD_RESET__SAI3_TX_DATA                       = IOMUX_PAD(0x03A0, 0x0114, 3, 0x0000, 0, 0),
+	MX6_PAD_LCD_RESET__WDOG1_WDOG_ANY                     = IOMUX_PAD(0x03A0, 0x0114, 4, 0x0000, 0, 0),
+	MX6_PAD_LCD_RESET__GPIO3_IO04                         = IOMUX_PAD(0x03A0, 0x0114, 5, 0x0000, 0, 0),
+	MX6_PAD_LCD_RESET__ECSPI2_SS3                         = IOMUX_PAD(0x03A0, 0x0114, 8, 0x0000, 0, 0),
+
+	MX6_PAD_LCD_DATA00__LCDIF_DATA00                      = IOMUX_PAD(0x03A4, 0x0118, 0, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA00__PWM1_OUT                          = IOMUX_PAD(0x03A4, 0x0118, 1, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA00__ENET1_1588_EVENT2_IN              = IOMUX_PAD(0x03A4, 0x0118, 3, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA00__I2C3_SDA                          = IOMUX_PAD(0x03A4, 0x0118, IOMUX_CONFIG_SION | 4, 0x05B8, 2, 0),
+	MX6_PAD_LCD_DATA00__GPIO3_IO05                        = IOMUX_PAD(0x03A4, 0x0118, 5, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA00__SRC_BT_CFG00                      = IOMUX_PAD(0x03A4, 0x0118, 6, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA00__SAI1_MCLK                         = IOMUX_PAD(0x03A4, 0x0118, 8, 0x05E0, 1, 0),
+
+	MX6_PAD_LCD_DATA01__LCDIF_DATA01                      = IOMUX_PAD(0x03A8, 0x011C, 0, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA01__PWM2_OUT                          = IOMUX_PAD(0x03A8, 0x011C, 1, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA01__ENET1_1588_EVENT2_OUT             = IOMUX_PAD(0x03A8, 0x011C, 3, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA01__I2C3_SCL                          = IOMUX_PAD(0x03A8, 0x011C, IOMUX_CONFIG_SION | 4, 0x05B4, 2, 0),
+	MX6_PAD_LCD_DATA01__GPIO3_IO06                        = IOMUX_PAD(0x03A8, 0x011C, 5, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA01__SRC_BT_CFG01                      = IOMUX_PAD(0x03A8, 0x011C, 6, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA01__SAI1_TX_SYNC                      = IOMUX_PAD(0x03A8, 0x011C, 8, 0x05EC, 0, 0),
+
+	MX6_PAD_LCD_DATA02__LCDIF_DATA02                      = IOMUX_PAD(0x03AC, 0x0120, 0, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA02__PWM3_OUT                          = IOMUX_PAD(0x03AC, 0x0120, 1, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA02__ENET1_1588_EVENT3_IN              = IOMUX_PAD(0x03AC, 0x0120, 3, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA02__I2C4_SDA                          = IOMUX_PAD(0x03AC, 0x0120, IOMUX_CONFIG_SION | 4, 0x05C0, 2, 0),
+	MX6_PAD_LCD_DATA02__GPIO3_IO07                        = IOMUX_PAD(0x03AC, 0x0120, 5, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA02__SRC_BT_CFG02                      = IOMUX_PAD(0x03AC, 0x0120, 6, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA02__SAI1_TX_BCLK                      = IOMUX_PAD(0x03AC, 0x0120, 8, 0x05E8, 0, 0),
+
+	MX6_PAD_LCD_DATA03__LCDIF_DATA03                      = IOMUX_PAD(0x03B0, 0x0124, 0, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA03__PWM4_OUT                          = IOMUX_PAD(0x03B0, 0x0124, 1, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA03__ENET1_1588_EVENT3_OUT             = IOMUX_PAD(0x03B0, 0x0124, 3, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA03__I2C4_SCL                          = IOMUX_PAD(0x03B0, 0x0124, IOMUX_CONFIG_SION | 4, 0x05BC, 2, 0),
+	MX6_PAD_LCD_DATA03__GPIO3_IO08                        = IOMUX_PAD(0x03B0, 0x0124, 5, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA03__SRC_BT_CFG03                      = IOMUX_PAD(0x03B0, 0x0124, 6, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA03__SAI1_RX_DATA                      = IOMUX_PAD(0x03B0, 0x0124, 8, 0x05E4, 0, 0),
+
+	MX6_PAD_LCD_DATA04__LCDIF_DATA04                      = IOMUX_PAD(0x03B4, 0x0128, 0, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA04__UART8_DCE_CTS                     = IOMUX_PAD(0x03B4, 0x0128, 1, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA04__UART8_DTE_RTS                     = IOMUX_PAD(0x03B4, 0x0128, 1, 0x0658, 2, 0),
+	MX6_PAD_LCD_DATA04__ENET2_1588_EVENT2_IN              = IOMUX_PAD(0x03B4, 0x0128, 3, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA04__SPDIF_SR_CLK                      = IOMUX_PAD(0x03B4, 0x0128, 4, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA04__GPIO3_IO09                        = IOMUX_PAD(0x03B4, 0x0128, 5, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA04__SRC_BT_CFG04                      = IOMUX_PAD(0x03B4, 0x0128, 6, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA04__SAI1_TX_DATA                      = IOMUX_PAD(0x03B4, 0x0128, 8, 0x0000, 0, 0),
+
+	MX6_PAD_LCD_DATA05__LCDIF_DATA05                      = IOMUX_PAD(0x03B8, 0x012C, 0, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA05__UART8_DCE_RTS                     = IOMUX_PAD(0x03B8, 0x012C, 1, 0x0658, 3, 0),
+	MX6_PAD_LCD_DATA05__UART8_DTE_CTS                     = IOMUX_PAD(0x03B8, 0x012C, 1, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA05__ENET2_1588_EVENT2_OUT             = IOMUX_PAD(0x03B8, 0x012C, 3, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA05__SPDIF_OUT                         = IOMUX_PAD(0x03B8, 0x012C, 4, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA05__GPIO3_IO10                        = IOMUX_PAD(0x03B8, 0x012C, 5, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA05__SRC_BT_CFG05                      = IOMUX_PAD(0x03B8, 0x012C, 6, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA05__ECSPI1_SS1                        = IOMUX_PAD(0x03B8, 0x012C, 8, 0x0000, 0, 0),
+
+	MX6_PAD_LCD_DATA06__LCDIF_DATA06                      = IOMUX_PAD(0x03BC, 0x0130, 0, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA06__UART7_DCE_CTS                     = IOMUX_PAD(0x03BC, 0x0130, 1, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA06__UART7_DTE_RTS                     = IOMUX_PAD(0x03BC, 0x0130, 1, 0x0650, 2, 0),
+	MX6_PAD_LCD_DATA06__ENET2_1588_EVENT3_IN              = IOMUX_PAD(0x03BC, 0x0130, 3, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA06__SPDIF_LOCK                        = IOMUX_PAD(0x03BC, 0x0130, 4, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA06__GPIO3_IO11                        = IOMUX_PAD(0x03BC, 0x0130, 5, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA06__SRC_BT_CFG06                      = IOMUX_PAD(0x03BC, 0x0130, 6, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA06__ECSPI1_SS2                        = IOMUX_PAD(0x03BC, 0x0130, 8, 0x0000, 0, 0),
+
+	MX6_PAD_LCD_DATA07__LCDIF_DATA07                      = IOMUX_PAD(0x03C0, 0x0134, 0, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA07__UART7_DCE_RTS                     = IOMUX_PAD(0x03C0, 0x0134, 1, 0x0650, 3, 0),
+	MX6_PAD_LCD_DATA07__UART7_DTE_CTS                     = IOMUX_PAD(0x03C0, 0x0134, 1, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA07__ENET2_1588_EVENT3_OUT             = IOMUX_PAD(0x03C0, 0x0134, 3, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA07__SPDIF_EXT_CLK                     = IOMUX_PAD(0x03C0, 0x0134, 4, 0x061C, 0, 0),
+	MX6_PAD_LCD_DATA07__GPIO3_IO12                        = IOMUX_PAD(0x03C0, 0x0134, 5, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA07__SRC_BT_CFG07                      = IOMUX_PAD(0x03C0, 0x0134, 6, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA07__ECSPI1_SS3                        = IOMUX_PAD(0x03C0, 0x0134, 8, 0x0000, 0, 0),
+
+	MX6_PAD_LCD_DATA08__LCDIF_DATA08                      = IOMUX_PAD(0x03C4, 0x0138, 0, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA08__SPDIF_IN                          = IOMUX_PAD(0x03C4, 0x0138, 1, 0x0618, 2, 0),
+	MX6_PAD_LCD_DATA08__CSI_DATA16                        = IOMUX_PAD(0x03C4, 0x0138, 3, 0x0504, 1, 0),
+	MX6_PAD_LCD_DATA08__EIM_DATA00                        = IOMUX_PAD(0x03C4, 0x0138, 4, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA08__GPIO3_IO13                        = IOMUX_PAD(0x03C4, 0x0138, 5, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA08__SRC_BT_CFG08                      = IOMUX_PAD(0x03C4, 0x0138, 6, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA08__FLEXCAN1_TX                       = IOMUX_PAD(0x03C4, 0x0138, 8, 0x0000, 0, 0),
+
+	MX6_PAD_LCD_DATA09__LCDIF_DATA09                      = IOMUX_PAD(0x03C8, 0x013C, 0, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA09__SAI3_MCLK                         = IOMUX_PAD(0x03C8, 0x013C, 1, 0x0600, 1, 0),
+	MX6_PAD_LCD_DATA09__CSI_DATA17                        = IOMUX_PAD(0x03C8, 0x013C, 3, 0x0508, 1, 0),
+	MX6_PAD_LCD_DATA09__EIM_DATA01                        = IOMUX_PAD(0x03C8, 0x013C, 4, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA09__GPIO3_IO14                        = IOMUX_PAD(0x03C8, 0x013C, 5, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA09__SRC_BT_CFG09                      = IOMUX_PAD(0x03C8, 0x013C, 6, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA09__FLEXCAN1_RX                       = IOMUX_PAD(0x03C8, 0x013C, 8, 0x0584, 2, 0),
+
+	MX6_PAD_LCD_DATA10__LCDIF_DATA10                      = IOMUX_PAD(0x03CC, 0x0140, 0, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA10__SAI3_RX_SYNC                      = IOMUX_PAD(0x03CC, 0x0140, 1, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA10__CSI_DATA18                        = IOMUX_PAD(0x03CC, 0x0140, 3, 0x050C, 1, 0),
+	MX6_PAD_LCD_DATA10__EIM_DATA02                        = IOMUX_PAD(0x03CC, 0x0140, 4, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA10__GPIO3_IO15                        = IOMUX_PAD(0x03CC, 0x0140, 5, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA10__SRC_BT_CFG10                      = IOMUX_PAD(0x03CC, 0x0140, 6, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA10__FLEXCAN2_TX                       = IOMUX_PAD(0x03CC, 0x0140, 8, 0x0000, 0, 0),
+
+	MX6_PAD_LCD_DATA11__LCDIF_DATA11                      = IOMUX_PAD(0x03D0, 0x0144, 0, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA11__SAI3_RX_BCLK                      = IOMUX_PAD(0x03D0, 0x0144, 1, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA11__CSI_DATA19                        = IOMUX_PAD(0x03D0, 0x0144, 3, 0x0510, 1, 0),
+	MX6_PAD_LCD_DATA11__EIM_DATA03                        = IOMUX_PAD(0x03D0, 0x0144, 4, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA11__GPIO3_IO16                        = IOMUX_PAD(0x03D0, 0x0144, 5, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA11__SRC_BT_CFG11                      = IOMUX_PAD(0x03D0, 0x0144, 6, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA11__FLEXCAN2_RX                       = IOMUX_PAD(0x03D0, 0x0144, 8, 0x0588, 2, 0),
+
+	MX6_PAD_LCD_DATA12__LCDIF_DATA12                      = IOMUX_PAD(0x03D4, 0x0148, 0, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA12__SAI3_TX_SYNC                      = IOMUX_PAD(0x03D4, 0x0148, 1, 0x060C, 1, 0),
+	MX6_PAD_LCD_DATA12__CSI_DATA20                        = IOMUX_PAD(0x03D4, 0x0148, 3, 0x0514, 1, 0),
+	MX6_PAD_LCD_DATA12__EIM_DATA04                        = IOMUX_PAD(0x03D4, 0x0148, 4, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA12__GPIO3_IO17                        = IOMUX_PAD(0x03D4, 0x0148, 5, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA12__SRC_BT_CFG12                      = IOMUX_PAD(0x03D4, 0x0148, 6, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA12__ECSPI1_RDY                        = IOMUX_PAD(0x03D4, 0x0148, 8, 0x0000, 0, 0),
+
+	MX6_PAD_LCD_DATA13__LCDIF_DATA13                      = IOMUX_PAD(0x03D8, 0x014C, 0, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA13__SAI3_TX_BCLK                      = IOMUX_PAD(0x03D8, 0x014C, 1, 0x0608, 1, 0),
+	MX6_PAD_LCD_DATA13__CSI_DATA21                        = IOMUX_PAD(0x03D8, 0x014C, 3, 0x0518, 1, 0),
+	MX6_PAD_LCD_DATA13__EIM_DATA05                        = IOMUX_PAD(0x03D8, 0x014C, 4, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA13__GPIO3_IO18                        = IOMUX_PAD(0x03D8, 0x014C, 5, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA13__SRC_BT_CFG13                      = IOMUX_PAD(0x03D8, 0x014C, 6, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA13__USDHC2_RESET_B                    = IOMUX_PAD(0x03D8, 0x014C, 8, 0x0000, 0, 0),
+
+	MX6_PAD_LCD_DATA14__LCDIF_DATA14                      = IOMUX_PAD(0x03DC, 0x0150, 0, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA14__SAI3_RX_DATA                      = IOMUX_PAD(0x03DC, 0x0150, 1, 0x0604, 1, 0),
+	MX6_PAD_LCD_DATA14__CSI_DATA22                        = IOMUX_PAD(0x03DC, 0x0150, 3, 0x051C, 1, 0),
+	MX6_PAD_LCD_DATA14__EIM_DATA06                        = IOMUX_PAD(0x03DC, 0x0150, 4, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA14__GPIO3_IO19                        = IOMUX_PAD(0x03DC, 0x0150, 5, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA14__SRC_BT_CFG14                      = IOMUX_PAD(0x03DC, 0x0150, 6, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA14__USDHC2_DATA4                      = IOMUX_PAD(0x03DC, 0x0150, 8, 0x068C, 0, 0),
+
+	MX6_PAD_LCD_DATA15__LCDIF_DATA15                      = IOMUX_PAD(0x03E0, 0x0154, 0, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA15__SAI3_TX_DATA                      = IOMUX_PAD(0x03E0, 0x0154, 1, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA15__CSI_DATA23                        = IOMUX_PAD(0x03E0, 0x0154, 3, 0x0520, 1, 0),
+	MX6_PAD_LCD_DATA15__EIM_DATA07                        = IOMUX_PAD(0x03E0, 0x0154, 4, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA15__GPIO3_IO20                        = IOMUX_PAD(0x03E0, 0x0154, 5, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA15__SRC_BT_CFG15                      = IOMUX_PAD(0x03E0, 0x0154, 6, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA15__USDHC2_DATA5                      = IOMUX_PAD(0x03E0, 0x0154, 8, 0x0690, 0, 0),
+
+	MX6_PAD_LCD_DATA16__LCDIF_DATA16                      = IOMUX_PAD(0x03E4, 0x0158, 0, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA16__UART7_DCE_TX                      = IOMUX_PAD(0x03E4, 0x0158, 1, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA16__UART7_DTE_RX                      = IOMUX_PAD(0x03E4, 0x0158, 1, 0x0654, 2, 0),
+	MX6_PAD_LCD_DATA16__CSI_DATA01                        = IOMUX_PAD(0x03E4, 0x0158, 3, 0x04D4, 1, 0),
+	MX6_PAD_LCD_DATA16__EIM_DATA08                        = IOMUX_PAD(0x03E4, 0x0158, 4, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA16__GPIO3_IO21                        = IOMUX_PAD(0x03E4, 0x0158, 5, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA16__SRC_BT_CFG24                      = IOMUX_PAD(0x03E4, 0x0158, 6, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA16__USDHC2_DATA6                      = IOMUX_PAD(0x03E4, 0x0158, 8, 0x0694, 0, 0),
+
+	MX6_PAD_LCD_DATA17__LCDIF_DATA17                      = IOMUX_PAD(0x03E8, 0x015C, 0, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA17__UART7_DCE_RX                      = IOMUX_PAD(0x03E8, 0x015C, 1, 0x0654, 3, 0),
+	MX6_PAD_LCD_DATA17__UART7_DTE_TX                      = IOMUX_PAD(0x03E8, 0x015C, 1, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA17__CSI_DATA00                        = IOMUX_PAD(0x03E8, 0x015C, 3, 0x04D0, 1, 0),
+	MX6_PAD_LCD_DATA17__EIM_DATA09                        = IOMUX_PAD(0x03E8, 0x015C, 4, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA17__GPIO3_IO22                        = IOMUX_PAD(0x03E8, 0x015C, 5, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA17__SRC_BT_CFG25                      = IOMUX_PAD(0x03E8, 0x015C, 6, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA17__USDHC2_DATA7                      = IOMUX_PAD(0x03E8, 0x015C, 8, 0x0698, 0, 0),
+
+	MX6_PAD_LCD_DATA18__LCDIF_DATA18                      = IOMUX_PAD(0x03EC, 0x0160, 0, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA18__PWM5_OUT                          = IOMUX_PAD(0x03EC, 0x0160, 1, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA18__CA7_MX6ULL_EVENTO                 = IOMUX_PAD(0x03EC, 0x0160, 2, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA18__CSI_DATA10                        = IOMUX_PAD(0x03EC, 0x0160, 3, 0x04EC, 1, 0),
+	MX6_PAD_LCD_DATA18__EIM_DATA10                        = IOMUX_PAD(0x03EC, 0x0160, 4, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA18__GPIO3_IO23                        = IOMUX_PAD(0x03EC, 0x0160, 5, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA18__SRC_BT_CFG26                      = IOMUX_PAD(0x03EC, 0x0160, 6, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA18__USDHC2_CMD                        = IOMUX_PAD(0x03EC, 0x0160, 8, 0x0678, 1, 0),
+	MX6_PAD_LCD_DATA19__EIM_DATA11                        = IOMUX_PAD(0x03F0, 0x0164, 4, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA19__GPIO3_IO24                        = IOMUX_PAD(0x03F0, 0x0164, 5, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA19__SRC_BT_CFG27                      = IOMUX_PAD(0x03F0, 0x0164, 6, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA19__USDHC2_CLK                        = IOMUX_PAD(0x03F0, 0x0164, 8, 0x0670, 1, 0),
+
+	MX6_PAD_LCD_DATA19__LCDIF_DATA19                      = IOMUX_PAD(0x03F0, 0x0164, 0, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA19__PWM6_OUT                          = IOMUX_PAD(0x03F0, 0x0164, 1, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA19__WDOG1_WDOG_ANY                    = IOMUX_PAD(0x03F0, 0x0164, 2, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA19__CSI_DATA11                        = IOMUX_PAD(0x03F0, 0x0164, 3, 0x04F0, 1, 0),
+	MX6_PAD_LCD_DATA20__EIM_DATA12                        = IOMUX_PAD(0x03F4, 0x0168, 4, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA20__GPIO3_IO25                        = IOMUX_PAD(0x03F4, 0x0168, 5, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA20__SRC_BT_CFG28                      = IOMUX_PAD(0x03F4, 0x0168, 6, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA20__USDHC2_DATA0                      = IOMUX_PAD(0x03F4, 0x0168, 8, 0x067C, 1, 0),
+
+	MX6_PAD_LCD_DATA20__LCDIF_DATA20                      = IOMUX_PAD(0x03F4, 0x0168, 0, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA20__UART8_DCE_TX                      = IOMUX_PAD(0x03F4, 0x0168, 1, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA20__UART8_DTE_RX                      = IOMUX_PAD(0x03F4, 0x0168, 1, 0x065C, 2, 0),
+	MX6_PAD_LCD_DATA20__ECSPI1_SCLK                       = IOMUX_PAD(0x03F4, 0x0168, 2, 0x0534, 0, 0),
+	MX6_PAD_LCD_DATA20__CSI_DATA12                        = IOMUX_PAD(0x03F4, 0x0168, 3, 0x04F4, 1, 0),
+
+	MX6_PAD_LCD_DATA21__LCDIF_DATA21                      = IOMUX_PAD(0x03F8, 0x016C, 0, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA21__UART8_DCE_RX                      = IOMUX_PAD(0x03F8, 0x016C, 1, 0x065C, 3, 0),
+	MX6_PAD_LCD_DATA21__UART8_DTE_TX                      = IOMUX_PAD(0x03F8, 0x016C, 1, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA21__ECSPI1_SS0                        = IOMUX_PAD(0x03F8, 0x016C, 2, 0x0540, 0, 0),
+	MX6_PAD_LCD_DATA21__CSI_DATA13                        = IOMUX_PAD(0x03F8, 0x016C, 3, 0x04F8, 1, 0),
+	MX6_PAD_LCD_DATA21__EIM_DATA13                        = IOMUX_PAD(0x03F8, 0x016C, 4, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA21__GPIO3_IO26                        = IOMUX_PAD(0x03F8, 0x016C, 5, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA21__SRC_BT_CFG29                      = IOMUX_PAD(0x03F8, 0x016C, 6, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA21__USDHC2_DATA1                      = IOMUX_PAD(0x03F8, 0x016C, 8, 0x0680, 1, 0),
+
+	MX6_PAD_LCD_DATA22__LCDIF_DATA22                      = IOMUX_PAD(0x03FC, 0x0170, 0, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA22__MQS_RIGHT                         = IOMUX_PAD(0x03FC, 0x0170, 1, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA22__ECSPI1_MOSI                       = IOMUX_PAD(0x03FC, 0x0170, 2, 0x053C, 0, 0),
+	MX6_PAD_LCD_DATA22__CSI_DATA14                        = IOMUX_PAD(0x03FC, 0x0170, 3, 0x04FC, 1, 0),
+	MX6_PAD_LCD_DATA22__EIM_DATA14                        = IOMUX_PAD(0x03FC, 0x0170, 4, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA22__GPIO3_IO27                        = IOMUX_PAD(0x03FC, 0x0170, 5, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA22__SRC_BT_CFG30                      = IOMUX_PAD(0x03FC, 0x0170, 6, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA22__USDHC2_DATA2                      = IOMUX_PAD(0x03FC, 0x0170, 8, 0x0684, 0, 0),
+
+	MX6_PAD_LCD_DATA23__LCDIF_DATA23                      = IOMUX_PAD(0x0400, 0x0174, 0, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA23__MQS_LEFT                          = IOMUX_PAD(0x0400, 0x0174, 1, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA23__ECSPI1_MISO                       = IOMUX_PAD(0x0400, 0x0174, 2, 0x0538, 0, 0),
+	MX6_PAD_LCD_DATA23__CSI_DATA15                        = IOMUX_PAD(0x0400, 0x0174, 3, 0x0500, 1, 0),
+	MX6_PAD_LCD_DATA23__EIM_DATA15                        = IOMUX_PAD(0x0400, 0x0174, 4, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA23__GPIO3_IO28                        = IOMUX_PAD(0x0400, 0x0174, 5, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA23__SRC_BT_CFG31                      = IOMUX_PAD(0x0400, 0x0174, 6, 0x0000, 0, 0),
+	MX6_PAD_LCD_DATA23__USDHC2_DATA3                      = IOMUX_PAD(0x0400, 0x0174, 8, 0x0688, 1, 0),
+
+	MX6_PAD_NAND_RE_B__RAWNAND_RE_B                       = IOMUX_PAD(0x0404, 0x0178, 0, 0x0000, 0, 0),
+	MX6_PAD_NAND_RE_B__USDHC2_CLK                         = IOMUX_PAD(0x0404, 0x0178, 1, 0x0670, 2, 0),
+	MX6_PAD_NAND_RE_B__QSPI_B_SCLK                        = IOMUX_PAD(0x0404, 0x0178, 2, 0x0000, 0, 0),
+	MX6_PAD_NAND_RE_B__KPP_ROW00                          = IOMUX_PAD(0x0404, 0x0178, 3, 0x05D0, 1, 0),
+	MX6_PAD_NAND_RE_B__EIM_EB_B00                         = IOMUX_PAD(0x0404, 0x0178, 4, 0x0000, 0, 0),
+	MX6_PAD_NAND_RE_B__GPIO4_IO00                         = IOMUX_PAD(0x0404, 0x0178, 5, 0x0000, 0, 0),
+	MX6_PAD_NAND_RE_B__ECSPI3_SS2                         = IOMUX_PAD(0x0404, 0x0178, 8, 0x0000, 0, 0),
+
+	MX6_PAD_NAND_WE_B__RAWNAND_WE_B                       = IOMUX_PAD(0x0408, 0x017C, 0, 0x0000, 0, 0),
+	MX6_PAD_NAND_WE_B__USDHC2_CMD                         = IOMUX_PAD(0x0408, 0x017C, 1, 0x0678, 2, 0),
+	MX6_PAD_NAND_WE_B__QSPI_B_SS0_B                       = IOMUX_PAD(0x0408, 0x017C, 2, 0x0000, 0, 0),
+	MX6_PAD_NAND_WE_B__KPP_COL00                          = IOMUX_PAD(0x0408, 0x017C, 3, 0x05C4, 1, 0),
+	MX6_PAD_NAND_WE_B__EIM_EB_B01                         = IOMUX_PAD(0x0408, 0x017C, 4, 0x0000, 0, 0),
+	MX6_PAD_NAND_WE_B__GPIO4_IO01                         = IOMUX_PAD(0x0408, 0x017C, 5, 0x0000, 0, 0),
+	MX6_PAD_NAND_WE_B__ECSPI3_SS3                         = IOMUX_PAD(0x0408, 0x017C, 8, 0x0000, 0, 0),
+
+	MX6_PAD_NAND_DATA00__RAWNAND_DATA00                   = IOMUX_PAD(0x040C, 0x0180, 0, 0x0000, 0, 0),
+	MX6_PAD_NAND_DATA00__USDHC2_DATA0                     = IOMUX_PAD(0x040C, 0x0180, 1, 0x067C, 2, 0),
+	MX6_PAD_NAND_DATA00__QSPI_B_SS1_B                     = IOMUX_PAD(0x040C, 0x0180, 2, 0x0000, 0, 0),
+	MX6_PAD_NAND_DATA00__KPP_ROW01                        = IOMUX_PAD(0x040C, 0x0180, 3, 0x05D4, 1, 0),
+	MX6_PAD_NAND_DATA00__EIM_AD08                         = IOMUX_PAD(0x040C, 0x0180, 4, 0x0000, 0, 0),
+	MX6_PAD_NAND_DATA00__GPIO4_IO02                       = IOMUX_PAD(0x040C, 0x0180, 5, 0x0000, 0, 0),
+	MX6_PAD_NAND_DATA00__ECSPI4_RDY                       = IOMUX_PAD(0x040C, 0x0180, 8, 0x0000, 0, 0),
+
+	MX6_PAD_NAND_DATA01__RAWNAND_DATA01                   = IOMUX_PAD(0x0410, 0x0184, 0, 0x0000, 0, 0),
+	MX6_PAD_NAND_DATA01__USDHC2_DATA1                     = IOMUX_PAD(0x0410, 0x0184, 1, 0x0680, 2, 0),
+	MX6_PAD_NAND_DATA01__QSPI_B_DQS                       = IOMUX_PAD(0x0410, 0x0184, 2, 0x0000, 0, 0),
+	MX6_PAD_NAND_DATA01__KPP_COL01                        = IOMUX_PAD(0x0410, 0x0184, 3, 0x05C8, 1, 0),
+	MX6_PAD_NAND_DATA01__EIM_AD09                         = IOMUX_PAD(0x0410, 0x0184, 4, 0x0000, 0, 0),
+	MX6_PAD_NAND_DATA01__GPIO4_IO03                       = IOMUX_PAD(0x0410, 0x0184, 5, 0x0000, 0, 0),
+	MX6_PAD_NAND_DATA01__ECSPI4_SS1                       = IOMUX_PAD(0x0410, 0x0184, 8, 0x0000, 0, 0),
+
+	MX6_PAD_NAND_DATA02__RAWNAND_DATA02                   = IOMUX_PAD(0x0414, 0x0188, 0, 0x0000, 0, 0),
+	MX6_PAD_NAND_DATA02__USDHC2_DATA2                     = IOMUX_PAD(0x0414, 0x0188, 1, 0x0684, 1, 0),
+	MX6_PAD_NAND_DATA02__QSPI_B_DATA00                    = IOMUX_PAD(0x0414, 0x0188, 2, 0x0000, 0, 0),
+	MX6_PAD_NAND_DATA02__KPP_ROW02                        = IOMUX_PAD(0x0414, 0x0188, 3, 0x05D8, 1, 0),
+	MX6_PAD_NAND_DATA02__EIM_AD10                         = IOMUX_PAD(0x0414, 0x0188, 4, 0x0000, 0, 0),
+	MX6_PAD_NAND_DATA02__GPIO4_IO04                       = IOMUX_PAD(0x0414, 0x0188, 5, 0x0000, 0, 0),
+	MX6_PAD_NAND_DATA02__ECSPI4_SS2                       = IOMUX_PAD(0x0414, 0x0188, 8, 0x0000, 0, 0),
+
+	MX6_PAD_NAND_DATA03__RAWNAND_DATA03                   = IOMUX_PAD(0x0418, 0x018C, 0, 0x0000, 0, 0),
+	MX6_PAD_NAND_DATA03__USDHC2_DATA3                     = IOMUX_PAD(0x0418, 0x018C, 1, 0x0688, 2, 0),
+	MX6_PAD_NAND_DATA03__QSPI_B_DATA01                    = IOMUX_PAD(0x0418, 0x018C, 2, 0x0000, 0, 0),
+	MX6_PAD_NAND_DATA03__KPP_COL02                        = IOMUX_PAD(0x0418, 0x018C, 3, 0x05CC, 1, 0),
+	MX6_PAD_NAND_DATA03__EIM_AD11                         = IOMUX_PAD(0x0418, 0x018C, 4, 0x0000, 0, 0),
+	MX6_PAD_NAND_DATA03__GPIO4_IO05                       = IOMUX_PAD(0x0418, 0x018C, 5, 0x0000, 0, 0),
+	MX6_PAD_NAND_DATA03__ECSPI4_SS3                       = IOMUX_PAD(0x0418, 0x018C, 8, 0x0000, 0, 0),
+
+	MX6_PAD_NAND_DATA04__RAWNAND_DATA04                   = IOMUX_PAD(0x041C, 0x0190, 0, 0x0000, 0, 0),
+	MX6_PAD_NAND_DATA04__USDHC2_DATA4                     = IOMUX_PAD(0x041C, 0x0190, 1, 0x068C, 1, 0),
+	MX6_PAD_NAND_DATA04__QSPI_B_DATA02                    = IOMUX_PAD(0x041C, 0x0190, 2, 0x0000, 0, 0),
+	MX6_PAD_NAND_DATA04__ECSPI4_SCLK                      = IOMUX_PAD(0x041C, 0x0190, 3, 0x0564, 1, 0),
+	MX6_PAD_NAND_DATA04__EIM_AD12                         = IOMUX_PAD(0x041C, 0x0190, 4, 0x0000, 0, 0),
+	MX6_PAD_NAND_DATA04__GPIO4_IO06                       = IOMUX_PAD(0x041C, 0x0190, 5, 0x0000, 0, 0),
+	MX6_PAD_NAND_DATA04__UART2_DCE_TX                     = IOMUX_PAD(0x041C, 0x0190, 8, 0x0000, 0, 0),
+	MX6_PAD_NAND_DATA04__UART2_DTE_RX                     = IOMUX_PAD(0x041C, 0x0190, 8, 0x062C, 2, 0),
+
+	MX6_PAD_NAND_DATA05__RAWNAND_DATA05                   = IOMUX_PAD(0x0420, 0x0194, 0, 0x0000, 0, 0),
+	MX6_PAD_NAND_DATA05__USDHC2_DATA5                     = IOMUX_PAD(0x0420, 0x0194, 1, 0x0690, 1, 0),
+	MX6_PAD_NAND_DATA05__QSPI_B_DATA03                    = IOMUX_PAD(0x0420, 0x0194, 2, 0x0000, 0, 0),
+	MX6_PAD_NAND_DATA05__ECSPI4_MOSI                      = IOMUX_PAD(0x0420, 0x0194, 3, 0x056C, 1, 0),
+	MX6_PAD_NAND_DATA05__EIM_AD13                         = IOMUX_PAD(0x0420, 0x0194, 4, 0x0000, 0, 0),
+	MX6_PAD_NAND_DATA05__GPIO4_IO07                       = IOMUX_PAD(0x0420, 0x0194, 5, 0x0000, 0, 0),
+	MX6_PAD_NAND_DATA05__UART2_DCE_RX                     = IOMUX_PAD(0x0420, 0x0194, 8, 0x062C, 3, 0),
+	MX6_PAD_NAND_DATA05__UART2_DTE_TX                     = IOMUX_PAD(0x0420, 0x0194, 8, 0x0000, 0, 0),
+
+	MX6_PAD_NAND_DATA06__RAWNAND_DATA06                   = IOMUX_PAD(0x0424, 0x0198, 0, 0x0000, 0, 0),
+	MX6_PAD_NAND_DATA06__USDHC2_DATA6                     = IOMUX_PAD(0x0424, 0x0198, 1, 0x0694, 1, 0),
+	MX6_PAD_NAND_DATA06__SAI2_RX_BCLK                     = IOMUX_PAD(0x0424, 0x0198, 2, 0x0000, 0, 0),
+	MX6_PAD_NAND_DATA06__ECSPI4_MISO                      = IOMUX_PAD(0x0424, 0x0198, 3, 0x0568, 1, 0),
+	MX6_PAD_NAND_DATA06__EIM_AD14                         = IOMUX_PAD(0x0424, 0x0198, 4, 0x0000, 0, 0),
+	MX6_PAD_NAND_DATA06__GPIO4_IO08                       = IOMUX_PAD(0x0424, 0x0198, 5, 0x0000, 0, 0),
+	MX6_PAD_NAND_DATA06__UART2_DCE_CTS                    = IOMUX_PAD(0x0424, 0x0198, 8, 0x0000, 0, 0),
+	MX6_PAD_NAND_DATA06__UART2_DTE_RTS                    = IOMUX_PAD(0x0424, 0x0198, 8, 0x0628, 4, 0),
+
+	MX6_PAD_NAND_DATA07__RAWNAND_DATA07                   = IOMUX_PAD(0x0428, 0x019C, 0, 0x0000, 0, 0),
+	MX6_PAD_NAND_DATA07__USDHC2_DATA7                     = IOMUX_PAD(0x0428, 0x019C, 1, 0x0698, 1, 0),
+	MX6_PAD_NAND_DATA07__QSPI_A_SS1_B                     = IOMUX_PAD(0x0428, 0x019C, 2, 0x0000, 0, 0),
+	MX6_PAD_NAND_DATA07__ECSPI4_SS0                       = IOMUX_PAD(0x0428, 0x019C, 3, 0x0570, 1, 0),
+	MX6_PAD_NAND_DATA07__EIM_AD15                         = IOMUX_PAD(0x0428, 0x019C, 4, 0x0000, 0, 0),
+	MX6_PAD_NAND_DATA07__GPIO4_IO09                       = IOMUX_PAD(0x0428, 0x019C, 5, 0x0000, 0, 0),
+	MX6_PAD_NAND_DATA07__UART2_DCE_RTS                    = IOMUX_PAD(0x0428, 0x019C, 8, 0x0628, 5, 0),
+	MX6_PAD_NAND_DATA07__UART2_DTE_CTS                    = IOMUX_PAD(0x0428, 0x019C, 8, 0x0000, 0, 0),
+
+	MX6_PAD_NAND_ALE__RAWNAND_ALE                         = IOMUX_PAD(0x042C, 0x01A0, 0, 0x0000, 0, 0),
+	MX6_PAD_NAND_ALE__USDHC2_RESET_B                      = IOMUX_PAD(0x042C, 0x01A0, 1, 0x0000, 0, 0),
+	MX6_PAD_NAND_ALE__QSPI_A_DQS                          = IOMUX_PAD(0x042C, 0x01A0, 2, 0x0000, 0, 0),
+	MX6_PAD_NAND_ALE__PWM3_OUT                            = IOMUX_PAD(0x042C, 0x01A0, 3, 0x0000, 0, 0),
+	MX6_PAD_NAND_ALE__EIM_ADDR17                          = IOMUX_PAD(0x042C, 0x01A0, 4, 0x0000, 0, 0),
+	MX6_PAD_NAND_ALE__GPIO4_IO10                          = IOMUX_PAD(0x042C, 0x01A0, 5, 0x0000, 0, 0),
+	MX6_PAD_NAND_ALE__ECSPI3_SS1                          = IOMUX_PAD(0x042C, 0x01A0, 8, 0x0000, 0, 0),
+
+	MX6_PAD_NAND_WP_B__RAWNAND_WP_B                       = IOMUX_PAD(0x0430, 0x01A4, 0, 0x0000, 0, 0),
+	MX6_PAD_NAND_WP_B__USDHC1_RESET_B                     = IOMUX_PAD(0x0430, 0x01A4, 1, 0x0000, 0, 0),
+	MX6_PAD_NAND_WP_B__QSPI_A_SCLK                        = IOMUX_PAD(0x0430, 0x01A4, 2, 0x0000, 0, 0),
+	MX6_PAD_NAND_WP_B__PWM4_OUT                           = IOMUX_PAD(0x0430, 0x01A4, 3, 0x0000, 0, 0),
+	MX6_PAD_NAND_WP_B__EIM_BCLK                           = IOMUX_PAD(0x0430, 0x01A4, 4, 0x0000, 0, 0),
+	MX6_PAD_NAND_WP_B__GPIO4_IO11                         = IOMUX_PAD(0x0430, 0x01A4, 5, 0x0000, 0, 0),
+	MX6_PAD_NAND_WP_B__ECSPI3_RDY                         = IOMUX_PAD(0x0430, 0x01A4, 8, 0x0000, 0, 0),
+
+	MX6_PAD_NAND_READY_B__RAWNAND_READY_B                 = IOMUX_PAD(0x0434, 0x01A8, 0, 0x0000, 0, 0),
+	MX6_PAD_NAND_READY_B__USDHC1_DATA4                    = IOMUX_PAD(0x0434, 0x01A8, 1, 0x0000, 0, 0),
+	MX6_PAD_NAND_READY_B__QSPI_A_DATA00                   = IOMUX_PAD(0x0434, 0x01A8, 2, 0x0000, 0, 0),
+	MX6_PAD_NAND_READY_B__ECSPI3_SS0                      = IOMUX_PAD(0x0434, 0x01A8, 3, 0x0560, 1, 0),
+	MX6_PAD_NAND_READY_B__EIM_CS1_B                       = IOMUX_PAD(0x0434, 0x01A8, 4, 0x0000, 0, 0),
+	MX6_PAD_NAND_READY_B__GPIO4_IO12                      = IOMUX_PAD(0x0434, 0x01A8, 5, 0x0000, 0, 0),
+	MX6_PAD_NAND_READY_B__UART3_DCE_TX                    = IOMUX_PAD(0x0434, 0x01A8, 8, 0x0000, 0, 0),
+	MX6_PAD_NAND_READY_B__UART3_DTE_RX                    = IOMUX_PAD(0x0434, 0x01A8, 8, 0x0634, 2, 0),
+
+	MX6_PAD_NAND_CE0_B__RAWNAND_CE0_B                     = IOMUX_PAD(0x0438, 0x01AC, 0, 0x0000, 0, 0),
+	MX6_PAD_NAND_CE0_B__USDHC1_DATA5                      = IOMUX_PAD(0x0438, 0x01AC, 1, 0x0000, 0, 0),
+	MX6_PAD_NAND_CE0_B__QSPI_A_DATA01                     = IOMUX_PAD(0x0438, 0x01AC, 2, 0x0000, 0, 0),
+	MX6_PAD_NAND_CE0_B__ECSPI3_SCLK                       = IOMUX_PAD(0x0438, 0x01AC, 3, 0x0554, 1, 0),
+	MX6_PAD_NAND_CE0_B__EIM_DTACK_B                       = IOMUX_PAD(0x0438, 0x01AC, 4, 0x0000, 0, 0),
+	MX6_PAD_NAND_CE0_B__GPIO4_IO13                        = IOMUX_PAD(0x0438, 0x01AC, 5, 0x0000, 0, 0),
+	MX6_PAD_NAND_CE0_B__UART3_DCE_RX                      = IOMUX_PAD(0x0438, 0x01AC, 8, 0x0634, 3, 0),
+	MX6_PAD_NAND_CE0_B__UART3_DTE_TX                      = IOMUX_PAD(0x0438, 0x01AC, 8, 0x0000, 0, 0),
+
+	MX6_PAD_NAND_CE1_B__RAWNAND_CE1_B                     = IOMUX_PAD(0x043C, 0x01B0, 0, 0x0000, 0, 0),
+	MX6_PAD_NAND_CE1_B__USDHC1_DATA6                      = IOMUX_PAD(0x043C, 0x01B0, 1, 0x0000, 0, 0),
+	MX6_PAD_NAND_CE1_B__QSPI_A_DATA02                     = IOMUX_PAD(0x043C, 0x01B0, 2, 0x0000, 0, 0),
+	MX6_PAD_NAND_CE1_B__ECSPI3_MOSI                       = IOMUX_PAD(0x043C, 0x01B0, 3, 0x055C, 1, 0),
+	MX6_PAD_NAND_CE1_B__EIM_ADDR18                        = IOMUX_PAD(0x043C, 0x01B0, 4, 0x0000, 0, 0),
+	MX6_PAD_NAND_CE1_B__GPIO4_IO14                        = IOMUX_PAD(0x043C, 0x01B0, 5, 0x0000, 0, 0),
+	MX6_PAD_NAND_CE1_B__UART3_DCE_CTS                     = IOMUX_PAD(0x043C, 0x01B0, 8, 0x0000, 0, 0),
+	MX6_PAD_NAND_CE1_B__UART3_DTE_RTS                     = IOMUX_PAD(0x043C, 0x01B0, 8, 0x0630, 2, 0),
+
+	MX6_PAD_NAND_CLE__RAWNAND_CLE                         = IOMUX_PAD(0x0440, 0x01B4, 0, 0x0000, 0, 0),
+	MX6_PAD_NAND_CLE__USDHC1_DATA7                        = IOMUX_PAD(0x0440, 0x01B4, 1, 0x0000, 0, 0),
+	MX6_PAD_NAND_CLE__QSPI_A_DATA03                       = IOMUX_PAD(0x0440, 0x01B4, 2, 0x0000, 0, 0),
+	MX6_PAD_NAND_CLE__ECSPI3_MISO                         = IOMUX_PAD(0x0440, 0x01B4, 3, 0x0558, 1, 0),
+	MX6_PAD_NAND_CLE__EIM_ADDR16                          = IOMUX_PAD(0x0440, 0x01B4, 4, 0x0000, 0, 0),
+	MX6_PAD_NAND_CLE__GPIO4_IO15                          = IOMUX_PAD(0x0440, 0x01B4, 5, 0x0000, 0, 0),
+	MX6_PAD_NAND_CLE__UART3_DCE_RTS                       = IOMUX_PAD(0x0440, 0x01B4, 8, 0x0630, 3, 0),
+	MX6_PAD_NAND_CLE__UART3_DTE_CTS                       = IOMUX_PAD(0x0440, 0x01B4, 8, 0x0000, 0, 0),
+
+	MX6_PAD_NAND_DQS__RAWNAND_DQS                         = IOMUX_PAD(0x0444, 0x01B8, 0, 0x0000, 0, 0),
+	MX6_PAD_NAND_DQS__CSI_FIELD                           = IOMUX_PAD(0x0444, 0x01B8, 1, 0x0530, 1, 0),
+	MX6_PAD_NAND_DQS__QSPI_A_SS0_B                        = IOMUX_PAD(0x0444, 0x01B8, 2, 0x0000, 0, 0),
+	MX6_PAD_NAND_DQS__PWM5_OUT                            = IOMUX_PAD(0x0444, 0x01B8, 3, 0x0000, 0, 0),
+	MX6_PAD_NAND_DQS__EIM_WAIT                            = IOMUX_PAD(0x0444, 0x01B8, 4, 0x0000, 0, 0),
+	MX6_PAD_NAND_DQS__GPIO4_IO16                          = IOMUX_PAD(0x0444, 0x01B8, 5, 0x0000, 0, 0),
+	MX6_PAD_NAND_DQS__SDMA_EXT_EVENT01                    = IOMUX_PAD(0x0444, 0x01B8, 6, 0x0614, 1, 0),
+	MX6_PAD_NAND_DQS__SPDIF_EXT_CLK                       = IOMUX_PAD(0x0444, 0x01B8, 8, 0x061C, 1, 0),
+
+	MX6_PAD_SD1_CMD__USDHC1_CMD                           = IOMUX_PAD(0x0448, 0x01BC, 0, 0x0000, 0, 0),
+	MX6_PAD_SD1_CMD__GPT2_COMPARE1                        = IOMUX_PAD(0x0448, 0x01BC, 1, 0x0000, 0, 0),
+	MX6_PAD_SD1_CMD__SAI2_RX_SYNC                         = IOMUX_PAD(0x0448, 0x01BC, 2, 0x0000, 0, 0),
+	MX6_PAD_SD1_CMD__SPDIF_OUT                            = IOMUX_PAD(0x0448, 0x01BC, 3, 0x0000, 0, 0),
+	MX6_PAD_SD1_CMD__EIM_ADDR19                           = IOMUX_PAD(0x0448, 0x01BC, 4, 0x0000, 0, 0),
+	MX6_PAD_SD1_CMD__GPIO2_IO16                           = IOMUX_PAD(0x0448, 0x01BC, 5, 0x0000, 0, 0),
+	MX6_PAD_SD1_CMD__SDMA_EXT_EVENT00                     = IOMUX_PAD(0x0448, 0x01BC, 6, 0x0610, 2, 0),
+	MX6_PAD_SD1_CMD__USB_OTG1_PWR                         = IOMUX_PAD(0x0448, 0x01BC, 8, 0x0000, 0, 0),
+
+	MX6_PAD_SD1_CLK__USDHC1_CLK                           = IOMUX_PAD(0x044C, 0x01C0, 0, 0x0000, 0, 0),
+	MX6_PAD_SD1_CLK__GPT2_COMPARE2                        = IOMUX_PAD(0x044C, 0x01C0, 1, 0x0000, 0, 0),
+	MX6_PAD_SD1_CLK__SAI2_MCLK                            = IOMUX_PAD(0x044C, 0x01C0, 2, 0x05F0, 1, 0),
+	MX6_PAD_SD1_CLK__SPDIF_IN                             = IOMUX_PAD(0x044C, 0x01C0, 3, 0x0618, 3, 0),
+	MX6_PAD_SD1_CLK__EIM_ADDR20                           = IOMUX_PAD(0x044C, 0x01C0, 4, 0x0000, 0, 0),
+	MX6_PAD_SD1_CLK__GPIO2_IO17                           = IOMUX_PAD(0x044C, 0x01C0, 5, 0x0000, 0, 0),
+	MX6_PAD_SD1_CLK__USB_OTG1_OC                          = IOMUX_PAD(0x044C, 0x01C0, 8, 0x0664, 2, 0),
+
+	MX6_PAD_SD1_DATA0__USDHC1_DATA0                       = IOMUX_PAD(0x0450, 0x01C4, 0, 0x0000, 0, 0),
+	MX6_PAD_SD1_DATA0__GPT2_COMPARE3                      = IOMUX_PAD(0x0450, 0x01C4, 1, 0x0000, 0, 0),
+	MX6_PAD_SD1_DATA0__SAI2_TX_SYNC                       = IOMUX_PAD(0x0450, 0x01C4, 2, 0x05FC, 1, 0),
+	MX6_PAD_SD1_DATA0__FLEXCAN1_TX                        = IOMUX_PAD(0x0450, 0x01C4, 3, 0x0000, 0, 0),
+	MX6_PAD_SD1_DATA0__EIM_ADDR21                         = IOMUX_PAD(0x0450, 0x01C4, 4, 0x0000, 0, 0),
+	MX6_PAD_SD1_DATA0__GPIO2_IO18                         = IOMUX_PAD(0x0450, 0x01C4, 5, 0x0000, 0, 0),
+	MX6_PAD_SD1_DATA0__ANATOP_OTG1_ID                     = IOMUX_PAD(0x0450, 0x01C4, 8, 0x04B8, 2, 0),
+
+	MX6_PAD_SD1_DATA1__USDHC1_DATA1                       = IOMUX_PAD(0x0454, 0x01C8, 0, 0x0000, 0, 0),
+	MX6_PAD_SD1_DATA1__GPT2_CLK                           = IOMUX_PAD(0x0454, 0x01C8, 1, 0x05A0, 1, 0),
+	MX6_PAD_SD1_DATA1__SAI2_TX_BCLK                       = IOMUX_PAD(0x0454, 0x01C8, 2, 0x05F8, 1, 0),
+	MX6_PAD_SD1_DATA1__FLEXCAN1_RX                        = IOMUX_PAD(0x0454, 0x01C8, 3, 0x0584, 3, 0),
+	MX6_PAD_SD1_DATA1__EIM_ADDR22                         = IOMUX_PAD(0x0454, 0x01C8, 4, 0x0000, 0, 0),
+	MX6_PAD_SD1_DATA1__GPIO2_IO19                         = IOMUX_PAD(0x0454, 0x01C8, 5, 0x0000, 0, 0),
+	MX6_PAD_SD1_DATA1__USB_OTG2_PWR                       = IOMUX_PAD(0x0454, 0x01C8, 8, 0x0000, 0, 0),
+
+	MX6_PAD_SD1_DATA2__USDHC1_DATA2                       = IOMUX_PAD(0x0458, 0x01CC, 0, 0x0000, 0, 0),
+	MX6_PAD_SD1_DATA2__GPT2_CAPTURE1                      = IOMUX_PAD(0x0458, 0x01CC, 1, 0x0598, 1, 0),
+	MX6_PAD_SD1_DATA2__SAI2_RX_DATA                       = IOMUX_PAD(0x0458, 0x01CC, 2, 0x05F4, 1, 0),
+	MX6_PAD_SD1_DATA2__FLEXCAN2_TX                        = IOMUX_PAD(0x0458, 0x01CC, 3, 0x0000, 0, 0),
+	MX6_PAD_SD1_DATA2__EIM_ADDR23                         = IOMUX_PAD(0x0458, 0x01CC, 4, 0x0000, 0, 0),
+	MX6_PAD_SD1_DATA2__GPIO2_IO20                         = IOMUX_PAD(0x0458, 0x01CC, 5, 0x0000, 0, 0),
+	MX6_PAD_SD1_DATA2__CCM_CLKO1                          = IOMUX_PAD(0x0458, 0x01CC, 6, 0x0000, 0, 0),
+	MX6_PAD_SD1_DATA2__USB_OTG2_OC                        = IOMUX_PAD(0x0458, 0x01CC, 8, 0x0660, 2, 0),
+
+	MX6_PAD_SD1_DATA3__USDHC1_DATA3                       = IOMUX_PAD(0x045C, 0x01D0, 0, 0x0000, 0, 0),
+	MX6_PAD_SD1_DATA3__GPT2_CAPTURE2                      = IOMUX_PAD(0x045C, 0x01D0, 1, 0x059C, 1, 0),
+	MX6_PAD_SD1_DATA3__SAI2_TX_DATA                       = IOMUX_PAD(0x045C, 0x01D0, 2, 0x0000, 0, 0),
+	MX6_PAD_SD1_DATA3__FLEXCAN2_RX                        = IOMUX_PAD(0x045C, 0x01D0, 3, 0x0588, 3, 0),
+	MX6_PAD_SD1_DATA3__EIM_ADDR24                         = IOMUX_PAD(0x045C, 0x01D0, 4, 0x0000, 0, 0),
+	MX6_PAD_SD1_DATA3__GPIO2_IO21                         = IOMUX_PAD(0x045C, 0x01D0, 5, 0x0000, 0, 0),
+	MX6_PAD_SD1_DATA3__CCM_CLKO2                          = IOMUX_PAD(0x045C, 0x01D0, 6, 0x0000, 0, 0),
+	MX6_PAD_SD1_DATA3__ANATOP_OTG2_ID                     = IOMUX_PAD(0x045C, 0x01D0, 8, 0x04BC, 2, 0),
+
+	MX6_PAD_CSI_MCLK__CSI_MCLK                            = IOMUX_PAD(0x0460, 0x01D4, 0, 0x0000, 0, 0),
+	MX6_PAD_CSI_MCLK__USDHC2_CD_B                         = IOMUX_PAD(0x0460, 0x01D4, 1, 0x0674, 0, 0),
+	MX6_PAD_CSI_MCLK__RAWNAND_CE2_B                       = IOMUX_PAD(0x0460, 0x01D4, 2, 0x0000, 0, 0),
+	MX6_PAD_CSI_MCLK__I2C1_SDA                            = IOMUX_PAD(0x0460, 0x01D4, IOMUX_CONFIG_SION | 3, 0x05A8, 0, 0),
+	MX6_PAD_CSI_MCLK__EIM_CS0_B                           = IOMUX_PAD(0x0460, 0x01D4, 4, 0x0000, 0, 0),
+	MX6_PAD_CSI_MCLK__GPIO4_IO17                          = IOMUX_PAD(0x0460, 0x01D4, 5, 0x0000, 0, 0),
+	MX6_PAD_CSI_MCLK__SNVS_HP_VIO_5_CTL                   = IOMUX_PAD(0x0460, 0x01D4, 6, 0x0000, 0, 0),
+	MX6_PAD_CSI_MCLK__UART6_DCE_TX                        = IOMUX_PAD(0x0460, 0x01D4, 8, 0x0000, 0, 0),
+	MX6_PAD_CSI_MCLK__UART6_DTE_RX                        = IOMUX_PAD(0x0460, 0x01D4, 8, 0x064C, 0, 0),
+
+	MX6_PAD_CSI_PIXCLK__CSI_PIXCLK                        = IOMUX_PAD(0x0464, 0x01D8, 0, 0x0528, 1, 0),
+	MX6_PAD_CSI_PIXCLK__USDHC2_WP                         = IOMUX_PAD(0x0464, 0x01D8, 1, 0x069C, 2, 0),
+	MX6_PAD_CSI_PIXCLK__RAWNAND_CE3_B                     = IOMUX_PAD(0x0464, 0x01D8, 2, 0x0000, 0, 0),
+	MX6_PAD_CSI_PIXCLK__I2C1_SCL                          = IOMUX_PAD(0x0464, 0x01D8, IOMUX_CONFIG_SION | 3, 0x05A4, 2, 0),
+	MX6_PAD_CSI_PIXCLK__EIM_OE                            = IOMUX_PAD(0x0464, 0x01D8, 4, 0x0000, 0, 0),
+	MX6_PAD_CSI_PIXCLK__GPIO4_IO18                        = IOMUX_PAD(0x0464, 0x01D8, 5, 0x0000, 0, 0),
+	MX6_PAD_CSI_PIXCLK__SNVS_HP_VIO_5                     = IOMUX_PAD(0x0464, 0x01D8, 6, 0x0000, 0, 0),
+	MX6_PAD_CSI_PIXCLK__UART6_DCE_RX                      = IOMUX_PAD(0x0464, 0x01D8, 8, 0x064C, 3, 0),
+	MX6_PAD_CSI_PIXCLK__UART6_DTE_TX                      = IOMUX_PAD(0x0464, 0x01D8, 8, 0x0000, 0, 0),
+
+	MX6_PAD_CSI_VSYNC__CSI_VSYNC                          = IOMUX_PAD(0x0468, 0x01DC, 0, 0x052C, 0, 0),
+	MX6_PAD_CSI_VSYNC__USDHC2_CLK                         = IOMUX_PAD(0x0468, 0x01DC, 1, 0x0670, 0, 0),
+	MX6_PAD_CSI_VSYNC__SIM1_PORT1_CLK                     = IOMUX_PAD(0x0468, 0x01DC, 2, 0x0000, 0, 0),
+	MX6_PAD_CSI_VSYNC__I2C2_SDA                           = IOMUX_PAD(0x0468, 0x01DC, IOMUX_CONFIG_SION | 3, 0x05B0, 0, 0),
+	MX6_PAD_CSI_VSYNC__EIM_RW                             = IOMUX_PAD(0x0468, 0x01DC, 4, 0x0000, 0, 0),
+	MX6_PAD_CSI_VSYNC__GPIO4_IO19                         = IOMUX_PAD(0x0468, 0x01DC, 5, 0x0000, 0, 0),
+	MX6_PAD_CSI_VSYNC__PWM7_OUT                           = IOMUX_PAD(0x0468, 0x01DC, 6, 0x0000, 0, 0),
+	MX6_PAD_CSI_VSYNC__UART6_DCE_RTS                      = IOMUX_PAD(0x0468, 0x01DC, 8, 0x0648, 0, 0),
+	MX6_PAD_CSI_VSYNC__UART6_DTE_CTS                      = IOMUX_PAD(0x0468, 0x01DC, 8, 0x0000, 0, 0),
+
+	MX6_PAD_CSI_HSYNC__CSI_HSYNC                          = IOMUX_PAD(0x046C, 0x01E0, 0, 0x0524, 0, 0),
+	MX6_PAD_CSI_HSYNC__USDHC2_CMD                         = IOMUX_PAD(0x046C, 0x01E0, 1, 0x0678, 0, 0),
+	MX6_PAD_CSI_HSYNC__SIM1_PORT1_PD                      = IOMUX_PAD(0x046C, 0x01E0, 2, 0x0000, 0, 0),
+	MX6_PAD_CSI_HSYNC__I2C2_SCL                           = IOMUX_PAD(0x046C, 0x01E0, IOMUX_CONFIG_SION | 3, 0x05AC, 0, 0),
+	MX6_PAD_CSI_HSYNC__EIM_LBA_B                          = IOMUX_PAD(0x046C, 0x01E0, 4, 0x0000, 0, 0),
+	MX6_PAD_CSI_HSYNC__GPIO4_IO20                         = IOMUX_PAD(0x046C, 0x01E0, 5, 0x0000, 0, 0),
+	MX6_PAD_CSI_HSYNC__PWM8_OUT                           = IOMUX_PAD(0x046C, 0x01E0, 6, 0x0000, 0, 0),
+	MX6_PAD_CSI_HSYNC__UART6_DCE_CTS                      = IOMUX_PAD(0x046C, 0x01E0, 8, 0x0000, 0, 0),
+	MX6_PAD_CSI_HSYNC__UART6_DTE_RTS                      = IOMUX_PAD(0x046C, 0x01E0, 8, 0x0648, 1, 0),
+
+	MX6_PAD_CSI_DATA00__CSI_DATA02                        = IOMUX_PAD(0x0470, 0x01E4, 0, 0x04C4, 0, 0),
+	MX6_PAD_CSI_DATA00__USDHC2_DATA0                      = IOMUX_PAD(0x0470, 0x01E4, 1, 0x067C, 0, 0),
+	MX6_PAD_CSI_DATA00__SIM1_PORT1_RST_B                  = IOMUX_PAD(0x0470, 0x01E4, 2, 0x0000, 0, 0),
+	MX6_PAD_CSI_DATA00__ECSPI2_SCLK                       = IOMUX_PAD(0x0470, 0x01E4, 3, 0x0544, 0, 0),
+	MX6_PAD_CSI_DATA00__EIM_AD00                          = IOMUX_PAD(0x0470, 0x01E4, 4, 0x0000, 0, 0),
+	MX6_PAD_CSI_DATA00__GPIO4_IO21                        = IOMUX_PAD(0x0470, 0x01E4, 5, 0x0000, 0, 0),
+	MX6_PAD_CSI_DATA00__SRC_INT_BOOT                      = IOMUX_PAD(0x0470, 0x01E4, 6, 0x0000, 0, 0),
+	MX6_PAD_CSI_DATA00__UART5_DCE_TX                      = IOMUX_PAD(0x0470, 0x01E4, 8, 0x0000, 0, 0),
+	MX6_PAD_CSI_DATA00__UART5_DTE_RX                      = IOMUX_PAD(0x0470, 0x01E4, 8, 0x0644, 0, 0),
+
+	MX6_PAD_CSI_DATA01__CSI_DATA03                        = IOMUX_PAD(0x0474, 0x01E8, 0, 0x04C8, 0, 0),
+	MX6_PAD_CSI_DATA01__USDHC2_DATA1                      = IOMUX_PAD(0x0474, 0x01E8, 1, 0x0680, 0, 0),
+	MX6_PAD_CSI_DATA01__SIM1_PORT1_SVEN                   = IOMUX_PAD(0x0474, 0x01E8, 2, 0x0000, 0, 0),
+	MX6_PAD_CSI_DATA01__ECSPI2_SS0                        = IOMUX_PAD(0x0474, 0x01E8, 3, 0x0550, 0, 0),
+	MX6_PAD_CSI_DATA01__EIM_AD01                          = IOMUX_PAD(0x0474, 0x01E8, 4, 0x0000, 0, 0),
+	MX6_PAD_CSI_DATA01__GPIO4_IO22                        = IOMUX_PAD(0x0474, 0x01E8, 5, 0x0000, 0, 0),
+	MX6_PAD_CSI_DATA01__SAI1_MCLK                         = IOMUX_PAD(0x0474, 0x01E8, 6, 0x05E0, 0, 0),
+	MX6_PAD_CSI_DATA01__UART5_DCE_RX                      = IOMUX_PAD(0x0474, 0x01E8, 8, 0x0644, 1, 0),
+	MX6_PAD_CSI_DATA01__UART5_DTE_TX                      = IOMUX_PAD(0x0474, 0x01E8, 8, 0x0000, 0, 0),
+
+	MX6_PAD_CSI_DATA02__CSI_DATA04                        = IOMUX_PAD(0x0478, 0x01EC, 0, 0x04D8, 1, 0),
+	MX6_PAD_CSI_DATA02__USDHC2_DATA2                      = IOMUX_PAD(0x0478, 0x01EC, 1, 0x0684, 2, 0),
+	MX6_PAD_CSI_DATA02__SIM1_PORT1_TRXD                   = IOMUX_PAD(0x0478, 0x01EC, 2, 0x0000, 0, 0),
+	MX6_PAD_CSI_DATA02__ECSPI2_MOSI                       = IOMUX_PAD(0x0478, 0x01EC, 3, 0x054C, 1, 0),
+	MX6_PAD_CSI_DATA02__EIM_AD02                          = IOMUX_PAD(0x0478, 0x01EC, 4, 0x0000, 0, 0),
+	MX6_PAD_CSI_DATA02__GPIO4_IO23                        = IOMUX_PAD(0x0478, 0x01EC, 5, 0x0000, 0, 0),
+	MX6_PAD_CSI_DATA02__SAI1_RX_SYNC                      = IOMUX_PAD(0x0478, 0x01EC, 6, 0x0000, 0, 0),
+	MX6_PAD_CSI_DATA02__UART5_DCE_RTS                     = IOMUX_PAD(0x0478, 0x01EC, 8, 0x0640, 5, 0),
+	MX6_PAD_CSI_DATA02__UART5_DTE_CTS                     = IOMUX_PAD(0x0478, 0x01EC, 8, 0x0000, 0, 0),
+
+	MX6_PAD_CSI_DATA03__CSI_DATA05                        = IOMUX_PAD(0x047C, 0x01F0, 0, 0x04CC, 0, 0),
+	MX6_PAD_CSI_DATA03__USDHC2_DATA3                      = IOMUX_PAD(0x047C, 0x01F0, 1, 0x0688, 0, 0),
+	MX6_PAD_CSI_DATA03__SIM2_PORT1_PD                     = IOMUX_PAD(0x047C, 0x01F0, 2, 0x0000, 0, 0),
+	MX6_PAD_CSI_DATA03__ECSPI2_MISO                       = IOMUX_PAD(0x047C, 0x01F0, 3, 0x0548, 0, 0),
+	MX6_PAD_CSI_DATA03__EIM_AD03                          = IOMUX_PAD(0x047C, 0x01F0, 4, 0x0000, 0, 0),
+	MX6_PAD_CSI_DATA03__GPIO4_IO24                        = IOMUX_PAD(0x047C, 0x01F0, 5, 0x0000, 0, 0),
+	MX6_PAD_CSI_DATA03__SAI1_RX_BCLK                      = IOMUX_PAD(0x047C, 0x01F0, 6, 0x0000, 0, 0),
+	MX6_PAD_CSI_DATA03__UART5_DCE_CTS                     = IOMUX_PAD(0x047C, 0x01F0, 8, 0x0000, 0, 0),
+	MX6_PAD_CSI_DATA03__UART5_DTE_RTS                     = IOMUX_PAD(0x047C, 0x01F0, 8, 0x0640, 0, 0),
+
+	MX6_PAD_CSI_DATA04__CSI_DATA06                        = IOMUX_PAD(0x0480, 0x01F4, 0, 0x04DC, 1, 0),
+	MX6_PAD_CSI_DATA04__USDHC2_DATA4                      = IOMUX_PAD(0x0480, 0x01F4, 1, 0x068C, 2, 0),
+	MX6_PAD_CSI_DATA04__SIM2_PORT1_CLK                    = IOMUX_PAD(0x0480, 0x01F4, 2, 0x0000, 0, 0),
+	MX6_PAD_CSI_DATA04__ECSPI1_SCLK                       = IOMUX_PAD(0x0480, 0x01F4, 3, 0x0534, 1, 0),
+	MX6_PAD_CSI_DATA04__EIM_AD04                          = IOMUX_PAD(0x0480, 0x01F4, 4, 0x0000, 0, 0),
+	MX6_PAD_CSI_DATA04__GPIO4_IO25                        = IOMUX_PAD(0x0480, 0x01F4, 5, 0x0000, 0, 0),
+	MX6_PAD_CSI_DATA04__SAI1_TX_SYNC                      = IOMUX_PAD(0x0480, 0x01F4, 6, 0x05EC, 1, 0),
+	MX6_PAD_CSI_DATA04__USDHC1_WP                         = IOMUX_PAD(0x0480, 0x01F4, 8, 0x066C, 2, 0),
+
+	MX6_PAD_CSI_DATA05__CSI_DATA07                        = IOMUX_PAD(0x0484, 0x01F8, 0, 0x04E0, 1, 0),
+	MX6_PAD_CSI_DATA05__USDHC2_DATA5                      = IOMUX_PAD(0x0484, 0x01F8, 1, 0x0690, 2, 0),
+	MX6_PAD_CSI_DATA05__SIM2_PORT1_RST_B                  = IOMUX_PAD(0x0484, 0x01F8, 2, 0x0000, 0, 0),
+	MX6_PAD_CSI_DATA05__ECSPI1_SS0                        = IOMUX_PAD(0x0484, 0x01F8, 3, 0x0540, 1, 0),
+	MX6_PAD_CSI_DATA05__EIM_AD05                          = IOMUX_PAD(0x0484, 0x01F8, 4, 0x0000, 0, 0),
+	MX6_PAD_CSI_DATA05__GPIO4_IO26                        = IOMUX_PAD(0x0484, 0x01F8, 5, 0x0000, 0, 0),
+	MX6_PAD_CSI_DATA05__SAI1_TX_BCLK                      = IOMUX_PAD(0x0484, 0x01F8, 6, 0x05E8, 1, 0),
+	MX6_PAD_CSI_DATA05__USDHC1_CD_B                       = IOMUX_PAD(0x0484, 0x01F8, 8, 0x0668, 2, 0),
+
+	MX6_PAD_CSI_DATA06__CSI_DATA08                        = IOMUX_PAD(0x0488, 0x01FC, 0, 0x04E4, 1, 0),
+	MX6_PAD_CSI_DATA06__USDHC2_DATA6                      = IOMUX_PAD(0x0488, 0x01FC, 1, 0x0694, 2, 0),
+	MX6_PAD_CSI_DATA06__SIM2_PORT1_SVEN                   = IOMUX_PAD(0x0488, 0x01FC, 2, 0x0000, 0, 0),
+	MX6_PAD_CSI_DATA06__ECSPI1_MOSI                       = IOMUX_PAD(0x0488, 0x01FC, 3, 0x053C, 1, 0),
+	MX6_PAD_CSI_DATA06__EIM_AD06                          = IOMUX_PAD(0x0488, 0x01FC, 4, 0x0000, 0, 0),
+	MX6_PAD_CSI_DATA06__GPIO4_IO27                        = IOMUX_PAD(0x0488, 0x01FC, 5, 0x0000, 0, 0),
+	MX6_PAD_CSI_DATA06__SAI1_RX_DATA                      = IOMUX_PAD(0x0488, 0x01FC, 6, 0x05E4, 1, 0),
+	MX6_PAD_CSI_DATA06__USDHC1_RESET_B                    = IOMUX_PAD(0x0488, 0x01FC, 8, 0x0000, 0, 0),
+
+	MX6_PAD_CSI_DATA07__CSI_DATA09                        = IOMUX_PAD(0x048C, 0x0200, 0, 0x04E8, 1, 0),
+	MX6_PAD_CSI_DATA07__USDHC2_DATA7                      = IOMUX_PAD(0x048C, 0x0200, 1, 0x0698, 2, 0),
+	MX6_PAD_CSI_DATA07__SIM2_PORT1_TRXD                   = IOMUX_PAD(0x048C, 0x0200, 2, 0x0000, 0, 0),
+	MX6_PAD_CSI_DATA07__ECSPI1_MISO                       = IOMUX_PAD(0x048C, 0x0200, 3, 0x0538, 1, 0),
+	MX6_PAD_CSI_DATA07__EIM_AD07                          = IOMUX_PAD(0x048C, 0x0200, 4, 0x0000, 0, 0),
+	MX6_PAD_CSI_DATA07__GPIO4_IO28                        = IOMUX_PAD(0x048C, 0x0200, 5, 0x0000, 0, 0),
+	MX6_PAD_CSI_DATA07__SAI1_TX_DATA                      = IOMUX_PAD(0x048C, 0x0200, 6, 0x0000, 0, 0),
+	MX6_PAD_CSI_DATA07__USDHC1_VSELECT                    = IOMUX_PAD(0x048C, 0x0200, 8, 0x0000, 0, 0),
+};
+#endif  /* __ASM_ARCH_IMX6ULL_PINS_H__ */
diff --git a/board/freescale/common/recovery.c b/board/freescale/common/recovery.c
index e6f2137..396bc73 100644
--- a/board/freescale/common/recovery.c
+++ b/board/freescale/common/recovery.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2010-2014 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright (C) 2010-2016 Freescale Semiconductor, Inc. All Rights Reserved.
  *
  * SPDX-License-Identifier:	GPL-2.0+
  */
diff --git a/board/freescale/mx6qarm2/mt128x64mx32.cfg b/board/freescale/mx6qarm2/mt128x64mx32.cfg
index adc8c4b..103e103 100644
--- a/board/freescale/mx6qarm2/mt128x64mx32.cfg
+++ b/board/freescale/mx6qarm2/mt128x64mx32.cfg
@@ -44,7 +44,7 @@ CSF CONFIG_CSF_SIZE
 #ifdef CONFIG_MX6DQ_POP_LPDDR2
 /* set ddr to 400Mhz */
 DATA 4 0x020C4018 0x21324
-DATA 4 0x020C4014 0x2018900
+DATA 4 0x020C4014 0x2018100
 CHECK_BITS_CLR 4 0x020C4048 0x3F
 DATA 4 0x020C4018 0x61324
 DATA 4 0x020C4014 0x18900
@@ -134,9 +134,9 @@ DATA 4 	0x020e05c4	0x00000030	// IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM7
 // MMDC0_MDSCR, set the Configuration request bit during MMDC set up
 DATA 4 	0x021b001c	0x00008000	// Chan 0
 DATA 4 	0x021b401c	0x00008000	// Chan 1
-
-DATA 4 	0x021b085c	0x1b5f0109 	//LPDDR2 ZQ params
-DATA 4 	0x021b485c	0x1b5f0109	//LPDDR2 ZQ params
+// Adjust ZQ delay for MMDC clock frequency at 400MHz
+DATA 4 	0x021b085c	0x1b4700c7	//LPDDR2 ZQ params
+DATA 4 	0x021b485c	0x1b4700c7	//LPDDR2 ZQ params
 
 //=============================================================================
 // Calibration setup.
@@ -209,7 +209,7 @@ DATA 4 	0x021b002c	0x0F9F26D2	// MMDC0_MDRWD
 DATA 4 	0x021b0030	0x009F0E10	// MMDC0_MDOR
 DATA 4 	0x021b0038	0x001A0889	// MMDC0_MDCFG3LP
 DATA 4 	0x021b0008	0x00000000	// MMDC0_MDOTC
-DATA 4 	0x021b0040	0x00000053	// Chan0 CS0_END 2 channel with 4K-interleave mode
+DATA 4 	0x021b0040	0x0000004F	// Chan0 CS0_END 2 channel with 2 Channel fixed mode
 // DATA 4  	0x021b0400	0x11420000      	//MMDC0_MAARCR ADOPT optimized priorities. Dyn jump disabled
 DATA 4 	0x021b0000	0x83110000	// MMDC0_MDCTL
 
@@ -224,10 +224,17 @@ DATA 4 	0x021b402c	0x0F9F26D2	// MMDC1_MDRWD
 DATA 4 	0x021b4030	0x009F0E10	// MMDC1_MDOR
 DATA 4 	0x021b4038	0x001A0889	// MMDC1_MDCFG3LP
 DATA 4 	0x021b4008	0x00000000	// MMDC1_MDOTC
-DATA 4 	0x021b4040	0x00000013	// Chan1 CS0_END
+DATA 4 	0x021b4040	0x00000017	// Chan1 CS0_END
 // DATA 4  	0x021b4400	0x11420000      	//MMDC0_MAARCR ADOPT optimized priorities. Dyn jump disabled
 DATA 4 	0x021b4000	0x83110000	// MMDC1_MDCTL
 
+// Precharge all commands per JEDEC
+// The memory controller may optionally issue a Precharge-All command
+// prior to the MRW Reset command.
+// This is strongly recommended to ensure a robust DRAM initialization
+DATA 4 	0x021b001c	0x00008010	// precharge-all commnad CS0 - Chan 0
+DATA 4 	0x021b401c	0x00008010	// precharge-all commnad CS0 - Chan 1
+
 //=============================================================================
 // LPDDR2 Mode Register Writes
 //=============================================================================
diff --git a/board/freescale/mx6qarm2/mx6qarm2.c b/board/freescale/mx6qarm2/mx6qarm2.c
index 188096b..56472dd 100644
--- a/board/freescale/mx6qarm2/mx6qarm2.c
+++ b/board/freescale/mx6qarm2/mx6qarm2.c
@@ -11,12 +11,29 @@
 #include <asm/arch/clock.h>
 #include <asm/errno.h>
 #include <asm/gpio.h>
+#include <asm/arch/crm_regs.h>
+#include <asm/arch/mxc_hdmi.h>
+#include <asm/imx-common/video.h>
+#include <asm/imx-common/mxc_i2c.h>
 #include <asm/imx-common/iomux-v3.h>
+#include <asm/imx-common/boot_mode.h>
 #include <mmc.h>
 #include <fsl_esdhc.h>
 #include <miiphy.h>
 #include <netdev.h>
 #include <usb.h>
+#include <i2c.h>
+
+#ifdef CONFIG_FSL_FASTBOOT
+#include <fsl_fastboot.h>
+#ifdef CONFIG_ANDROID_RECOVERY
+#include <recovery.h>
+#endif
+#endif /*CONFIG_FSL_FASTBOOT*/
+
+#ifdef CONFIG_MAX7310_IOEXP
+#include <gpio_exp.h>
+#endif
 
 DECLARE_GLOBAL_DATA_PTR;
 
@@ -35,6 +52,12 @@ DECLARE_GLOBAL_DATA_PTR;
 	PAD_CTL_PUS_47K_UP  | PAD_CTL_SPEED_LOW |		\
 	PAD_CTL_DSE_80ohm   | PAD_CTL_SRE_FAST  | PAD_CTL_HYS)
 
+#define I2C_PAD_CTRL    (PAD_CTL_PUS_100K_UP |                  \
+	PAD_CTL_SPEED_MED | PAD_CTL_DSE_40ohm | PAD_CTL_HYS |	\
+	PAD_CTL_ODE | PAD_CTL_SRE_FAST)
+
+#define PC MUX_PAD_CTRL(I2C_PAD_CTRL)
+
 int dram_init(void)
 {
 #if defined(CONFIG_MX6DL) && !defined(CONFIG_MX6DL_LPDDR2) && \
@@ -47,6 +70,15 @@ int dram_init(void)
 	return 0;
 }
 
+#if defined(CONFIG_MX6DQ_POP_LPDDR2)
+void dram_init_banksize(void) {
+	gd->bd->bi_dram[0].start = PHYS_SDRAM_0;
+	gd->bd->bi_dram[0].size = (phys_size_t)CONFIG_DDR_MB * 1024 * 1024;
+	gd->bd->bi_dram[1].start = PHYS_SDRAM_1;
+	gd->bd->bi_dram[1].size = (phys_size_t)CONFIG_DDR_MB * 1024 * 1024;
+}
+#endif
+
 iomux_v3_cfg_t const uart4_pads[] = {
 	MX6_PAD_KEY_COL0__UART4_TX_DATA | MUX_PAD_CTRL(UART_PAD_CTRL),
 	MX6_PAD_KEY_ROW0__UART4_RX_DATA | MUX_PAD_CTRL(UART_PAD_CTRL),
@@ -101,6 +133,192 @@ iomux_v3_cfg_t const enet_pads[] = {
 	MX6_PAD_RGMII_RX_CTL__RGMII_RX_CTL | MUX_PAD_CTRL(ENET_PAD_CTRL),
 };
 
+#ifdef CONFIG_SYS_I2C_MXC
+static struct i2c_pads_info i2c_pad_info1 = {
+	.scl = {
+		.i2c_mode = MX6_PAD_KEY_COL3__I2C2_SCL | PC,
+		.gpio_mode = MX6_PAD_KEY_COL3__GPIO4_IO12 | PC,
+		.gp = IMX_GPIO_NR(4, 12)
+	},
+	.sda = {
+		.i2c_mode = MX6_PAD_KEY_ROW3__I2C2_SDA | PC,
+		.gpio_mode = MX6_PAD_KEY_ROW3__GPIO4_IO13 | PC,
+		.gp = IMX_GPIO_NR(4, 13)
+	}
+};
+
+static struct i2c_pads_info i2c_pad_info2 = {
+	.scl = {
+		.i2c_mode = MX6_PAD_GPIO_5__I2C3_SCL | PC,
+		.gpio_mode = MX6_PAD_GPIO_5__GPIO1_IO05 | PC,
+		.gp = IMX_GPIO_NR(1, 5)
+	},
+	.sda = {
+		.i2c_mode = MX6_PAD_GPIO_16__I2C3_SDA | PC,
+		.gpio_mode = MX6_PAD_GPIO_16__GPIO7_IO11 | PC,
+		.gp = IMX_GPIO_NR(7, 11)
+	}
+};
+#endif
+
+#ifdef CONFIG_MAX7310_IOEXP
+#define BACKLIGHT_ON	IOEXP_GPIO_NR(1, 0)
+#define LVDS3V3_CTRL1	IOEXP_GPIO_NR(2, 1)
+
+int setup_max7310(void)
+{
+#ifdef CONFIG_SYS_I2C_MXC
+	gpio_exp_setup_port(2, 2, 0x1F);
+	gpio_exp_setup_port(1, 2, 0x1B);
+	return 0;
+#else
+	return -EPERM;
+#endif
+}
+#endif
+
+#if defined(CONFIG_VIDEO_IPUV3)
+static void disable_lvds(struct display_info_t const *dev)
+{
+	struct iomuxc *iomux = (struct iomuxc *)IOMUXC_BASE_ADDR;
+
+	int reg = readl(&iomux->gpr[2]);
+
+	reg &= ~(IOMUXC_GPR2_LVDS_CH0_MODE_MASK |
+		 IOMUXC_GPR2_LVDS_CH1_MODE_MASK);
+
+	writel(reg, &iomux->gpr[2]);
+}
+
+static void do_enable_hdmi(struct display_info_t const *dev)
+{
+	disable_lvds(dev);
+	imx_enable_hdmi_phy();
+}
+
+struct display_info_t const displays[] = {{
+	.bus	= -1,
+	.addr	= 0,
+	.pixfmt	= IPU_PIX_FMT_RGB666,
+	.detect	= NULL,
+	.enable	= NULL,
+	.mode	= {
+		.name           = "Hannstar-XGA",
+		.refresh        = 60,
+		.xres           = 768,
+		.yres           = 576,
+		.pixclock       = 15385,
+		.left_margin    = 220,
+		.right_margin   = 40,
+		.upper_margin   = 21,
+		.lower_margin   = 7,
+		.hsync_len      = 60,
+		.vsync_len      = 10,
+		.sync           = FB_SYNC_EXT,
+		.vmode          = FB_VMODE_NONINTERLACED
+} }, {
+	.bus	= -1,
+	.addr	= 0,
+	.pixfmt	= IPU_PIX_FMT_RGB24,
+	.detect	= NULL,
+	.enable	= do_enable_hdmi,
+	.mode	= {
+		.name           = "HDMI",
+		.refresh        = 60,
+		.xres           = 640,
+		.yres           = 480,
+		.pixclock       = 39721,
+		.left_margin    = 48,
+		.right_margin   = 16,
+		.upper_margin   = 33,
+		.lower_margin   = 10,
+		.hsync_len      = 96,
+		.vsync_len      = 2,
+		.sync           = 0,
+		.vmode          = FB_VMODE_NONINTERLACED
+} } };
+size_t display_count = ARRAY_SIZE(displays);
+
+iomux_v3_cfg_t const backlight_pads[] = {
+	MX6_PAD_GPIO_9__GPIO1_IO09 | MUX_PAD_CTRL(ENET_PAD_CTRL),
+};
+
+static void setup_iomux_backlight(void)
+{
+	gpio_direction_output(IMX_GPIO_NR(1, 9), 1);
+	imx_iomux_v3_setup_multiple_pads(backlight_pads,
+			ARRAY_SIZE(backlight_pads));
+#ifdef CONFIG_MAX7310_IOEXP
+	gpio_exp_direction_output(BACKLIGHT_ON, 1);
+#endif
+}
+
+static void setup_display(void)
+{
+	struct mxc_ccm_reg *mxc_ccm = (struct mxc_ccm_reg *)CCM_BASE_ADDR;
+	struct iomuxc *iomux = (struct iomuxc *)IOMUXC_BASE_ADDR;
+	int reg;
+
+#ifdef CONFIG_MAX7310_IOEXP
+	gpio_exp_direction_output(LVDS3V3_CTRL1, 1);
+#endif
+	setup_iomux_backlight();
+	enable_ipu_clock();
+	imx_setup_hdmi();
+
+	/* Turn on LDB_DI0 and LDB_DI1 clocks */
+	reg = readl(&mxc_ccm->CCGR3);
+	reg |= MXC_CCM_CCGR3_LDB_DI0_MASK | MXC_CCM_CCGR3_LDB_DI1_MASK;
+	writel(reg, &mxc_ccm->CCGR3);
+
+	/* Set LDB_DI0 and LDB_DI1 clk select to 3b'011 */
+	reg = readl(&mxc_ccm->cs2cdr);
+	reg &= ~(MXC_CCM_CS2CDR_LDB_DI0_CLK_SEL_MASK |
+		 MXC_CCM_CS2CDR_LDB_DI1_CLK_SEL_MASK);
+	reg |= (3 << MXC_CCM_CS2CDR_LDB_DI0_CLK_SEL_OFFSET) |
+	       (3 << MXC_CCM_CS2CDR_LDB_DI1_CLK_SEL_OFFSET);
+	writel(reg, &mxc_ccm->cs2cdr);
+
+	reg = readl(&mxc_ccm->cscmr2);
+	reg |= MXC_CCM_CSCMR2_LDB_DI0_IPU_DIV | MXC_CCM_CSCMR2_LDB_DI1_IPU_DIV;
+	writel(reg, &mxc_ccm->cscmr2);
+
+	reg = readl(&mxc_ccm->chsccdr);
+	reg |= (CHSCCDR_CLK_SEL_LDB_DI0 <<
+		MXC_CCM_CHSCCDR_IPU1_DI0_CLK_SEL_OFFSET);
+	reg |= (CHSCCDR_CLK_SEL_LDB_DI0 <<
+		MXC_CCM_CHSCCDR_IPU1_DI1_CLK_SEL_OFFSET);
+	writel(reg, &mxc_ccm->chsccdr);
+
+	reg = IOMUXC_GPR2_DI1_VS_POLARITY_ACTIVE_LOW |
+	      IOMUXC_GPR2_DI0_VS_POLARITY_ACTIVE_LOW |
+	      IOMUXC_GPR2_BIT_MAPPING_CH1_SPWG |
+	      IOMUXC_GPR2_DATA_WIDTH_CH1_18BIT |
+	      IOMUXC_GPR2_BIT_MAPPING_CH0_SPWG |
+	      IOMUXC_GPR2_DATA_WIDTH_CH0_18BIT |
+	      IOMUXC_GPR2_LVDS_CH0_MODE_ENABLED_DI0 |
+	      IOMUXC_GPR2_LVDS_CH1_MODE_DISABLED;
+	writel(reg, &iomux->gpr[2]);
+
+	reg = readl(&iomux->gpr[3]);
+	reg &= ~(IOMUXC_GPR3_LVDS0_MUX_CTL_MASK |
+		 IOMUXC_GPR3_HDMI_MUX_CTL_MASK);
+	reg |= (IOMUXC_GPR3_MUX_SRC_IPU1_DI0 <<
+		IOMUXC_GPR3_LVDS0_MUX_CTL_OFFSET) |
+	       (IOMUXC_GPR3_MUX_SRC_IPU1_DI0 <<
+		IOMUXC_GPR3_HDMI_MUX_CTL_OFFSET);
+	writel(reg, &iomux->gpr[3]);
+}
+#endif /* CONFIG_VIDEO_IPUV3 */
+
+/*
+ * Do not overwrite the console
+ * Use always serial for U-Boot console
+ */
+int overwrite_console(void)
+{
+	return 1;
+}
 
 static void setup_iomux_uart(void)
 {
@@ -326,6 +544,11 @@ int board_early_init_f(void)
 	setup_iomux_uart();
 	setup_iomux_enet();
 
+#ifdef CONFIG_SYS_I2C_MXC
+	setup_i2c(1, CONFIG_SYS_I2C_SPEED, 0x7f, &i2c_pad_info1);
+	setup_i2c(2, CONFIG_SYS_I2C_SPEED, 0x7f, &i2c_pad_info2);
+#endif
+
 	return 0;
 }
 
@@ -334,6 +557,14 @@ int board_init(void)
 	/* address of boot parameters */
 	gd->bd->bi_boot_params = PHYS_SDRAM + 0x100;
 
+#ifdef CONFIG_MAX7310_IOEXP
+	setup_max7310();
+#endif
+
+#ifdef CONFIG_VIDEO_IPUV3
+	setup_display();
+#endif
+
 #ifdef CONFIG_USB_EHCI_MX6
 	setup_usb();
 #endif
@@ -367,3 +598,28 @@ void ldo_mode_set(int ldo_bypass)
 	return;
 }
 #endif
+
+#ifdef CONFIG_FSL_FASTBOOT
+void board_fastboot_setup(void)
+{
+	if (!getenv("fastboot_dev"))
+		setenv("fastboot_dev", "mmc0");
+	if (!getenv("bootcmd"))
+		setenv("bootcmd", "boota mmc0");
+}
+
+#ifdef CONFIG_ANDROID_RECOVERY
+int check_recovery_cmd_file(void) {
+	return 0;
+}
+
+void board_recovery_setup(void)
+{
+	if (!getenv("bootcmd_android_recovery"))
+		setenv("bootcmd_android_recovery", "boota mmc0 recovery");
+
+	printf("setup env for recovery..\n");
+	setenv("bootcmd", "run bootcmd_android_recovery");
+}
+#endif
+#endif
diff --git a/board/freescale/mx6qsabreauto/mx6qsabreauto.c b/board/freescale/mx6qsabreauto/mx6qsabreauto.c
index 21362a4..3588f19 100644
--- a/board/freescale/mx6qsabreauto/mx6qsabreauto.c
+++ b/board/freescale/mx6qsabreauto/mx6qsabreauto.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2012-2015 Freescale Semiconductor, Inc.
+ * Copyright (C) 2012-2016 Freescale Semiconductor, Inc.
  *
  * Author: Fabio Estevam <fabio.estevam@freescale.com>
  *
@@ -1032,8 +1032,9 @@ int check_recovery_cmd_file(void)
 	int button_pressed = 0;
 	int recovery_mode = 0;
 
-	recovery_mode = recovery_check_and_clean_flag();
-
+#ifdef CONFIG_BCB_SUPPORT
+	recovery_mode = recovery_check_and_clean_command();
+#endif
 	/* Check Recovery Combo Button press or not. */
 	imx_iomux_v3_setup_multiple_pads(recovery_key_pads,
 		ARRAY_SIZE(recovery_key_pads));
diff --git a/board/freescale/mx6qsabreauto/plugin.S b/board/freescale/mx6qsabreauto/plugin.S
index db322c0..09c75ca 100644
--- a/board/freescale/mx6qsabreauto/plugin.S
+++ b/board/freescale/mx6qsabreauto/plugin.S
@@ -638,9 +638,15 @@
 	ldr r1, =0xF00000CF
 	str r1, [r0, #0x10]
 
+#if defined(CONFIG_MX6QP)
+	ldr r1, =0x77177717
+	str r1, [r0, #0x18]
+	str r1, [r0, #0x1c]
+#else
 	ldr r1, =0x007F007F
 	str r1, [r0, #0x18]
 	str r1, [r0, #0x1c]
+#endif
 .endm
 
 .macro imx6_ddr_setting
diff --git a/board/freescale/mx6sabresd/mx6qp.cfg b/board/freescale/mx6sabresd/mx6qp.cfg
index fa62066..fd78696 100644
--- a/board/freescale/mx6sabresd/mx6qp.cfg
+++ b/board/freescale/mx6sabresd/mx6qp.cfg
@@ -66,6 +66,16 @@ DATA 4, 0x020e0518, 0x00000030
 DATA 4, 0x020e050c, 0x00000030
 DATA 4, 0x020e05b8, 0x00000030
 DATA 4, 0x020e05c0, 0x00000030
+
+DATA 4, 0x020e0534, 0x00018200
+DATA 4, 0x020e0538, 0x00008000
+DATA 4, 0x020e053c, 0x00018200
+DATA 4, 0x020e0540, 0x00018200
+DATA 4, 0x020e0544, 0x00018200
+DATA 4, 0x020e0548, 0x00018200
+DATA 4, 0x020e054c, 0x00018200
+DATA 4, 0x020e0550, 0x00018200
+
 DATA 4, 0x020e0774, 0x00020000
 DATA 4, 0x020e0784, 0x00000030
 DATA 4, 0x020e0788, 0x00000030
@@ -104,8 +114,8 @@ DATA 4, 0x021b481c, 0x33333333
 DATA 4, 0x021b4820, 0x33333333
 DATA 4, 0x021b4824, 0x33333333
 DATA 4, 0x021b4828, 0x33333333
-DATA 4, 0x021b08c0, 0x24912249
-DATA 4, 0x021b48c0, 0x24914289
+DATA 4, 0x021b08c0, 0x24912489
+DATA 4, 0x021b48c0, 0x24914452
 DATA 4, 0x021b08b8, 0x00000800
 DATA 4, 0x021b48b8, 0x00000800
 DATA 4, 0x021b0004, 0x00020036
@@ -113,7 +123,7 @@ DATA 4, 0x021b0008, 0x24444040
 DATA 4, 0x021b000c, 0x555A7955
 DATA 4, 0x021b0010, 0xFF320F64
 DATA 4, 0x021b0014, 0x01ff00db
-DATA 4, 0x021b0018, 0x00001740
+DATA 4, 0x021b0018, 0x00011740
 DATA 4, 0x021b001c, 0x00008000
 DATA 4, 0x021b002c, 0x000026d2
 DATA 4, 0x021b0030, 0x005A1023
diff --git a/board/freescale/mx6sabresd/mx6sabresd.c b/board/freescale/mx6sabresd/mx6sabresd.c
index 88f5d96..cd9dd83 100644
--- a/board/freescale/mx6sabresd/mx6sabresd.c
+++ b/board/freescale/mx6sabresd/mx6sabresd.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2012-2015 Freescale Semiconductor, Inc.
+ * Copyright (C) 2012-2016 Freescale Semiconductor, Inc.
  *
  * Author: Fabio Estevam <fabio.estevam@freescale.com>
  *
@@ -1256,8 +1256,9 @@ int check_recovery_cmd_file(void)
     int button_pressed = 0;
     int recovery_mode = 0;
 
-    recovery_mode = recovery_check_and_clean_flag();
-
+#ifdef CONFIG_BCB_SUPPORT
+    recovery_mode = recovery_check_and_clean_command();
+#endif
     /* Check Recovery Combo Button press or not. */
 	imx_iomux_v3_setup_multiple_pads(recovery_key_pads,
 			ARRAY_SIZE(recovery_key_pads));
diff --git a/board/freescale/mx6sabresd/plugin.S b/board/freescale/mx6sabresd/plugin.S
index 0e593e0..a9ee364 100644
--- a/board/freescale/mx6sabresd/plugin.S
+++ b/board/freescale/mx6sabresd/plugin.S
@@ -43,6 +43,18 @@
 	str r1, [r0, #0x5b8]
 	str r1, [r0, #0x5c0]
 
+	ldr r1, =0x00018200
+	str r1, [r0, #0x534]
+	ldr r1, =0x00008000
+	str r1, [r0, #0x538]
+	ldr r1, =0x00018200
+	str r1, [r0, #0x53c]
+	str r1, [r0, #0x540]
+	str r1, [r0, #0x544]
+	str r1, [r0, #0x548]
+	str r1, [r0, #0x54c]
+	str r1, [r0, #0x550]
+
 	ldr r1, =0x00020000
 	str r1, [r0, #0x774]
 
@@ -109,9 +121,9 @@
 	str r2, [r1, #0x824]
 	str r2, [r1, #0x828]
 
-	ldr r2, =0x24912249
+	ldr r2, =0x24912489
 	str r2, [r0, #0x8c0]
-	ldr r2, =0x24914289
+	ldr r2, =0x24914452
 	str r2, [r1, #0x8c0]
 
 	ldr r2, =0x00000800
@@ -130,7 +142,7 @@
 
 	ldr r2, =0x01FF00DB
 	str r2, [r0, #0x014]
-	ldr r2, =0x00001740
+	ldr r2, =0x00011740
 	str r2, [r0, #0x018]
 
 	ldr r2, =0x00008000
@@ -640,9 +652,15 @@
 	ldr r1, =0xF00000CF
 	str r1, [r0, #0x10]
 
+#if defined(CONFIG_MX6QP)
+	ldr r1, =0x77177717
+	str r1, [r0, #0x18]
+	str r1, [r0, #0x1c]
+#else
 	ldr r1, =0x007F007F
 	str r1, [r0, #0x18]
 	str r1, [r0, #0x1c]
+#endif
 .endm
 
 .macro imx6_ddr_setting
diff --git a/board/freescale/mx6slevk/mx6slevk.c b/board/freescale/mx6slevk/mx6slevk.c
index b94fdf0..3a71295 100644
--- a/board/freescale/mx6slevk/mx6slevk.c
+++ b/board/freescale/mx6slevk/mx6slevk.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2013-2015 Freescale Semiconductor, Inc.
+ * Copyright (C) 2013-2016 Freescale Semiconductor, Inc.
  *
  * Author: Fabio Estevam <fabio.estevam@freescale.com>
  *
@@ -876,7 +876,11 @@ void board_fastboot_setup(void)
 #ifdef CONFIG_ANDROID_RECOVERY
 int check_recovery_cmd_file(void)
 {
-    return recovery_check_and_clean_flag();
+#ifdef CONFIG_BCB_SUPPORT
+	return recovery_check_and_clean_command();
+#else
+	return 0;
+#endif
 }
 
 void board_recovery_setup(void)
diff --git a/board/freescale/mx6sxsabreauto/mx6sxsabreauto.c b/board/freescale/mx6sxsabreauto/mx6sxsabreauto.c
index 43a2e3f..e84f1a6 100644
--- a/board/freescale/mx6sxsabreauto/mx6sxsabreauto.c
+++ b/board/freescale/mx6sxsabreauto/mx6sxsabreauto.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2014-2015 Freescale Semiconductor, Inc.
+ * Copyright (C) 2014-2016 Freescale Semiconductor, Inc.
  *
  * SPDX-License-Identifier:	GPL-2.0+
  */
@@ -886,9 +886,9 @@ void board_fastboot_setup(void)
 int check_recovery_cmd_file(void)
 {
 	int recovery_mode = 0;
-
-	recovery_mode = recovery_check_and_clean_flag();
-
+#ifdef CONFIG_BCB_SUPPORT
+	recovery_mode = recovery_check_and_clean_command();
+#endif
 	return recovery_mode;
 }
 
diff --git a/board/freescale/mx6sxsabresd/mx6sxsabresd.c b/board/freescale/mx6sxsabresd/mx6sxsabresd.c
index 3b238e7..d475752 100644
--- a/board/freescale/mx6sxsabresd/mx6sxsabresd.c
+++ b/board/freescale/mx6sxsabresd/mx6sxsabresd.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2014-2015 Freescale Semiconductor, Inc.
+ * Copyright (C) 2014-2016 Freescale Semiconductor, Inc.
  *
  * Author: Fabio Estevam <fabio.estevam@freescale.com>
  *
@@ -970,8 +970,9 @@ int check_recovery_cmd_file(void)
 	int button_pressed = 0;
 	int recovery_mode = 0;
 
-	recovery_mode = recovery_check_and_clean_flag();
-
+#ifdef CONFIG_BCB_SUPPORT
+	recovery_mode = recovery_check_and_clean_command();
+#endif
 	/* Check Recovery Combo Button press or not. */
 	imx_iomux_v3_setup_multiple_pads(recovery_key_pads,
 		ARRAY_SIZE(recovery_key_pads));
diff --git a/board/freescale/mx6ul_14x14_evk/mx6ul_14x14_evk.c b/board/freescale/mx6ul_14x14_evk/mx6ul_14x14_evk.c
index 768138c..476d94b 100644
--- a/board/freescale/mx6ul_14x14_evk/mx6ul_14x14_evk.c
+++ b/board/freescale/mx6ul_14x14_evk/mx6ul_14x14_evk.c
@@ -553,9 +553,11 @@ int board_mmc_init(bd_t *bis)
 			imx_iomux_v3_setup_multiple_pads(
 				usdhc2_emmc_pads, ARRAY_SIZE(usdhc2_emmc_pads));
 #else
+# ifndef CONFIG_SYS_USE_NAND
 			imx_iomux_v3_setup_multiple_pads(
 				usdhc2_pads, ARRAY_SIZE(usdhc2_pads));
 #endif
+#endif
 			gpio_direction_output(USDHC2_PWR_GPIO, 0);
 			udelay(500);
 			gpio_direction_output(USDHC2_PWR_GPIO, 1);
diff --git a/board/freescale/mx6ull_ddr3_arm2/Kconfig b/board/freescale/mx6ull_ddr3_arm2/Kconfig
new file mode 100644
index 0000000..e351ad8
--- /dev/null
+++ b/board/freescale/mx6ull_ddr3_arm2/Kconfig
@@ -0,0 +1,12 @@
+if TARGET_MX6ULL_DDR3_ARM2
+
+config SYS_BOARD
+       default "mx6ull_ddr3_arm2"
+
+config SYS_VENDOR
+       default "freescale"
+
+config SYS_CONFIG_NAME
+       default "mx6ull_ddr3_arm2"
+
+endif
diff --git a/board/freescale/mx6ull_ddr3_arm2/Makefile b/board/freescale/mx6ull_ddr3_arm2/Makefile
new file mode 100644
index 0000000..d6a08fa
--- /dev/null
+++ b/board/freescale/mx6ull_ddr3_arm2/Makefile
@@ -0,0 +1,10 @@
+# (C) Copyright 2016 Freescale Semiconductor, Inc.
+#
+# SPDX-License-Identifier:	GPL-2.0+
+#
+
+obj-y  := mx6ull_ddr3_arm2.o
+
+extra-$(CONFIG_USE_PLUGIN) :=  plugin.bin
+$(obj)/plugin.bin: $(obj)/plugin.o
+	$(OBJCOPY) -O binary --gap-fill 0xff $< $@
diff --git a/board/freescale/mx6ull_ddr3_arm2/imximage.cfg b/board/freescale/mx6ull_ddr3_arm2/imximage.cfg
new file mode 100644
index 0000000..66acf1e
--- /dev/null
+++ b/board/freescale/mx6ull_ddr3_arm2/imximage.cfg
@@ -0,0 +1,114 @@
+/*
+ * Copyright (C) 2016 Freescale Semiconductor, Inc.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ *
+ * Refer docs/README.imxmage for more details about how-to configure
+ * and create imximage boot image
+ *
+ * The syntax is taken as close as possible with the kwbimage
+ */
+
+#define __ASSEMBLY__
+#include <config.h>
+
+/* image version */
+
+IMAGE_VERSION 2
+
+/*
+ * Boot Device : one of
+ * spi/sd/nand/onenand, qspi/nor
+ */
+
+#ifdef CONFIG_SYS_BOOT_QSPI
+BOOT_FROM	qspi
+#elif defined(CONFIG_SYS_BOOT_EIMNOR)
+BOOT_FROM	nor
+#else
+BOOT_FROM	sd
+#endif
+
+#ifdef CONFIG_USE_PLUGIN
+/*PLUGIN    plugin-binary-file    IRAM_FREE_START_ADDR*/
+PLUGIN	board/freescale/mx6ull_ddr3_arm2/plugin.bin 0x00907000
+#else
+
+#ifdef CONFIG_SECURE_BOOT
+CSF CONFIG_CSF_SIZE
+#endif
+
+/*
+ * Device Configuration Data (DCD)
+ *
+ * Each entry must have the format:
+ * Addr-type           Address        Value
+ *
+ * where:
+ *	Addr-type register length (1,2 or 4 bytes)
+ *	Address	  absolute address of the register
+ *	value	  value to be stored in the register
+ */
+
+DATA 4 0x020c4068 0xffffffff
+DATA 4 0x020c406c 0xffffffff
+DATA 4 0x020c4070 0xffffffff
+DATA 4 0x020c4074 0xffffffff
+DATA 4 0x020c4078 0xffffffff
+DATA 4 0x020c407c 0xffffffff
+DATA 4 0x020c4080 0xffffffff
+
+DATA 4 0x020E04B4 0x000C0000
+DATA 4 0x020E04AC 0x00000000
+DATA 4 0x020E027C 0x00000030
+DATA 4 0x020E0250 0x00000030
+DATA 4 0x020E024C 0x00000030
+DATA 4 0x020E0490 0x00000030
+DATA 4 0x020E0288 0x000C0030
+DATA 4 0x020E0270 0x00000000
+DATA 4 0x020E0260 0x00000030
+DATA 4 0x020E0264 0x00000030
+DATA 4 0x020E04A0 0x00000030
+DATA 4 0x020E0494 0x00020000
+DATA 4 0x020E0280 0x00000030
+DATA 4 0x020E0284 0x00000030
+DATA 4 0x020E04B0 0x00020000
+DATA 4 0x020E0498 0x00000030
+DATA 4 0x020E04A4 0x00000030
+DATA 4 0x020E0244 0x00000030
+DATA 4 0x020E0248 0x00000030
+DATA 4 0x021B001C 0x00008000
+DATA 4 0x021B0800 0xA1390003
+DATA 4 0x021B080C 0x00150019
+DATA 4 0x021B083C 0x41550153
+DATA 4 0x021B0848 0x40403A3E
+DATA 4 0x021B0850 0x40402F2A
+DATA 4 0x021B081C 0x33333333
+DATA 4 0x021B0820 0x33333333
+DATA 4 0x021B082C 0xf3333333
+DATA 4 0x021B0830 0xf3333333
+DATA 4 0x021B08C0 0x00944009
+DATA 4 0x021B08b8 0x00000800
+DATA 4 0x021B0004 0x0002002D
+DATA 4 0x021B0008 0x1B333030
+DATA 4 0x021B000C 0x676B52F3
+DATA 4 0x021B0010 0xB66D0B63
+DATA 4 0x021B0014 0x01FF00DB
+DATA 4 0x021B0018 0x00201740
+DATA 4 0x021B001C 0x00008000
+DATA 4 0x021B002C 0x000026D2
+DATA 4 0x021B0030 0x006B1023
+DATA 4 0x021B0040 0x0000005F
+DATA 4 0x021B0000 0x85180000
+DATA 4 0x021B0890 0x00400000
+DATA 4 0x021B001C 0x02008032
+DATA 4 0x021B001C 0x00008033
+DATA 4 0x021B001C 0x00048031
+DATA 4 0x021B001C 0x15208030
+DATA 4 0x021B001C 0x04008040
+DATA 4 0x021B0020 0x00000800
+DATA 4 0x021B0818 0x00000227
+DATA 4 0x021B0004 0x0002552D
+DATA 4 0x021B0404 0x00011006
+DATA 4 0x021B001C 0x00000000
+#endif
diff --git a/board/freescale/mx6ull_ddr3_arm2/mx6ull_ddr3_arm2.c b/board/freescale/mx6ull_ddr3_arm2/mx6ull_ddr3_arm2.c
new file mode 100644
index 0000000..1a0d0ec
--- /dev/null
+++ b/board/freescale/mx6ull_ddr3_arm2/mx6ull_ddr3_arm2.c
@@ -0,0 +1,947 @@
+/*
+ * Copyright (C) 2016 Freescale Semiconductor, Inc.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <asm/arch/clock.h>
+#include <asm/arch/crm_regs.h>
+#include <asm/arch/iomux.h>
+#include <asm/arch/imx-regs.h>
+#include <asm/arch/mx6-pins.h>
+#include <asm/arch/sys_proto.h>
+#include <asm/gpio.h>
+#include <asm/imx-common/iomux-v3.h>
+#include <asm/imx-common/boot_mode.h>
+#include <asm/imx-common/mxc_i2c.h>
+#include <asm/io.h>
+#include <common.h>
+#include <fsl_esdhc.h>
+#include <i2c.h>
+#include <linux/sizes.h>
+#include <linux/fb.h>
+#include <miiphy.h>
+#include <mmc.h>
+#include <mxsfb.h>
+#include <netdev.h>
+#include <power/pmic.h>
+#include <power/pfuze100_pmic.h>
+#include "../common/pfuze.h"
+#include <usb.h>
+#include <usb/ehci-fsl.h>
+
+DECLARE_GLOBAL_DATA_PTR;
+
+#define UART_PAD_CTRL  (PAD_CTL_PKE | PAD_CTL_PUE |		\
+	PAD_CTL_PUS_100K_UP | PAD_CTL_SPEED_MED |		\
+	PAD_CTL_DSE_40ohm   | PAD_CTL_SRE_FAST  | PAD_CTL_HYS)
+
+#define USDHC_PAD_CTRL (PAD_CTL_PKE | PAD_CTL_PUE |		\
+	PAD_CTL_PUS_22K_UP  | PAD_CTL_SPEED_LOW |		\
+	PAD_CTL_DSE_80ohm   | PAD_CTL_SRE_FAST  | PAD_CTL_HYS)
+
+#define USDHC_PAD_CTRL_WP (PAD_CTL_PKE | PAD_CTL_PUE |		\
+	PAD_CTL_PUS_100K_DOWN | PAD_CTL_SPEED_LOW |		\
+	PAD_CTL_DSE_80ohm   | PAD_CTL_SRE_FAST  | PAD_CTL_HYS)
+
+#define ENET_PAD_CTRL  (PAD_CTL_PUS_100K_UP | PAD_CTL_PUE |     \
+	PAD_CTL_SPEED_HIGH   |                                   \
+	PAD_CTL_DSE_48ohm   | PAD_CTL_SRE_FAST)
+
+#define ENET_CLK_PAD_CTRL  (PAD_CTL_SPEED_MED | \
+	PAD_CTL_DSE_120ohm   | PAD_CTL_SRE_FAST)
+
+#define ENET_RX_PAD_CTRL  (PAD_CTL_PKE | PAD_CTL_PUE |          \
+	PAD_CTL_SPEED_HIGH   | PAD_CTL_SRE_FAST)
+
+#define I2C_PAD_CTRL    (PAD_CTL_PKE | PAD_CTL_PUE |            \
+	PAD_CTL_PUS_100K_UP | PAD_CTL_SPEED_MED |               \
+	PAD_CTL_DSE_40ohm | PAD_CTL_HYS |			\
+	PAD_CTL_ODE)
+
+#define LCD_PAD_CTRL    (PAD_CTL_HYS | PAD_CTL_PUS_100K_UP | PAD_CTL_PUE | \
+	PAD_CTL_PKE | PAD_CTL_SPEED_MED | PAD_CTL_DSE_40ohm)
+
+#define GPMI_PAD_CTRL0 (PAD_CTL_PKE | PAD_CTL_PUE | PAD_CTL_PUS_100K_UP)
+#define GPMI_PAD_CTRL1 (PAD_CTL_DSE_40ohm | PAD_CTL_SPEED_MED | \
+			PAD_CTL_SRE_FAST)
+#define GPMI_PAD_CTRL2 (GPMI_PAD_CTRL0 | GPMI_PAD_CTRL1)
+
+#define WEIM_NOR_PAD_CTRL (PAD_CTL_PKE | PAD_CTL_PUE | \
+		PAD_CTL_PUS_100K_UP | PAD_CTL_SPEED_MED | \
+		PAD_CTL_DSE_40ohm   | PAD_CTL_SRE_FAST)
+
+#define SPI_PAD_CTRL (PAD_CTL_HYS |				\
+	PAD_CTL_SPEED_MED |		\
+	PAD_CTL_DSE_40ohm | PAD_CTL_SRE_FAST)
+
+#define OTG_ID_PAD_CTRL (PAD_CTL_PKE | PAD_CTL_PUE |		\
+	PAD_CTL_PUS_47K_UP  | PAD_CTL_SPEED_LOW |		\
+	PAD_CTL_DSE_80ohm   | PAD_CTL_SRE_FAST  | PAD_CTL_HYS)
+
+#ifdef CONFIG_SYS_I2C_MXC
+#define PC MUX_PAD_CTRL(I2C_PAD_CTRL)
+/* I2C1 for PMIC and EEPROM */
+struct i2c_pads_info i2c_pad_info1 = {
+	.scl = {
+		/* conflict with usb_otg2_pwr */
+		.i2c_mode = MX6_PAD_GPIO1_IO02__I2C1_SCL | PC,
+		.gpio_mode = MX6_PAD_GPIO1_IO02__GPIO1_IO02 | PC,
+		.gp = IMX_GPIO_NR(1, 2),
+	},
+	.sda = {
+		/* conflict with usb_otg2_oc */
+		.i2c_mode = MX6_PAD_GPIO1_IO03__I2C1_SDA | PC,
+		.gpio_mode = MX6_PAD_GPIO1_IO03__GPIO1_IO03 | PC,
+		.gp = IMX_GPIO_NR(1, 3),
+	},
+};
+#endif
+
+int dram_init(void)
+{
+	gd->ram_size = PHYS_SDRAM_SIZE;
+
+	return 0;
+}
+
+static iomux_v3_cfg_t const uart1_pads[] = {
+	MX6_PAD_UART1_TX_DATA__UART1_DCE_TX | MUX_PAD_CTRL(UART_PAD_CTRL),
+	MX6_PAD_UART1_RX_DATA__UART1_DCE_RX | MUX_PAD_CTRL(UART_PAD_CTRL),
+};
+
+#ifdef CONFIG_MX6ULL_DDR3_ARM2_EMMC_REWORK
+static iomux_v3_cfg_t const usdhc1_emmc_pads[] = {
+	MX6_PAD_SD1_CLK__USDHC1_CLK | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD1_CMD__USDHC1_CMD | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD1_DATA0__USDHC1_DATA0 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD1_DATA1__USDHC1_DATA1 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD1_DATA2__USDHC1_DATA2 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD1_DATA3__USDHC1_DATA3 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	/*
+	 * The following 4 pins conflicts with qspi and nand flash.
+	 * You can comment out the following 4 pins and change
+	 * {USDHC1_BASE_ADDR, 0, 8}  -> {USDHC1_BASE_ADDR, 0, 4}
+	 * to make emmc and qspi coexists.
+	 */
+	MX6_PAD_NAND_READY_B__USDHC1_DATA4 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_NAND_CE0_B__USDHC1_DATA5 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_NAND_CE1_B__USDHC1_DATA6 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_NAND_CLE__USDHC1_DATA7 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+
+	/* Default NO WP for emmc, since we use pull down */
+	MX6_PAD_UART1_CTS_B__USDHC1_WP  | MUX_PAD_CTRL(USDHC_PAD_CTRL_WP),
+	/* RST_B */
+	MX6_PAD_GPIO1_IO09__GPIO1_IO09 | MUX_PAD_CTRL(NO_PAD_CTRL),
+};
+#else
+static iomux_v3_cfg_t const usdhc1_pads[] = {
+	MX6_PAD_SD1_CLK__USDHC1_CLK | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD1_CMD__USDHC1_CMD | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD1_DATA0__USDHC1_DATA0 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD1_DATA1__USDHC1_DATA1 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD1_DATA2__USDHC1_DATA2 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD1_DATA3__USDHC1_DATA3 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_UART1_CTS_B__USDHC1_WP | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+
+	/* VSELECT */
+	MX6_PAD_GPIO1_IO05__GPIO1_IO05 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	/* CD */
+	MX6_PAD_UART1_RTS_B__GPIO1_IO19 | MUX_PAD_CTRL(NO_PAD_CTRL),
+	/* RST_B */
+	MX6_PAD_GPIO1_IO09__GPIO1_IO09 | MUX_PAD_CTRL(NO_PAD_CTRL),
+};
+#endif
+
+#if !defined(CONFIG_SYS_USE_NAND) && !defined(CONFIG_MX6ULL_DDR3_ARM2_QSPIB_REWORK)
+static iomux_v3_cfg_t const usdhc2_pads[] = {
+	/* usdhc2_clk, nand_re_b, qspi1b_clk */
+	MX6_PAD_NAND_RE_B__USDHC2_CLK | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	/* usdhc2_cmd, nand_we_b, qspi1b_cs0_b */
+	MX6_PAD_NAND_WE_B__USDHC2_CMD | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	/* usdhc2_data0, nand_data0, qspi1b_cs1_b */
+	MX6_PAD_NAND_DATA00__USDHC2_DATA0 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	/* usdhc2_data1, nand_data1 */
+	MX6_PAD_NAND_DATA01__USDHC2_DATA1 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	/* usdhc2_data2, nand_data2, qspi1b_dat0 */
+	MX6_PAD_NAND_DATA02__USDHC2_DATA2 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	/* usdhc2_data3, nand_data3, qspi1b_dat1 */
+	MX6_PAD_NAND_DATA03__USDHC2_DATA3 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+
+	/*
+	 * VSELECT
+	 * Conflicts with WDOG1, so default disabled.
+	 * MX6_PAD_GPIO1_IO08__USDHC2_VSELECT | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	 */
+	/*
+	 * CD
+	 * Share with sdhc1
+	 * MX6_PAD_CSI_MCLK__GPIO4_IO17 | MUX_PAD_CTRL(NO_PAD_CTRL),
+	 */
+	/*
+	 * RST_B
+	 * Pin conflicts with NAND ALE, if want to test nand,
+	 * Connect R169(B), disconnect R169(A).
+	 */
+	MX6_PAD_NAND_ALE__GPIO4_IO10 | MUX_PAD_CTRL(NO_PAD_CTRL),
+};
+#endif
+
+#ifdef CONFIG_SYS_USE_NAND
+static iomux_v3_cfg_t const nand_pads[] = {
+	MX6_PAD_NAND_DATA00__RAWNAND_DATA00 | MUX_PAD_CTRL(GPMI_PAD_CTRL2),
+	MX6_PAD_NAND_DATA01__RAWNAND_DATA01 | MUX_PAD_CTRL(GPMI_PAD_CTRL2),
+	MX6_PAD_NAND_DATA02__RAWNAND_DATA02 | MUX_PAD_CTRL(GPMI_PAD_CTRL2),
+	MX6_PAD_NAND_DATA03__RAWNAND_DATA03 | MUX_PAD_CTRL(GPMI_PAD_CTRL2),
+	MX6_PAD_NAND_DATA04__RAWNAND_DATA04 | MUX_PAD_CTRL(GPMI_PAD_CTRL2),
+	MX6_PAD_NAND_DATA05__RAWNAND_DATA05 | MUX_PAD_CTRL(GPMI_PAD_CTRL2),
+	MX6_PAD_NAND_DATA06__RAWNAND_DATA06 | MUX_PAD_CTRL(GPMI_PAD_CTRL2),
+	MX6_PAD_NAND_DATA07__RAWNAND_DATA07 | MUX_PAD_CTRL(GPMI_PAD_CTRL2),
+	MX6_PAD_NAND_CLE__RAWNAND_CLE | MUX_PAD_CTRL(GPMI_PAD_CTRL2),
+	MX6_PAD_NAND_ALE__RAWNAND_ALE | MUX_PAD_CTRL(GPMI_PAD_CTRL2),
+	MX6_PAD_NAND_CE0_B__RAWNAND_CE0_B | MUX_PAD_CTRL(GPMI_PAD_CTRL2),
+	MX6_PAD_NAND_CE1_B__RAWNAND_CE1_B | MUX_PAD_CTRL(GPMI_PAD_CTRL2),
+	MX6_PAD_CSI_MCLK__RAWNAND_CE2_B   | MUX_PAD_CTRL(GPMI_PAD_CTRL2),
+	MX6_PAD_CSI_PIXCLK__RAWNAND_CE3_B | MUX_PAD_CTRL(GPMI_PAD_CTRL2),
+	MX6_PAD_NAND_RE_B__RAWNAND_RE_B | MUX_PAD_CTRL(GPMI_PAD_CTRL2),
+	MX6_PAD_NAND_WE_B__RAWNAND_WE_B | MUX_PAD_CTRL(GPMI_PAD_CTRL2),
+	MX6_PAD_NAND_WP_B__RAWNAND_WP_B | MUX_PAD_CTRL(GPMI_PAD_CTRL2),
+	MX6_PAD_NAND_READY_B__RAWNAND_READY_B | MUX_PAD_CTRL(GPMI_PAD_CTRL2),
+	MX6_PAD_NAND_DQS__RAWNAND_DQS | MUX_PAD_CTRL(GPMI_PAD_CTRL2),
+};
+
+static void setup_gpmi_nand(void)
+{
+	struct mxc_ccm_reg *mxc_ccm = (struct mxc_ccm_reg *)CCM_BASE_ADDR;
+
+	/* config gpmi nand iomux */
+	imx_iomux_v3_setup_multiple_pads(nand_pads, ARRAY_SIZE(nand_pads));
+
+	clrbits_le32(&mxc_ccm->CCGR4,
+		     MXC_CCM_CCGR4_RAWNAND_U_BCH_INPUT_APB_MASK |
+		     MXC_CCM_CCGR4_RAWNAND_U_GPMI_BCH_INPUT_BCH_MASK |
+		     MXC_CCM_CCGR4_RAWNAND_U_GPMI_BCH_INPUT_GPMI_IO_MASK |
+		     MXC_CCM_CCGR4_RAWNAND_U_GPMI_INPUT_APB_MASK |
+		     MXC_CCM_CCGR4_PL301_MX6QPER1_BCH_MASK);
+
+	/*
+	 * config gpmi and bch clock to 100 MHz
+	 * bch/gpmi select PLL2 PFD2 400M
+	 * 100M = 400M / 4
+	 */
+	clrbits_le32(&mxc_ccm->cscmr1,
+		     MXC_CCM_CSCMR1_BCH_CLK_SEL |
+		     MXC_CCM_CSCMR1_GPMI_CLK_SEL);
+	clrsetbits_le32(&mxc_ccm->cscdr1,
+			MXC_CCM_CSCDR1_BCH_PODF_MASK |
+			MXC_CCM_CSCDR1_GPMI_PODF_MASK,
+			(3 << MXC_CCM_CSCDR1_BCH_PODF_OFFSET) |
+			(3 << MXC_CCM_CSCDR1_GPMI_PODF_OFFSET));
+
+	/* enable gpmi and bch clock gating */
+	setbits_le32(&mxc_ccm->CCGR4,
+		     MXC_CCM_CCGR4_RAWNAND_U_BCH_INPUT_APB_MASK |
+		     MXC_CCM_CCGR4_RAWNAND_U_GPMI_BCH_INPUT_BCH_MASK |
+		     MXC_CCM_CCGR4_RAWNAND_U_GPMI_BCH_INPUT_GPMI_IO_MASK |
+		     MXC_CCM_CCGR4_RAWNAND_U_GPMI_INPUT_APB_MASK |
+		     MXC_CCM_CCGR4_PL301_MX6QPER1_BCH_MASK);
+
+	/* enable apbh clock gating */
+	setbits_le32(&mxc_ccm->CCGR0, MXC_CCM_CCGR0_APBHDMA_MASK);
+}
+#endif
+
+#ifdef CONFIG_SYS_USE_SPINOR
+static iomux_v3_cfg_t const ecspi1_pads[] = {
+	MX6_PAD_CSI_DATA06__ECSPI1_MOSI | MUX_PAD_CTRL(SPI_PAD_CTRL),
+	MX6_PAD_CSI_DATA04__ECSPI1_SCLK | MUX_PAD_CTRL(SPI_PAD_CTRL),
+	MX6_PAD_CSI_DATA07__ECSPI1_MISO | MUX_PAD_CTRL(SPI_PAD_CTRL),
+
+	/* CS Pin */
+	MX6_PAD_CSI_DATA05__GPIO4_IO26 | MUX_PAD_CTRL(NO_PAD_CTRL),
+};
+
+static void setup_spinor(void)
+{
+	imx_iomux_v3_setup_multiple_pads(ecspi1_pads, ARRAY_SIZE(ecspi1_pads));
+	gpio_direction_output(IMX_GPIO_NR(4, 26), 0);
+}
+
+int board_spi_cs_gpio(unsigned bus, unsigned cs)
+{
+	return (bus == 0 && cs == 0) ? (IMX_GPIO_NR(4, 26)) : -1;
+}
+#endif
+
+#ifdef CONFIG_FEC_MXC
+/*
+ * pin conflicts for fec1 and fec2, GPIO1_IO06 and GPIO1_IO07 can only
+ * be used for ENET1 or ENET2, cannot be used for both.
+ */
+static iomux_v3_cfg_t const fec1_pads[] = {
+	MX6_PAD_GPIO1_IO06__ENET1_MDIO | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_GPIO1_IO07__ENET1_MDC | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_ENET1_TX_DATA0__ENET1_TDATA00 | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_ENET1_TX_DATA1__ENET1_TDATA01 | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_ENET1_TX_EN__ENET1_TX_EN | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_ENET1_TX_CLK__ENET1_REF_CLK1 | MUX_PAD_CTRL(ENET_CLK_PAD_CTRL),
+	/* Pin conflicts with LCD PWM1 */
+	MX6_PAD_ENET1_RX_DATA0__ENET1_RDATA00 | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_ENET1_RX_DATA1__ENET1_RDATA01 | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_ENET1_RX_ER__ENET1_RX_ER | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_ENET1_RX_EN__ENET1_RX_EN | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	/*
+	 * ALT5 mode is only valid when TAMPER pin is used for GPIO.
+	 * This depends on FUSE settings, TAMPER_PIN_DISABLE[1:0].
+	 *
+	 * ENET1_RST
+	 */
+	MX6_PAD_SNVS_TAMPER2__GPIO5_IO02 | MUX_PAD_CTRL(NO_PAD_CTRL),
+};
+
+static iomux_v3_cfg_t const fec2_pads[] = {
+	MX6_PAD_GPIO1_IO06__ENET2_MDIO | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_GPIO1_IO07__ENET2_MDC | MUX_PAD_CTRL(ENET_PAD_CTRL),
+
+	MX6_PAD_ENET2_RX_DATA0__ENET2_RDATA00 | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_ENET2_RX_DATA1__ENET2_RDATA01 | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_UART3_TX_DATA__ENET2_RDATA02 | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_UART3_RX_DATA__ENET2_RDATA03 | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_ENET2_RX_EN__ENET2_RX_EN | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_ENET2_RX_ER__ENET2_RX_ER | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_UART3_CTS_B__ENET2_RX_CLK | MUX_PAD_CTRL(ENET_PAD_CTRL),
+
+	MX6_PAD_ENET2_TX_DATA0__ENET2_TDATA00 | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_ENET2_TX_DATA1__ENET2_TDATA01 | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_UART4_TX_DATA__ENET2_TDATA02 | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_UART4_RX_DATA__ENET2_TDATA03 | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_ENET2_TX_CLK__ENET2_TX_CLK | MUX_PAD_CTRL(ENET_CLK_PAD_CTRL),
+	MX6_PAD_ENET2_TX_EN__ENET2_TX_EN | MUX_PAD_CTRL(ENET_PAD_CTRL),
+
+	MX6_PAD_UART5_RX_DATA__ENET2_COL | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_UART5_TX_DATA__ENET2_CRS | MUX_PAD_CTRL(ENET_PAD_CTRL),
+
+	/*
+	 * ENET2_RST
+	 *
+	 * This depends on FUSE settings, TAMPER_PIN_DISABLE[1:0]
+	 */
+	MX6_PAD_SNVS_TAMPER4__GPIO5_IO04 | MUX_PAD_CTRL(NO_PAD_CTRL),
+};
+
+static void setup_iomux_fec(int fec_id)
+{
+	if (fec_id == 0) {
+		imx_iomux_v3_setup_multiple_pads(fec1_pads,
+						 ARRAY_SIZE(fec1_pads));
+		gpio_direction_output(IMX_GPIO_NR(5, 2), 0);
+		udelay(50);
+		gpio_direction_output(IMX_GPIO_NR(5, 2), 1);
+	} else {
+		imx_iomux_v3_setup_multiple_pads(fec2_pads,
+						 ARRAY_SIZE(fec2_pads));
+		gpio_direction_output(IMX_GPIO_NR(5, 4), 0);
+		udelay(50);
+		gpio_direction_output(IMX_GPIO_NR(5, 4), 1);
+	}
+}
+#endif
+
+static void setup_iomux_uart(void)
+{
+	imx_iomux_v3_setup_multiple_pads(uart1_pads, ARRAY_SIZE(uart1_pads));
+}
+
+#ifdef CONFIG_FSL_QSPI
+
+#define QSPI_PAD_CTRL1	\
+	(PAD_CTL_SRE_FAST | PAD_CTL_SPEED_MED | \
+	 PAD_CTL_PKE | PAD_CTL_PUE | PAD_CTL_PUS_47K_UP | PAD_CTL_DSE_120ohm)
+
+static iomux_v3_cfg_t const quadspi_pads[] = {
+	MX6_PAD_NAND_WP_B__QSPI_A_SCLK	| MUX_PAD_CTRL(QSPI_PAD_CTRL1),
+	MX6_PAD_NAND_READY_B__QSPI_A_DATA00	| MUX_PAD_CTRL(QSPI_PAD_CTRL1),
+	MX6_PAD_NAND_CE0_B__QSPI_A_DATA01	| MUX_PAD_CTRL(QSPI_PAD_CTRL1),
+	MX6_PAD_NAND_CE1_B__QSPI_A_DATA02	| MUX_PAD_CTRL(QSPI_PAD_CTRL1),
+	MX6_PAD_NAND_CLE__QSPI_A_DATA03	| MUX_PAD_CTRL(QSPI_PAD_CTRL1),
+	MX6_PAD_NAND_DQS__QSPI_A_SS0_B	| MUX_PAD_CTRL(QSPI_PAD_CTRL1),
+	MX6_PAD_NAND_DATA07__QSPI_A_SS1_B	| MUX_PAD_CTRL(QSPI_PAD_CTRL1),
+
+#ifdef CONFIG_MX6ULL_DDR3_ARM2_QSPIB_REWORK
+	MX6_PAD_NAND_RE_B__QSPI_B_SCLK	| MUX_PAD_CTRL(QSPI_PAD_CTRL1),
+	MX6_PAD_NAND_WE_B__QSPI_B_SS0_B	| MUX_PAD_CTRL(QSPI_PAD_CTRL1),
+	MX6_PAD_NAND_DATA00__QSPI_B_SS1_B	| MUX_PAD_CTRL(QSPI_PAD_CTRL1),
+	MX6_PAD_NAND_DATA02__QSPI_B_DATA00	| MUX_PAD_CTRL(QSPI_PAD_CTRL1),
+	MX6_PAD_NAND_DATA03__QSPI_B_DATA01	| MUX_PAD_CTRL(QSPI_PAD_CTRL1),
+	MX6_PAD_NAND_DATA04__QSPI_B_DATA02	| MUX_PAD_CTRL(QSPI_PAD_CTRL1),
+	MX6_PAD_NAND_DATA05__QSPI_B_DATA03	| MUX_PAD_CTRL(QSPI_PAD_CTRL1),
+#endif
+};
+
+int board_qspi_init(void)
+{
+	/* Set the iomux */
+	imx_iomux_v3_setup_multiple_pads(quadspi_pads,
+					 ARRAY_SIZE(quadspi_pads));
+
+	/* Set the clock */
+	enable_qspi_clk(0);
+
+	return 0;
+}
+#endif
+
+#ifdef CONFIG_FSL_ESDHC
+static struct fsl_esdhc_cfg usdhc_cfg[2] = {
+#ifdef CONFIG_MX6ULL_DDR3_ARM2_EMMC_REWORK
+	/* If want to use qspi, should change to 4 bit width */
+	{USDHC1_BASE_ADDR, 0, 8},
+#else
+	{USDHC1_BASE_ADDR, 0, 4},
+#endif
+#if !defined(CONFIG_SYS_USE_NAND) && !defined(CONFIG_MX6ULL_DDR3_ARM2_QSPIB_REWORK)
+	{USDHC2_BASE_ADDR, 0, 4},
+#endif
+};
+
+#define USDHC1_CD_GPIO	IMX_GPIO_NR(1, 19)
+#define USDHC1_PWR_GPIO	IMX_GPIO_NR(1, 9)
+#define USDHC1_VSELECT IMX_GPIO_NR(1, 5)
+#define USDHC2_PWR_GPIO	IMX_GPIO_NR(4, 10)
+
+int mmc_get_env_devno(void)
+{
+	u32 soc_sbmr = readl(SRC_BASE_ADDR + 0x4);
+	int dev_no;
+	u32 bootsel;
+
+	bootsel = (soc_sbmr & 0x000000FF) >> 6;
+
+	/* If not boot from sd/mmc, use default value */
+	if (bootsel != 1)
+		return CONFIG_SYS_MMC_ENV_DEV;
+
+	/* BOOT_CFG2[3] and BOOT_CFG2[4] */
+	dev_no = (soc_sbmr & 0x00001800) >> 11;
+
+	return dev_no;
+}
+
+int mmc_map_to_kernel_blk(int dev_no)
+{
+	return dev_no;
+}
+
+int board_mmc_getcd(struct mmc *mmc)
+{
+	struct fsl_esdhc_cfg *cfg = (struct fsl_esdhc_cfg *)mmc->priv;
+	int ret = 0;
+
+	switch (cfg->esdhc_base) {
+	case USDHC1_BASE_ADDR:
+#ifdef CONFIG_MX6ULL_DDR3_ARM2_EMMC_REWORK
+		ret = 1;
+#else
+		ret = !gpio_get_value(USDHC1_CD_GPIO);
+#endif
+		break;
+#if !defined(CONFIG_SYS_USE_NAND) && !defined(CONFIG_MX6ULL_DDR3_ARM2_QSPIB_REWORK)
+	case USDHC2_BASE_ADDR:
+		ret = 1;
+		break;
+#endif
+	}
+
+	return ret;
+}
+
+int board_mmc_init(bd_t *bis)
+{
+	int i;
+
+	/*
+	 * According to the board_mmc_init() the following map is done:
+	 * (U-boot device node)    (Physical Port)
+	 * mmc0                    USDHC1
+	 * mmc1                    USDHC2
+	 */
+	for (i = 0; i < CONFIG_SYS_FSL_USDHC_NUM; i++) {
+		switch (i) {
+		case 0:
+#ifdef CONFIG_MX6ULL_DDR3_ARM2_EMMC_REWORK
+			imx_iomux_v3_setup_multiple_pads(
+				usdhc1_emmc_pads, ARRAY_SIZE(usdhc1_emmc_pads));
+#else
+			imx_iomux_v3_setup_multiple_pads(
+				usdhc1_pads, ARRAY_SIZE(usdhc1_pads));
+			gpio_direction_input(USDHC1_CD_GPIO);
+#endif
+			usdhc_cfg[0].sdhc_clk = mxc_get_clock(MXC_ESDHC_CLK);
+			/* 3.3V */
+			gpio_direction_output(USDHC1_VSELECT, 0);
+			gpio_direction_output(USDHC1_PWR_GPIO, 1);
+			break;
+#if !defined(CONFIG_SYS_USE_NAND) && !defined(CONFIG_MX6ULL_DDR3_ARM2_QSPIB_REWORK)
+		case 1:
+			imx_iomux_v3_setup_multiple_pads(
+				usdhc2_pads, ARRAY_SIZE(usdhc2_pads));
+			gpio_direction_output(USDHC2_PWR_GPIO, 1);
+			usdhc_cfg[1].sdhc_clk = mxc_get_clock(MXC_ESDHC2_CLK);
+			break;
+#endif
+		default:
+			printf("Warning: you configured more USDHC controllers (%d) than supported by the board\n", i + 1);
+			return 0;
+			}
+
+			if (fsl_esdhc_initialize(bis, &usdhc_cfg[i]))
+				printf("Warning: failed to initialize mmc dev %d\n", i);
+	}
+
+	return 0;
+}
+
+int check_mmc_autodetect(void)
+{
+	char *autodetect_str = getenv("mmcautodetect");
+
+	if ((autodetect_str != NULL) && (strcmp(autodetect_str, "yes") == 0))
+		return 1;
+
+	return 0;
+}
+
+void board_late_mmc_init(void)
+{
+	char cmd[32];
+	char mmcblk[32];
+	u32 dev_no = mmc_get_env_devno();
+
+	if (!check_mmc_autodetect())
+		return;
+
+	setenv_ulong("mmcdev", dev_no);
+
+	/* Set mmcblk env */
+	sprintf(mmcblk, "/dev/mmcblk%dp2 rootwait rw",
+		mmc_map_to_kernel_blk(dev_no));
+	setenv("mmcroot", mmcblk);
+
+	sprintf(cmd, "mmc dev %d", dev_no);
+	run_command(cmd, 0);
+}
+#endif
+
+#ifdef CONFIG_VIDEO_MXS
+static iomux_v3_cfg_t const lcd_pads[] = {
+	MX6_PAD_LCD_CLK__LCDIF_CLK | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_ENABLE__LCDIF_ENABLE | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_HSYNC__LCDIF_HSYNC | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_VSYNC__LCDIF_VSYNC | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_DATA00__LCDIF_DATA00 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_DATA01__LCDIF_DATA01 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_DATA02__LCDIF_DATA02 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_DATA03__LCDIF_DATA03 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_DATA04__LCDIF_DATA04 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_DATA05__LCDIF_DATA05 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_DATA06__LCDIF_DATA06 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_DATA07__LCDIF_DATA07 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_DATA08__LCDIF_DATA08 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_DATA09__LCDIF_DATA09 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_DATA10__LCDIF_DATA10 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_DATA11__LCDIF_DATA11 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_DATA12__LCDIF_DATA12 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_DATA13__LCDIF_DATA13 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_DATA14__LCDIF_DATA14 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_DATA15__LCDIF_DATA15 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_DATA16__LCDIF_DATA16 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_DATA17__LCDIF_DATA17 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_DATA18__LCDIF_DATA18 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_DATA19__LCDIF_DATA19 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_DATA20__LCDIF_DATA20 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_DATA21__LCDIF_DATA21 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_DATA22__LCDIF_DATA22 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_DATA23__LCDIF_DATA23 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6_PAD_LCD_RESET__GPIO3_IO04 | MUX_PAD_CTRL(NO_PAD_CTRL),
+
+	/*
+	 * PWM1, pin conflicts with ENET1_RX_DATA0
+	 * Use GPIO for Brightness adjustment, duty cycle = period.
+	 */
+	/* MX6_PAD_ENET1_RX_DATA0__GPIO2_IO00 | MUX_PAD_CTRL(NO_PAD_CTRL),*/
+};
+
+struct lcd_panel_info_t {
+	unsigned int lcdif_base_addr;
+	int depth;
+	void (*enable)(struct lcd_panel_info_t const *dev);
+	struct fb_videomode mode;
+};
+
+void do_enable_parallel_lcd(struct lcd_panel_info_t const *dev)
+{
+	enable_lcdif_clock(dev->lcdif_base_addr);
+
+	imx_iomux_v3_setup_multiple_pads(lcd_pads, ARRAY_SIZE(lcd_pads));
+
+	/* Power up the LCD */
+	gpio_direction_output(IMX_GPIO_NR(3, 4) , 1);
+
+	/* Set Brightness to high */
+	/* gpio_direction_output(IMX_GPIO_NR(2, 0) , 1); */
+}
+
+static struct lcd_panel_info_t const displays[] = {{
+	.lcdif_base_addr = LCDIF1_BASE_ADDR,
+	.depth = 24,
+	.enable	= do_enable_parallel_lcd,
+	.mode	= {
+		.name		= "MCIMX28LCD",
+		.xres           = 800,
+		.yres           = 480,
+		.pixclock       = 29850,
+		.left_margin    = 89,
+		.right_margin   = 164,
+		.upper_margin   = 23,
+		.lower_margin   = 10,
+		.hsync_len      = 10,
+		.vsync_len      = 10,
+		.sync           = 0,
+		.vmode          = FB_VMODE_NONINTERLACED
+} } };
+
+int board_video_skip(void)
+{
+	int i;
+	int ret;
+	char const *panel = getenv("panel");
+	if (!panel) {
+		panel = displays[0].mode.name;
+		printf("No panel detected: default to %s\n", panel);
+		i = 0;
+	} else {
+		for (i = 0; i < ARRAY_SIZE(displays); i++) {
+			if (!strcmp(panel, displays[i].mode.name))
+				break;
+		}
+	}
+	if (i < ARRAY_SIZE(displays)) {
+		ret = mxs_lcd_panel_setup(displays[i].mode, displays[i].depth,
+				    displays[i].lcdif_base_addr);
+		if (!ret) {
+			if (displays[i].enable)
+				displays[i].enable(displays+i);
+			printf("Display: %s (%ux%u)\n",
+			       displays[i].mode.name,
+			       displays[i].mode.xres,
+			       displays[i].mode.yres);
+		} else
+			printf("LCD %s cannot be configured: %d\n",
+			       displays[i].mode.name, ret);
+	} else {
+		printf("unsupported panel %s\n", panel);
+		return -EINVAL;
+	}
+
+	return 0;
+}
+#endif
+
+#ifdef CONFIG_FEC_MXC
+int board_eth_init(bd_t *bis)
+{
+	int ret;
+
+	setup_iomux_fec(CONFIG_FEC_ENET_DEV);
+
+	ret = fecmxc_initialize_multi(bis, CONFIG_FEC_ENET_DEV,
+		CONFIG_FEC_MXC_PHYADDR, IMX_FEC_BASE);
+	if (ret)
+		printf("FEC%d MXC: %s:failed\n", CONFIG_FEC_ENET_DEV, __func__);
+
+	return 0;
+}
+
+static int setup_fec(int fec_id)
+{
+	struct iomuxc_gpr_base_regs *const iomuxc_gpr_regs
+		= (struct iomuxc_gpr_base_regs *)IOMUXC_GPR_BASE_ADDR;
+	int ret;
+
+	if (0 == fec_id) {
+		/*
+		 * Use 50M anatop loopback REF_CLK1 for ENET1,
+		 * clear gpr1[13], set gpr1[17]
+		 */
+		clrsetbits_le32(&iomuxc_gpr_regs->gpr[1], IOMUX_GPR1_FEC1_MASK,
+				IOMUX_GPR1_FEC1_CLOCK_MUX1_SEL_MASK);
+		ret = enable_fec_anatop_clock(fec_id, ENET_50MHZ);
+		if (ret)
+			return ret;
+
+	} else {
+		/* clk from phy, set gpr1[14], clear gpr1[18]*/
+		clrsetbits_le32(&iomuxc_gpr_regs->gpr[1], IOMUX_GPR1_FEC2_MASK,
+				IOMUX_GPR1_FEC2_CLOCK_MUX2_SEL_MASK);
+	}
+
+	enable_enet_clk(1);
+
+	return 0;
+}
+
+int board_phy_config(struct phy_device *phydev)
+{
+	if (CONFIG_FEC_ENET_DEV == 0) {
+		phy_write(phydev, MDIO_DEVAD_NONE, 0x16, 0x202);
+		phy_write(phydev, MDIO_DEVAD_NONE, 0x1f, 0x8190);
+	} else if (CONFIG_FEC_ENET_DEV == 1) {
+		phy_write(phydev, MDIO_DEVAD_NONE, 0x16, 0x201);
+		phy_write(phydev, MDIO_DEVAD_NONE, 0x1f, 0x8110);
+	}
+
+	if (phydev->drv->config)
+		phydev->drv->config(phydev);
+
+	return 0;
+}
+#endif
+
+#ifdef CONFIG_POWER
+#define I2C_PMIC	0
+static struct pmic *pfuze;
+int power_init_board(void)
+{
+	int ret;
+	u32 rev_id, value;
+
+	ret = power_pfuze100_init(I2C_PMIC);
+	if (ret)
+		return ret;
+
+	pfuze = pmic_get("PFUZE100");
+	if (!pfuze)
+		return -ENODEV;
+
+	ret = pmic_probe(pfuze);
+	if (ret)
+		return ret;
+
+	ret = pfuze_mode_init(pfuze, APS_PFM);
+	if (ret < 0)
+		return ret;
+
+	pmic_reg_read(pfuze, PFUZE100_DEVICEID, &value);
+	pmic_reg_read(pfuze, PFUZE100_REVID, &rev_id);
+	printf("PMIC: PFUZE200! DEV_ID=0x%x REV_ID=0x%x\n", value, rev_id);
+
+	/*
+	 * Our PFUZE0200 is PMPF0200X0AEP, the Pre-programmed OTP
+	 * Configuration is F0.
+	 * Default VOLT:
+	 * VSNVS_VOLT	|	3.0V
+	 * SW1AB	|	1.375V
+	 * SW2		|	3.3V
+	 * SW3A		|	1.5V
+	 * SW3B		|	1.5V
+	 * VGEN1	|	1.5V
+	 * VGEN2	|	1.5V
+	 * VGEN3	|	2.5V
+	 * VGEN4	|	1.8V
+	 * VGEN5	|	2.8V
+	 * VGEN6	|	3.3V
+	 *
+	 * According to schematic, we need SW3A 1.35V, SW3B 3.3V,
+	 * VGEN1 1.2V, VGEN2 1.5V, VGEN3 2.8V, VGEN4 1.8V,
+	 * VGEN5 3.3V, VGEN6 3.0V.
+	 *
+	 * Here we just use the default VOLT, but not configure
+	 * them, when needed, configure them to our requested voltage.
+	 */
+
+	/* set SW1AB standby volatage 0.975V */
+	pmic_reg_read(pfuze, PFUZE100_SW1ABSTBY, &value);
+	value &= ~0x3f;
+	value |= PFUZE100_SW1ABC_SETP(9750);
+	pmic_reg_write(pfuze, PFUZE100_SW1ABSTBY, value);
+
+	/* set SW1AB/VDDARM step ramp up time from 16us to 4us/25mV */
+	pmic_reg_read(pfuze, PFUZE100_SW1ABCONF, &value);
+	value &= ~0xc0;
+	value |= 0x40;
+	pmic_reg_write(pfuze, PFUZE100_SW1ABCONF, value);
+
+	/* Enable power of VGEN5 3V3 */
+	pmic_reg_read(pfuze, PFUZE100_VGEN5VOL, &value);
+	value &= ~0x1F;
+	value |= 0x1F;
+	pmic_reg_write(pfuze, PFUZE100_VGEN5VOL, value);
+
+	return 0;
+}
+
+#ifdef CONFIG_LDO_BYPASS_CHECK
+void ldo_mode_set(int ldo_bypass)
+{
+	unsigned int value;
+	int is_400M;
+	u32 vddarm;
+
+	struct pmic *p = pfuze;
+
+	if (!p) {
+		printf("No PMIC found!\n");
+		return;
+	}
+
+	/* switch to ldo_bypass mode */
+	if (ldo_bypass) {
+		prep_anatop_bypass();
+		/* decrease VDDARM to 1.275V */
+		pmic_reg_read(pfuze, PFUZE100_SW1ABVOL, &value);
+		value &= ~0x3f;
+		value |= PFUZE100_SW1ABC_SETP(12750);
+		pmic_reg_write(pfuze, PFUZE100_SW1ABVOL, value);
+
+		is_400M = set_anatop_bypass(1);
+		if (is_400M)
+			vddarm = PFUZE100_SW1ABC_SETP(10750);
+		else
+			vddarm = PFUZE100_SW1ABC_SETP(11750);
+
+		pmic_reg_read(pfuze, PFUZE100_SW1ABVOL, &value);
+		value &= ~0x3f;
+		value |= vddarm;
+		pmic_reg_write(pfuze, PFUZE100_SW1ABVOL, value);
+
+		finish_anatop_bypass();
+
+		printf("switch to ldo_bypass mode!\n");
+	}
+}
+#endif
+#endif
+
+int board_early_init_f(void)
+{
+	setup_iomux_uart();
+
+	return 0;
+}
+
+int board_init(void)
+{
+	/* Address of boot parameters */
+	gd->bd->bi_boot_params = PHYS_SDRAM + 0x100;
+
+#ifdef CONFIG_SYS_I2C_MXC
+	setup_i2c(0, CONFIG_SYS_I2C_SPEED, 0x7f, &i2c_pad_info1);
+#endif
+
+#ifdef CONFIG_FEC_MXC
+	setup_fec(CONFIG_FEC_ENET_DEV);
+#endif
+
+#ifdef CONFIG_SYS_USE_SPINOR
+	setup_spinor();
+#endif
+
+#ifdef CONFIG_SYS_USE_NAND
+	setup_gpmi_nand();
+#endif
+
+#ifdef CONFIG_SYS_USE_QSPI
+	board_qspi_init();
+#endif
+
+	return 0;
+}
+
+#ifdef CONFIG_CMD_BMODE
+static const struct boot_mode board_boot_modes[] = {
+	/* 4 bit bus width */
+	{"sd1", MAKE_CFGVAL(0x42, 0x20, 0x00, 0x00)},
+	{"qspi1", MAKE_CFGVAL(0x10, 0x00, 0x00, 0x00)},
+	{NULL,	 0},
+};
+#endif
+
+int board_late_init(void)
+{
+#ifdef CONFIG_CMD_BMODE
+	add_board_boot_modes(board_boot_modes);
+#endif
+
+#ifdef CONFIG_ENV_IS_IN_MMC
+	board_late_mmc_init();
+#endif
+
+	return 0;
+}
+
+u32 get_board_rev(void)
+{
+	return get_cpu_rev();
+}
+
+int checkboard(void)
+{
+	puts("Board: MX6ULL 14X14 DDR3 ARM2\n");
+
+	return 0;
+}
+
+#ifdef CONFIG_USB_EHCI_MX6
+#define USB_OTHERREGS_OFFSET	0x800
+#define UCTRL_PWR_POL		(1 << 9)
+iomux_v3_cfg_t const usb_otg1_pads[] = {
+	MX6_PAD_GPIO1_IO04__USB_OTG1_PWR | MUX_PAD_CTRL(NO_PAD_CTRL),
+	MX6_PAD_GPIO1_IO00__ANATOP_OTG1_ID | MUX_PAD_CTRL(OTG_ID_PAD_CTRL),
+};
+
+/*
+ * Leave it here, but default configuration only supports 1 port now,
+ * because we need sd1 and i2c1
+ */
+iomux_v3_cfg_t const usb_otg2_pads[] = {
+	/* conflict with i2c1_scl */
+	MX6_PAD_GPIO1_IO02__USB_OTG2_PWR | MUX_PAD_CTRL(NO_PAD_CTRL),
+	/* conflict with sd1_vselect */
+	MX6_PAD_GPIO1_IO05__ANATOP_OTG2_ID | MUX_PAD_CTRL(OTG_ID_PAD_CTRL),
+};
+
+int board_usb_phy_mode(int port)
+{
+	return usb_phy_mode(port);
+}
+
+int board_ehci_hcd_init(int port)
+{
+	u32 *usbnc_usb_ctrl;
+
+	if (port > 1)
+		return -EINVAL;
+
+	switch (port) {
+	case 0:
+		imx_iomux_v3_setup_multiple_pads(usb_otg1_pads,
+						 ARRAY_SIZE(usb_otg1_pads));
+		break;
+	case 1:
+		imx_iomux_v3_setup_multiple_pads(usb_otg2_pads,
+						 ARRAY_SIZE(usb_otg2_pads));
+		break;
+	default:
+		printf("MXC USB port %d not yet supported\n", port);
+		return 1;
+	}
+
+	usbnc_usb_ctrl = (u32 *)(USB_BASE_ADDR + USB_OTHERREGS_OFFSET +
+				 port * 4);
+
+	/* Set Power polarity */
+	setbits_le32(usbnc_usb_ctrl, UCTRL_PWR_POL);
+
+	return 0;
+}
+#endif
diff --git a/board/freescale/mx6ull_ddr3_arm2/plugin.S b/board/freescale/mx6ull_ddr3_arm2/plugin.S
new file mode 100644
index 0000000..e32cc13
--- /dev/null
+++ b/board/freescale/mx6ull_ddr3_arm2/plugin.S
@@ -0,0 +1,137 @@
+/*
+ * Copyright (C) 2016 Freescale Semiconductor, Inc.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <config.h>
+
+/* DDR script */
+.macro imx6ull_ddr3_arm2_setting
+	ldr r0, =IOMUXC_BASE_ADDR
+	ldr r1, =0x000C0000
+	str r1, [r0, #0x4B4]
+	ldr r1, =0x00000000
+	str r1, [r0, #0x4AC]
+	ldr r1, =0x00000030
+	str r1, [r0, #0x27C]
+	str r1, [r0, #0x250]
+	str r1, [r0, #0x24C]
+	str r1, [r0, #0x490]
+	ldr r1, =0x000C0030
+	str r1, [r0, #0x288]
+
+	ldr r1, =0x00000000
+	str r1, [r0, #0x270]
+
+	ldr r1, =0x00000030
+	str r1, [r0, #0x260]
+	str r1, [r0, #0x264]
+	str r1, [r0, #0x4A0]
+
+	ldr r1, =0x00020000
+	str r1, [r0, #0x494]
+
+	ldr r1, =0x00000030
+	str r1, [r0, #0x280]
+	str r1, [r0, #0x284]
+
+	ldr r1, =0x00020000
+	str r1, [r0, #0x4B0]
+
+	ldr r1, =0x00000030
+	str r1, [r0, #0x498]
+	str r1, [r0, #0x4A4]
+	str r1, [r0, #0x244]
+	str r1, [r0, #0x248]
+
+	ldr r0, =MMDC_P0_BASE_ADDR
+	ldr r1, =0x00008000
+	str r1, [r0, #0x1C]
+	ldr r1, =0xA1390003
+	str r1, [r0, #0x800]
+	ldr r1, =0x00150019
+	str r1, [r0, #0x80C]
+	ldr r1, =0x41550153
+	str r1, [r0, #0x83C]
+	ldr r1, =0x40403A3E
+	str r1, [r0, #0x848]
+	ldr r1, =0x40402F2A
+	str r1, [r0, #0x850]
+	ldr r1, =0x33333333
+	str r1, [r0, #0x81C]
+	str r1, [r0, #0x820]
+	ldr r1, =0xF3333333
+	str r1, [r0, #0x82C]
+	str r1, [r0, #0x830]
+	ldr r1, =0x00944009
+	str r1, [r0, #0x8C0]
+	ldr r1, =0x00000800
+	str r1, [r0, #0x8B8]
+	ldr r1, =0x0002002D
+	str r1, [r0, #0x004]
+	ldr r1, =0x1B333030
+	str r1, [r0, #0x008]
+	ldr r1, =0x676B52F3
+	str r1, [r0, #0x00C]
+	ldr r1, =0xB66D0B63
+	str r1, [r0, #0x010]
+	ldr r1, =0x01FF00DB
+	str r1, [r0, #0x014]
+	ldr r1, =0x00201740
+	str r1, [r0, #0x018]
+	ldr r1, =0x00008000
+	str r1, [r0, #0x01C]
+	ldr r1, =0x000026D2
+	str r1, [r0, #0x02C]
+	ldr r1, =0x006B1023
+	str r1, [r0, #0x030]
+	ldr r1, =0x0000005F
+	str r1, [r0, #0x040]
+	ldr r1, =0x85180000
+	str r1, [r0, #0x000]
+	ldr r1, =0x00400000
+	str r1, [r0, #0x890]
+	ldr r1, =0x02008032
+	str r1, [r0, #0x01C]
+	ldr r1, =0x00008033
+	str r1, [r0, #0x01C]
+	ldr r1, =0x00048031
+	str r1, [r0, #0x01C]
+	ldr r1, =0x15208030
+	str r1, [r0, #0x01C]
+	ldr r1, =0x04008040
+	str r1, [r0, #0x01C]
+	ldr r1, =0x00000800
+	str r1, [r0, #0x020]
+	ldr r1, =0x00000227
+	str r1, [r0, #0x818]
+	ldr r1, =0x0002552D
+	str r1, [r0, #0x004]
+	ldr r1, =0x00011006
+	str r1, [r0, #0x404]
+	ldr r1, =0x00000000
+	str r1, [r0, #0x01C]
+.endm
+
+.macro imx6_clock_gating
+	ldr r0, =CCM_BASE_ADDR
+	ldr r1, =0xFFFFFFFF
+	str r1, [r0, #0x68]
+	str r1, [r0, #0x6C]
+	str r1, [r0, #0x70]
+	str r1, [r0, #0x74]
+	str r1, [r0, #0x78]
+	str r1, [r0, #0x7C]
+	str r1, [r0, #0x80]
+.endm
+
+.macro imx6_qos_setting
+.endm
+
+.macro imx6_ddr_setting
+	imx6ull_ddr3_arm2_setting
+.endm
+
+/* include the common plugin code here */
+#include <asm/arch/mx6_plugin.S>
diff --git a/board/freescale/mx7dsabresd/mx7dsabresd.c b/board/freescale/mx7dsabresd/mx7dsabresd.c
index d80610c..f9e8e17 100644
--- a/board/freescale/mx7dsabresd/mx7dsabresd.c
+++ b/board/freescale/mx7dsabresd/mx7dsabresd.c
@@ -1187,8 +1187,9 @@ int check_recovery_cmd_file(void)
 	int button_pressed = 0;
 	int recovery_mode = 0;
 
-	recovery_mode = recovery_check_and_clean_flag();
-
+#ifdef CONFIG_BCB_SUPPORT
+	recovery_mode = recovery_check_and_clean_command();
+#endif
 	/* Check Recovery Combo Button press or not. */
 	imx_iomux_v3_setup_multiple_pads(recovery_key_pads,
 		ARRAY_SIZE(recovery_key_pads));
diff --git a/common/Makefile b/common/Makefile
index 33945b7..02693a4 100644
--- a/common/Makefile
+++ b/common/Makefile
@@ -59,6 +59,7 @@ obj-$(CONFIG_ENV_IS_IN_UBI) += env_ubi.o
 obj-$(CONFIG_ENV_IS_NOWHERE) += env_nowhere.o
 
 # command
+obj-$(CONFIG_CMD_FSL_CAAM_KB) += cmd_fsl_caam.o
 obj-$(CONFIG_CMD_AES) += cmd_aes.o
 obj-$(CONFIG_CMD_AMBAPP) += cmd_ambapp.o
 obj-$(CONFIG_CMD_ARMFLASH) += cmd_armflash.o
diff --git a/common/autoboot.c b/common/autoboot.c
index 1c08c08..d8a126f 100644
--- a/common/autoboot.c
+++ b/common/autoboot.c
@@ -250,7 +250,7 @@ const char *bootdelay_process(void)
 	s = getenv("bootdelay");
 	bootdelay = s ? (int)simple_strtol(s, NULL, 10) : CONFIG_BOOTDELAY;
 
-#ifdef is_boot_from_usb
+#if !defined(CONFIG_FSL_FASTBOOT) && defined(is_boot_from_usb)
 	if (is_boot_from_usb()) {
 		disconnect_from_pc();
 		printf("Boot from USB for mfgtools\n");
@@ -288,7 +288,7 @@ const char *bootdelay_process(void)
 #endif /* CONFIG_BOOTCOUNT_LIMIT */
 		s = getenv("bootcmd");
 
-#ifdef is_boot_from_usb
+#if !defined(CONFIG_FSL_FASTBOOT) && defined(is_boot_from_usb)
 	if (is_boot_from_usb()) {
 		s = getenv("bootcmd_mfg");
 		printf("Run bootcmd_mfg: %s\n", s);
diff --git a/common/cmd_fsl_caam.c b/common/cmd_fsl_caam.c
new file mode 100644
index 0000000..1cd7af7
--- /dev/null
+++ b/common/cmd_fsl_caam.c
@@ -0,0 +1,108 @@
+/*
+ * Copyright (C) 2012-2016 Freescale Semiconductor, Inc.
+ *
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+
+#include <common.h>
+#include <command.h>
+#include <fsl_caam.h>
+
+static int do_caam(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
+{
+
+	int ret, i;
+
+	if (argc < 2)
+	return CMD_RET_USAGE;
+
+	if (strcmp(argv[1], "genblob") == 0) {
+
+	if (argc != 5)
+	    return CMD_RET_USAGE;
+
+	void *data_addr;
+	void *blob_addr;
+	int size;
+
+	data_addr = (void *)simple_strtoul(argv[2], NULL, 16);
+	blob_addr = (void *)simple_strtoul(argv[3], NULL, 16);
+	size      = (void *)simple_strtoul(argv[4], NULL, 10);
+	if (size <= 48)
+		return CMD_RET_USAGE;
+
+	caam_open();
+	ret = caam_gen_blob((uint32_t)data_addr, (uint32_t)blob_addr, (uint32_t)size);
+
+	if(ret != SUCCESS){
+		printf("Error during blob decap operation: 0x%d\n",ret);
+		return 0;
+	}
+
+	/* Print the generated DEK blob */
+	printf("DEK blob is available at 0x%08X and equals:\n",(unsigned int)blob_addr);
+	for(i=0;i<size;i++)
+		printf("%02X ",((uint8_t *)blob_addr)[i]);
+	printf("\n\n");
+
+
+	return 1;
+
+	}
+
+	else if (strcmp(argv[1], "decap") == 0){
+
+	if (argc != 5)
+		return CMD_RET_USAGE;
+
+	void *blob_addr;
+	void *data_addr;
+	int size;
+
+	blob_addr = (void *)simple_strtoul(argv[2], NULL, 16);
+	data_addr = (void *)simple_strtoul(argv[3], NULL, 16);
+	size      = (void *)simple_strtoul(argv[4], NULL, 10);
+	if (size <= 48)
+		return CMD_RET_USAGE;
+
+	caam_open();
+	ret = caam_decap_blob((uint32_t)(data_addr), (uint32_t)(blob_addr), (uint32_t)size);
+	if(ret != SUCCESS)
+		printf("Error during blob decap operation: 0x%d\n",ret);
+	else {
+		printf("Success, blob decap at SM PAGE1 original data is:\n");
+		int i = 0;
+		for (i = 0; i < size; i++) {
+		printf("0x%x  ",*(unsigned char*)(data_addr+i));
+		if (i % 16 == 0)
+			printf("\n");
+		}
+		printf("\n");
+	}
+
+	return 1;
+	}
+
+	return CMD_RET_USAGE;
+}
+
+U_BOOT_CMD(
+	caam, 5, 1, do_caam,
+	"Freescale i.MX CAAM command",
+	"caam genblob data_addr blob_addr data_size\n \
+	caam decap blobaddr data_addr data_size\n \
+	\n "
+	);
diff --git a/common/cmd_read.c b/common/cmd_read.c
index f0fc9bf..e1d14a3 100644
--- a/common/cmd_read.c
+++ b/common/cmd_read.c
@@ -12,7 +12,7 @@
 #include <command.h>
 #include <part.h>
 
-int do_read(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
+int do_raw_read(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
 {
 	char *ep;
 	block_dev_desc_t *dev_desc = NULL;
@@ -75,7 +75,7 @@ int do_read(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
 }
 
 U_BOOT_CMD(
-	read,	6,	0,	do_read,
+	read,	6,	0,	do_raw_read,
 	"Load binary data from a partition",
 	"<interface> <dev[:part]> addr blk# cnt"
 );
diff --git a/common/image-android.c b/common/image-android.c
index 36c6b39..11f2a81 100644
--- a/common/image-android.c
+++ b/common/image-android.c
@@ -1,6 +1,8 @@
 /*
  * Copyright (c) 2011 Sebastian Andrzej Siewior <bigeasy@linutronix.de>
  *
+ * Copyright (C) 2016 Freescale Semiconductor, Inc.
+ *
  * SPDX-License-Identifier:	GPL-2.0+
  */
 
@@ -13,6 +15,18 @@
 
 static char andr_tmp_str[ANDR_BOOT_ARGS_SIZE + 1];
 
+#ifdef CONFIG_BRILLO_SUPPORT
+#include <linux/usb/ch9.h>
+#include <linux/usb/gadget.h>
+#include "../drivers/usb/gadget/bootctrl.h"
+#endif
+#ifdef CONFIG_RESET_CAUSE
+#include <asm/arch-imx/cpu.h>
+#include <recovery.h>
+#define POR_NUM1 0x1
+#define POR_NUM2 0x11
+#define ANDROID_NORMAL_BOOT     6
+#endif
 /**
  * android_image_get_kernel() - processes kernel part of Android boot images
  * @hdr:	Pointer to image header, which is at the start
@@ -36,6 +50,9 @@ int android_image_get_kernel(const struct andr_img_hdr *hdr, int verify,
 	 * sha1 (or anything) so we don't check it. It is not obvious that the
 	 * string is null terminated so we take care of this.
 	 */
+#ifdef CONFIG_RESET_CAUSE
+	u32 reset_cause_sw,reset_cause_hw;
+#endif
 	strncpy(andr_tmp_str, hdr->name, ANDR_BOOT_NAME_SIZE);
 	andr_tmp_str[ANDR_BOOT_NAME_SIZE] = '\0';
 	if (strlen(andr_tmp_str))
@@ -83,6 +100,30 @@ int android_image_get_kernel(const struct andr_img_hdr *hdr, int verify,
 #endif
 					serialnr.high,
 					serialnr.low);
+	newbootargs = commandline;
+#endif
+#ifdef CONFIG_RESET_CAUSE
+	reset_cause_sw = read_boot_reason();
+	clear_boot_reason();
+	reset_cause_hw = get_imx_reset_cause();
+	if (ANDROID_NORMAL_BOOT == reset_cause_sw)
+		sprintf(commandline,
+				"%s androidboot.bootreason=Reboot",
+				newbootargs);
+	else if (POR_NUM1==reset_cause_hw || POR_NUM2 == reset_cause_hw)
+		sprintf(commandline,
+				"%s androidboot.bootreason=normal",
+				newbootargs);
+	else
+		sprintf(commandline,
+				"%s androidboot.bootreason=unknown",
+				newbootargs);
+#endif
+
+#ifdef CONFIG_BRILLO_SUPPORT
+	char suffixStr[64];
+	sprintf(suffixStr, " androidboot.slot_suffix=%s", get_slot_suffix());
+	strcat(commandline, suffixStr);
 #endif
 	setenv("bootargs", commandline);
 	if (os_data) {
diff --git a/common/image-android.c.orig b/common/image-android.c.orig
new file mode 100644
index 0000000..36c6b39
--- /dev/null
+++ b/common/image-android.c.orig
@@ -0,0 +1,157 @@
+/*
+ * Copyright (c) 2011 Sebastian Andrzej Siewior <bigeasy@linutronix.de>
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <common.h>
+#include <image.h>
+#include <android_image.h>
+#include <malloc.h>
+#include <errno.h>
+#include <asm/bootm.h>
+
+static char andr_tmp_str[ANDR_BOOT_ARGS_SIZE + 1];
+
+/**
+ * android_image_get_kernel() - processes kernel part of Android boot images
+ * @hdr:	Pointer to image header, which is at the start
+ *			of the image.
+ * @verify:	Checksum verification flag. Currently unimplemented.
+ * @os_data:	Pointer to a ulong variable, will hold os data start
+ *			address.
+ * @os_len:	Pointer to a ulong variable, will hold os data length.
+ *
+ * This function returns the os image's start address and length. Also,
+ * it appends the kernel command line to the bootargs env variable.
+ *
+ * Return: Zero, os start address and length on success,
+ *		otherwise on failure.
+ */
+int android_image_get_kernel(const struct andr_img_hdr *hdr, int verify,
+			     ulong *os_data, ulong *os_len)
+{
+	/*
+	 * Not all Android tools use the id field for signing the image with
+	 * sha1 (or anything) so we don't check it. It is not obvious that the
+	 * string is null terminated so we take care of this.
+	 */
+	strncpy(andr_tmp_str, hdr->name, ANDR_BOOT_NAME_SIZE);
+	andr_tmp_str[ANDR_BOOT_NAME_SIZE] = '\0';
+	if (strlen(andr_tmp_str))
+		printf("Android's image name: %s\n", andr_tmp_str);
+
+	printf("Kernel load addr 0x%08x size %u KiB\n",
+	       hdr->kernel_addr, DIV_ROUND_UP(hdr->kernel_size, 1024));
+
+	int len = 0;
+	if (*hdr->cmdline) {
+		len += strlen(hdr->cmdline);
+	}
+	char *bootargs = getenv("bootargs");
+	if (bootargs)
+		len += strlen(bootargs);
+
+	char *newbootargs = malloc(len + 2);
+	if (!newbootargs) {
+		puts("Error: malloc in android_image_get_kernel failed!\n");
+		return -ENOMEM;
+	}
+	*newbootargs = '\0';
+
+	if (bootargs) {
+		strcpy(newbootargs, bootargs);
+	} else if (*hdr->cmdline) {
+		strcat(newbootargs, hdr->cmdline);
+	}
+
+	printf("Kernel command line: %s\n", newbootargs);
+#ifdef CONFIG_SERIAL_TAG
+	struct tag_serialnr serialnr;
+	char commandline[ANDR_BOOT_ARGS_SIZE];
+	get_board_serial(&serialnr);
+#ifdef CONFIG_ANDROID_SUPPORT
+	char *adv_cmd_line = getenv("bootargs_adv");
+#endif
+	sprintf(commandline,
+#ifdef CONFIG_ANDROID_SUPPORT
+					"%s %s androidboot.serialno=%08x%08x",
+					newbootargs,adv_cmd_line,
+#else
+                                        "%s androidboot.serialno=%08x%08x",
+                                        newbootargs,
+#endif
+					serialnr.high,
+					serialnr.low);
+#endif
+	setenv("bootargs", commandline);
+	if (os_data) {
+		*os_data = (ulong)hdr;
+		*os_data += hdr->page_size;
+	}
+	if (os_len)
+		*os_len = hdr->kernel_size;
+	return 0;
+}
+
+int android_image_check_header(const struct andr_img_hdr *hdr)
+{
+	return memcmp(ANDR_BOOT_MAGIC, hdr->magic, ANDR_BOOT_MAGIC_SIZE);
+}
+
+ulong android_image_get_end(const struct andr_img_hdr *hdr)
+{
+	ulong end;
+	/*
+	 * The header takes a full page, the remaining components are aligned
+	 * on page boundary
+	 */
+	end = (ulong)hdr;
+	end += hdr->page_size;
+	end += ALIGN(hdr->kernel_size, hdr->page_size);
+	end += ALIGN(hdr->ramdisk_size, hdr->page_size);
+	end += ALIGN(hdr->second_size, hdr->page_size);
+
+	return end;
+}
+
+ulong android_image_get_kload(const struct andr_img_hdr *hdr)
+{
+	return hdr->kernel_addr;
+}
+
+int android_image_get_ramdisk(const struct andr_img_hdr *hdr,
+			      ulong *rd_data, ulong *rd_len)
+{
+	if (!hdr->ramdisk_size)
+		return -1;
+
+	printf("RAM disk load addr 0x%08x size %u KiB\n",
+	       hdr->ramdisk_addr, DIV_ROUND_UP(hdr->ramdisk_size, 1024));
+
+	*rd_data = (unsigned long)hdr;
+	*rd_data += hdr->page_size;
+	*rd_data += ALIGN(hdr->kernel_size, hdr->page_size);
+
+	*rd_len = hdr->ramdisk_size;
+	return 0;
+}
+
+int android_image_get_fdt(const struct andr_img_hdr *hdr,
+			      ulong *fdt_data, ulong *fdt_len)
+{
+	if (!hdr->second_size)
+		return -1;
+
+	printf("FDT load addr 0x%08x size %u KiB\n",
+	       hdr->second_addr, DIV_ROUND_UP(hdr->second_size, 1024));
+
+	*fdt_data = (unsigned long)hdr;
+	*fdt_data += hdr->page_size;
+	*fdt_data += ALIGN(hdr->kernel_size, hdr->page_size);
+	*fdt_data += ALIGN(hdr->ramdisk_size, hdr->page_size);
+
+	*fdt_len = hdr->second_size;
+	return 0;
+}
+
diff --git a/common/usb_storage.c b/common/usb_storage.c
index ad08dea..1411737 100644
--- a/common/usb_storage.c
+++ b/common/usb_storage.c
@@ -16,8 +16,6 @@
  * BBB support based on /sys/dev/usb/umass.c from
  * FreeBSD.
  *
- * Copyright (C) 2016 Freescale Semiconductor, Inc.
- *
  * SPDX-License-Identifier:	GPL-2.0+
  */
 
@@ -140,7 +138,7 @@ struct us_data {
  * enough free heap space left, but the SCSI READ(10) and WRITE(10) commands are
  * limited to 65535 blocks.
  */
-#define USB_MAX_XFER_BLK	256
+#define USB_MAX_XFER_BLK	65535
 #else
 #define USB_MAX_XFER_BLK	20
 #endif
diff --git a/configs/mx6qarm2_pop_lpddr2_revb_defconfig b/configs/mx6qarm2_pop_lpddr2_revb_defconfig
index 0f6e0c4..b50a9d2 100644
--- a/configs/mx6qarm2_pop_lpddr2_revb_defconfig
+++ b/configs/mx6qarm2_pop_lpddr2_revb_defconfig
@@ -1,4 +1,4 @@
-CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=board/freescale/mx6qarm2/mt128x64mx32.cfg,MX6Q,MX6DQ_POP_LPDDR2,DDR_MB=1024"
+CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=board/freescale/mx6qarm2/mt128x64mx32.cfg,MX6Q,MX6DQ_POP_LPDDR2,DDR_MB=512"
 CONFIG_ARM=y
 CONFIG_TARGET_MX6QARM2=y
 CONFIG_SYS_MALLOC_F=y
diff --git a/configs/mx6ul_14x14_evk_android_defconfig b/configs/mx6ul_14x14_evk_android_defconfig
deleted file mode 100644
index 53f39d5..0000000
--- a/configs/mx6ul_14x14_evk_android_defconfig
+++ /dev/null
@@ -1,5 +0,0 @@
-CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=board/freescale/mx6ul_14x14_evk/imximage.cfg,MX6UL,ANDROID_SUPPORT"
-CONFIG_ARM=y
-CONFIG_TARGET_MX6UL_14X14_EVK=y
-CONFIG_DM=y
-CONFIG_DM_THERMAL=y
diff --git a/configs/mx6ul_14x14_evk_brillo_defconfig b/configs/mx6ul_14x14_evk_brillo_defconfig
new file mode 100644
index 0000000..6b88ee4
--- /dev/null
+++ b/configs/mx6ul_14x14_evk_brillo_defconfig
@@ -0,0 +1,5 @@
+CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=board/freescale/mx6ul_14x14_evk/imximage.cfg,MX6UL,ANDROID_SUPPORT,BRILLO_SUPPORT"
+CONFIG_ARM=y
+CONFIG_TARGET_MX6UL_14X14_EVK=y
+CONFIG_DM=y
+CONFIG_DM_THERMAL=y
diff --git a/configs/mx6ul_14x14_evk_ddr_eol_android_defconfig b/configs/mx6ul_14x14_evk_ddr_eol_android_defconfig
deleted file mode 100644
index 8654c04..0000000
--- a/configs/mx6ul_14x14_evk_ddr_eol_android_defconfig
+++ /dev/null
@@ -1,5 +0,0 @@
-CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=board/freescale/mx6ul_14x14_evk/imximage.cfg,MX6UL,ANDROID_SUPPORT,DDR3L_MT41K256M16HA"
-CONFIG_ARM=y
-CONFIG_TARGET_MX6UL_14X14_EVK=y
-CONFIG_DM=y
-CONFIG_DM_THERMAL=y
diff --git a/configs/mx6ul_14x14_evk_nand_defconfig b/configs/mx6ul_14x14_evk_nand_defconfig
new file mode 100644
index 0000000..4d39a23
--- /dev/null
+++ b/configs/mx6ul_14x14_evk_nand_defconfig
@@ -0,0 +1,5 @@
+CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=board/freescale/mx6ul_14x14_evk/imximage.cfg,MX6UL,SYS_BOOT_NAND"
+CONFIG_ARM=y
+CONFIG_TARGET_MX6UL_14X14_EVK=y
+CONFIG_DM=y
+CONFIG_DM_THERMAL=y
diff --git a/configs/mx6ull_ddr3_arm2_defconfig b/configs/mx6ull_ddr3_arm2_defconfig
new file mode 100644
index 0000000..906b9b0
--- /dev/null
+++ b/configs/mx6ull_ddr3_arm2_defconfig
@@ -0,0 +1,9 @@
+CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=board/freescale/mx6ull_ddr3_arm2/imximage.cfg"
+CONFIG_ARM=y
+CONFIG_ARCH_MX6=y
+CONFIG_MX6ULL=y
+CONFIG_TARGET_MX6ULL_DDR3_ARM2=y
+CONFIG_SYS_MALLOC_F=y
+CONFIG_SYS_MALLOC_F_LEN=0x400
+CONFIG_DM=y
+CONFIG_DM_THERMAL=y
diff --git a/configs/mx6ull_ddr3_arm2_emmc_defconfig b/configs/mx6ull_ddr3_arm2_emmc_defconfig
new file mode 100644
index 0000000..7912331
--- /dev/null
+++ b/configs/mx6ull_ddr3_arm2_emmc_defconfig
@@ -0,0 +1,9 @@
+CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=board/freescale/mx6ull_ddr3_arm2/imximage.cfg,MX6ULL_DDR3_ARM2_EMMC_REWORK"
+CONFIG_ARM=y
+CONFIG_ARCH_MX6=y
+CONFIG_MX6ULL=y
+CONFIG_TARGET_MX6ULL_DDR3_ARM2=y
+CONFIG_SYS_MALLOC_F=y
+CONFIG_SYS_MALLOC_F_LEN=0x400
+CONFIG_DM=y
+CONFIG_DM_THERMAL=y
diff --git a/configs/mx6ull_ddr3_arm2_nand_defconfig b/configs/mx6ull_ddr3_arm2_nand_defconfig
new file mode 100644
index 0000000..de28c76
--- /dev/null
+++ b/configs/mx6ull_ddr3_arm2_nand_defconfig
@@ -0,0 +1,9 @@
+CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=board/freescale/mx6ull_ddr3_arm2/imximage.cfg,SYS_BOOT_NAND"
+CONFIG_ARM=y
+CONFIG_ARCH_MX6=y
+CONFIG_MX6ULL=y
+CONFIG_TARGET_MX6ULL_DDR3_ARM2=y
+CONFIG_SYS_MALLOC_F=y
+CONFIG_SYS_MALLOC_F_LEN=0x400
+CONFIG_DM=y
+CONFIG_DM_THERMAL=y
diff --git a/configs/mx6ull_ddr3_arm2_qspi1_defconfig b/configs/mx6ull_ddr3_arm2_qspi1_defconfig
new file mode 100644
index 0000000..c940ca9
--- /dev/null
+++ b/configs/mx6ull_ddr3_arm2_qspi1_defconfig
@@ -0,0 +1,9 @@
+CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=board/freescale/mx6ull_ddr3_arm2/imximage.cfg,SYS_BOOT_QSPI"
+CONFIG_ARM=y
+CONFIG_ARCH_MX6=y
+CONFIG_MX6ULL=y
+CONFIG_TARGET_MX6ULL_DDR3_ARM2=y
+CONFIG_SYS_MALLOC_F=y
+CONFIG_SYS_MALLOC_F_LEN=0x400
+CONFIG_DM=y
+CONFIG_DM_THERMAL=y
diff --git a/configs/mx6ull_ddr3_arm2_spinor_defconfig b/configs/mx6ull_ddr3_arm2_spinor_defconfig
new file mode 100644
index 0000000..cbaa353
--- /dev/null
+++ b/configs/mx6ull_ddr3_arm2_spinor_defconfig
@@ -0,0 +1,9 @@
+CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=board/freescale/mx6ull_ddr3_arm2/imximage.cfg,SYS_BOOT_SPINOR"
+CONFIG_ARM=y
+CONFIG_ARCH_MX6=y
+CONFIG_MX6ULL=y
+CONFIG_TARGET_MX6ULL_DDR3_ARM2=y
+CONFIG_SYS_MALLOC_F=y
+CONFIG_SYS_MALLOC_F_LEN=0x400
+CONFIG_DM=y
+CONFIG_DM_THERMAL=y
diff --git a/drivers/crypto/Makefile b/drivers/crypto/Makefile
index fb8c10b..062efdc 100644
--- a/drivers/crypto/Makefile
+++ b/drivers/crypto/Makefile
@@ -6,5 +6,6 @@
 #
 
 obj-$(CONFIG_EXYNOS_ACE_SHA)	+= ace_sha.o
+obj-$(CONFIG_FSL_CAAM_KB)	+= fsl_caam.o
 obj-y += rsa_mod_exp/
 obj-y += fsl/
diff --git a/drivers/crypto/fsl_caam.c b/drivers/crypto/fsl_caam.c
new file mode 100644
index 0000000..fa041cf
--- /dev/null
+++ b/drivers/crypto/fsl_caam.c
@@ -0,0 +1,459 @@
+/*
+ * Copyright (c) 2012-2016, Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * o Redistributions of source code must retain the above copyright notice, this list
+ *   of conditions and the following disclaimer.
+ *
+ * o Redistributions in binary form must reproduce the above copyright notice, this
+ *   list of conditions and the following disclaimer in the documentation and/or
+ *   other materials provided with the distribution.
+ *
+ * o Neither the name of Freescale Semiconductor, Inc. nor the names of its
+ *   contributors may be used to endorse or promote products derived from this
+ *   software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
+ * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include <common.h>
+#include <asm/io.h>
+#include <asm/arch/crm_regs.h>
+#include "fsl_caam_internal.h"
+#include <fsl_caam.h>
+
+/*---------- Global variables ----------*/
+/* Input job ring - single entry input ring */
+uint32_t g_input_ring[JOB_RING_ENTRIES] = {0};
+
+/* Output job ring - single entry output ring (consists of two words) */    
+uint32_t g_output_ring[2*JOB_RING_ENTRIES] = {0, 0};
+
+uint32_t decap_dsc[] = 
+{
+	DECAP_BLOB_DESC1,
+	DECAP_BLOB_DESC2,
+	DECAP_BLOB_DESC3,
+	DECAP_BLOB_DESC4,
+	DECAP_BLOB_DESC5,
+	DECAP_BLOB_DESC6,
+	DECAP_BLOB_DESC7,
+	DECAP_BLOB_DESC8,
+	DECAP_BLOB_DESC9
+};
+
+uint32_t encap_dsc[] = 
+{
+	ENCAP_BLOB_DESC1,
+	ENCAP_BLOB_DESC2,
+	ENCAP_BLOB_DESC3,
+	ENCAP_BLOB_DESC4,
+	ENCAP_BLOB_DESC5,
+	ENCAP_BLOB_DESC6,
+	ENCAP_BLOB_DESC7,
+	ENCAP_BLOB_DESC8,
+	ENCAP_BLOB_DESC9
+};
+
+uint32_t rng_inst_dsc[] = 
+{
+	RNG_INST_DESC1,
+	RNG_INST_DESC2,
+	RNG_INST_DESC3,
+	RNG_INST_DESC4,
+	RNG_INST_DESC5,
+	RNG_INST_DESC6,
+	RNG_INST_DESC7,
+	RNG_INST_DESC8,
+	RNG_INST_DESC9
+};
+
+static uint8_t skeymod[] = {
+	0x0f, 0x0e, 0x0d, 0x0c, 0x0b, 0x0a, 0x09, 0x08,
+	0x07, 0x06, 0x05, 0x04, 0x03, 0x02, 0x01, 0x00
+};
+
+/*!
+ * Secure memory run command.
+ *
+ * @param   sec_mem_cmd  Secure memory command register
+ * @return  cmd_status  Secure memory command status register
+ */
+uint32_t secmem_set_cmd_1(uint32_t sec_mem_cmd)
+{
+	uint32_t temp_reg;
+	__raw_writel(sec_mem_cmd, CAAM_SMCJR0);
+	do {
+	temp_reg = __raw_readl(CAAM_SMCSJR0);
+	} while(temp_reg & CMD_COMPLETE);
+
+	return temp_reg;
+}
+
+/*!
+ * CAAM page allocation.
+ *
+ * @param   page  Number of the page to allocate.
+ * @param   partition  Number of the partition to allocate.
+ */
+static uint32_t caam_page_alloc(uint8_t page_num, uint8_t partition_num)
+{
+	uint32_t temp_reg;
+
+	/* 
+	 * De-Allocate partition_num if already allocated to ARM core
+	 */
+	if(__raw_readl(CAAM_SMPO_0) & PARTITION_OWNER(partition_num))
+	{
+		temp_reg = secmem_set_cmd_1(PARTITION(partition_num) | CMD_PART_DEALLOC);
+		if(temp_reg & SMCSJR_AERR)
+		{
+		printf("Error: De-allocation status 0x%X\n",temp_reg);
+		return ERROR_IN_PAGE_ALLOC;
+		}
+	}
+
+	/* set the access rights to allow full access */ 
+	__raw_writel(0xF, CAAM_SMAG1JR0(partition_num));
+	__raw_writel(0xF, CAAM_SMAG2JR0(partition_num));
+	__raw_writel(0xFF, CAAM_SMAPJR0(partition_num));
+
+	/* Now need to allocate partition_num of secure RAM. */    
+	/* De-Allocate page_num by starting with a page inquiry command */
+	temp_reg = secmem_set_cmd_1(PAGE(page_num) | CMD_INQUIRY);
+	/* if the page is owned, de-allocate it */
+	if((temp_reg & SMCSJR_PO) == PAGE_OWNED)
+	{
+		temp_reg = secmem_set_cmd_1(PAGE(page_num) | CMD_PAGE_DEALLOC);
+		if(temp_reg & SMCSJR_AERR)
+	{
+	  printf("Error: Allocation status 0x%X\n",temp_reg);
+	  return ERROR_IN_PAGE_ALLOC;
+		}
+	}
+
+	/* Allocate page_num to partition_num */
+	temp_reg = secmem_set_cmd_1(PAGE(page_num) | PARTITION(partition_num)
+		| CMD_PAGE_ALLOC);
+	if(temp_reg & SMCSJR_AERR)
+	{
+		printf("Error: Allocation status 0x%X\n",temp_reg);
+		return ERROR_IN_PAGE_ALLOC;
+	}
+	/* page inquiry command to ensure that the page was allocated */
+	temp_reg = secmem_set_cmd_1(PAGE(page_num) | CMD_INQUIRY);
+	/* if the page is not owned => problem */
+	if((temp_reg & SMCSJR_PO) != PAGE_OWNED)
+	{
+		printf("Error: Allocation of page %d in partition %d failed 0x%X\n"
+		,temp_reg, page_num, partition_num);
+
+		return ERROR_IN_PAGE_ALLOC;
+	}
+
+	return SUCCESS;
+}
+
+/*!
+ * Use CAAM to decapsulate a blob to secure memory.
+ * Such blob of secret key cannot be read once decrypted,
+ * but can still be used for enc/dec operation of user's data.
+ *
+ * @param   blob_addr  Location address of the blob.
+ *
+ * @return  SUCCESS or ERROR_XXX
+ */
+uint32_t caam_decap_blob(uint32_t plain_text, uint32_t blob_addr, uint32_t size)
+{
+	uint32_t ret = SUCCESS;
+
+	/* Buffer that holds blob */
+	uint8_t *blob = (uint8_t *)blob_addr;
+
+	/**** Prepare partition and page, and start the job to create the blob ***/
+#if 0
+    ret = caam_page_alloc(PAGE_1, PARTITION_1);
+    if(ret != SUCCESS)
+        return ret;
+
+    /* Now configure the access rights of the partition */
+    __raw_writel(KS_G1, CAAM_SMAG1JR0(PARTITION_1)); // set group 1
+    __raw_writel(0, CAAM_SMAG2JR0(PARTITION_1));     // clear group 2
+	__raw_writel(PERM, CAAM_SMAPJR0(PARTITION_1));   // set permissions & locks
+#endif
+
+	/* TODO: Fix Hardcoded Descriptor */
+	decap_dsc[0] = (uint32_t)0xB0800008;
+	decap_dsc[1] = (uint32_t)0x14400010;
+	decap_dsc[2] = (uint32_t)skeymod;
+	decap_dsc[3] = (uint32_t)0xF0000000 | (0x0000ffff & (size+48) );
+	decap_dsc[4] = blob_addr;
+	decap_dsc[5] = (uint32_t)0xF8000000 | (0x0000ffff & (size));
+	decap_dsc[6] = (uint32_t)(uint8_t*)plain_text;
+	decap_dsc[7] = (uint32_t)0x860D0000;
+
+// uncomment when using descriptor from "fsl_caam_internal.h"
+// does not use key modifier.
+#if 0  
+    /* Fill in input blob addr in decap_dsc */
+    decap_dsc[5] = (uint32_t)blob;
+    /* Fill in the address where to decrypt the blob */
+    decap_dsc[7] = (uint32_t)SEC_MEM_PAGE1;
+#endif
+
+    /* Run descriptor with result written to blob buffer */
+    /* Add job to input ring */
+	g_input_ring[0] = (uint32_t)decap_dsc;
+
+	flush_dcache_range((uint32_t)blob_addr & 0xffffffe0, ((uint32_t)blob_addr & 0xffffffe0) + 2*size);
+	flush_dcache_range((uint32_t)plain_text& 0xffffffe0, ((uint32_t)plain_text& 0xffffffe0) + 2*size);
+	flush_dcache_range((uint32_t)decap_dsc & 0xffffffe0, ((uint32_t)decap_dsc & 0xffffffe0) + 128); 
+	flush_dcache_range((uint32_t)g_input_ring & 0xffffffe0, ((uint32_t)g_input_ring & 0xffffffe0) + 128);
+    /* Increment jobs added */
+	__raw_writel(1, CAAM_IRJAR0);
+
+    /* Wait for job ring to complete the job: 1 completed job expected */
+	while(__raw_readl(CAAM_ORSFR0) != 1);
+
+	// TODO: check if Secure memory is cacheable.
+	invalidate_dcache_range((uint32_t)g_output_ring & 0xffffffe0, ((uint32_t)g_output_ring & 0xffffffe0) + 128);
+	/* check that descriptor address is the one expected in the output ring */
+	if(g_output_ring[0] == (uint32_t)decap_dsc)
+	{
+		/* check if any error is reported in the output ring */
+		if ((g_output_ring[1] & JOB_RING_STS) != 0)
+		{
+			printf("Error: blob decap job completed with errors 0x%X\n",
+						g_output_ring[1]);
+		}
+	}
+	else
+	{
+		printf("Error: blob decap job output ring descriptor address does" \
+	                " not match\n");
+	}
+	flush_dcache_range((uint32_t)plain_text& 0xffffffe0, ((uint32_t)plain_text& 0xffffffe0) + 2*size);
+
+
+	/* Remove job from Job Ring Output Queue */
+	__raw_writel(1, CAAM_ORJRR0);
+
+	return ret;
+}
+
+/*!
+ * Use CAAM to generate a blob.
+ *
+ * @param   plain_data_addr  Location address of the plain data.
+ * @param   blob_addr  Location address of the blob.
+ *
+ * @return  SUCCESS or ERROR_XXX
+ */
+uint32_t caam_gen_blob(uint32_t plain_data_addr, uint32_t blob_addr, uint32_t size)
+{
+	uint32_t ret = SUCCESS;
+	uint32_t addr;
+
+	/* Buffer to hold the resulting blob */
+	uint8_t *blob = (uint8_t *)blob_addr;
+
+	/* initialize the blob array */
+	memset(blob,0,size);
+
+    /**** Prepare partition and page, and start the job to create the blob ***/
+#if 0
+    ret = caam_page_alloc(PAGE_1, PARTITION_1);
+    if(ret != SUCCESS)
+	return ret;
+
+    /* Write the DEK to the partition. */
+    memcpy((uint32_t*)SEC_MEM_PAGE1, (uint32_t*)plain_data_addr, size);
+
+    /* Now configure the access rights of the partition */
+    //  __raw_writel(KS_G1, CAAM_SMAG1JR0(PARTITION_1)); // set group 1
+    //  __raw_writel(0, CAAM_SMAG2JR0(PARTITION_1));     // clear group 2
+    //   __raw_writel(PERM, CAAM_SMAPJR0(PARTITION_1));   // set permissions & locks
+#endif
+
+    /* TODO: Fix Hardcoded Descriptor */
+	encap_dsc[0] = (uint32_t)0xB0800008;
+	encap_dsc[1] = (uint32_t)0x14400010;
+	encap_dsc[2] = (uint32_t)skeymod;
+	encap_dsc[3] = (uint32_t)0xF0000000 | (0x0000ffff & (size));
+	encap_dsc[4] = (uint32_t)plain_data_addr;
+	encap_dsc[5] = (uint32_t)0xF8000000 | (0x0000ffff & (size+48));
+	encap_dsc[6] = (uint32_t)blob;	
+	encap_dsc[7] = (uint32_t)0x870D0000;
+
+    // uncomment when using descriptor from "fsl_caam_internal.h"
+    // does not use key modifier.	
+#if 0
+    //
+    /* Fill in the address where the DEK resides */
+    encap_dsc[5] = (uint32_t)SEC_MEM_PAGE1;    
+    /* Fill in output blob addr in encap_dsc */
+    encap_dsc[7] = (uint32_t)blob;
+#endif
+
+    /* Run descriptor with result written to blob buffer */
+    /* Add job to input ring */
+	g_input_ring[0] = (uint32_t)encap_dsc;
+
+	flush_dcache_range((uint32_t)plain_data_addr& 0xffffffe0, ((uint32_t)plain_data_addr& 0xffffffe0) + size);
+	flush_dcache_range((uint32_t)encap_dsc & 0xffffffe0, ((uint32_t)encap_dsc & 0xffffffe0) + 128);
+	flush_dcache_range((uint32_t)blob & 0xffffffe0, ((uint32_t)g_input_ring & 0xffffffe0) + 2 * size);
+	/* Increment jobs added */
+	__raw_writel(1, CAAM_IRJAR0);
+
+    /* Wait for job ring to complete the job: 1 completed job expected */
+	while(__raw_readl(CAAM_ORSFR0) != 1);
+
+    // flush cache
+	invalidate_dcache_range((uint32_t)g_output_ring & 0xffffffe0, ((uint32_t)g_output_ring & 0xffffffe0) + 128);
+	invalidate_dcache_range((uint32_t)g_output_ring & 0xffffffe0, ((uint32_t)g_output_ring & 0xffffffe0) + 128);
+	/* check that descriptor address is the one expected in the output ring */
+	if(g_output_ring[0] == (uint32_t)encap_dsc)
+	{
+	/* check if any error is reported in the output ring */
+		if ((g_output_ring[1] & JOB_RING_STS) != 0)
+		{
+			printf("Error: blob encap job completed with errors 0x%X\n",
+			      g_output_ring[1]);
+		}
+	}
+	else
+	{
+	printf("Error: blob encap job output ring descriptor address does" \
+		" not match\n");
+	}
+
+	/* Remove job from Job Ring Output Queue */
+	__raw_writel(1, CAAM_ORJRR0);
+
+	return ret;
+}
+
+/*!
+ * Initialize the CAAM.
+ *
+ */
+void caam_open(void)
+{
+	struct mxc_ccm_reg *mxc_ccm = (struct mxc_ccm_reg *)CCM_BASE_ADDR;
+	uint32_t temp_reg;
+	//uint32_t addr;
+
+    /* switch on the clock */
+	temp_reg = __raw_readl(&mxc_ccm->CCGR0);
+	temp_reg |= MXC_CCM_CCGR0_CAAM_SECURE_MEM_MASK | 
+		MXC_CCM_CCGR0_CAAM_WRAPPER_ACLK_MASK | 
+		MXC_CCM_CCGR0_CAAM_WRAPPER_IPG_MASK;
+	__raw_writel(temp_reg, &mxc_ccm->CCGR0);
+
+    /* MID for CAAM - already done by HAB in ROM during preconfigure,
+     * That is JROWN for JR0/1 = 1 (TZ, Secure World, ARM)
+     * JRNSMID and JRSMID for JR0/1 = 2 (TZ, Secure World, CAAM)
+     *
+     * However, still need to initialize Job Rings as these are torn
+     * down by HAB for each command
+     */    
+
+    /* Initialize job ring addresses */
+	__raw_writel((uint32_t)g_input_ring, CAAM_IRBAR0);   // input ring address
+	__raw_writel((uint32_t)g_output_ring, CAAM_ORBAR0);  // output ring address
+
+	/* Initialize job ring sizes to 1 */
+	__raw_writel(JOB_RING_ENTRIES, CAAM_IRSR0);
+	__raw_writel(JOB_RING_ENTRIES, CAAM_ORSR0);
+
+    /* HAB disables interrupts for JR0 so do the same here */
+	temp_reg = __raw_readl(CAAM_JRCFGR0_LS) | JRCFG_LS_IMSK;
+	__raw_writel(temp_reg, CAAM_JRCFGR0_LS);    
+
+    /********* Initialize and instantiate the RNG *******************/
+    /* if RNG already instantiated then skip it */
+	if ((__raw_readl(CAAM_RDSTA) & RDSTA_IF0) != RDSTA_IF0)
+	{
+	/* Enter TRNG Program mode */
+	__raw_writel(RTMCTL_PGM, CAAM_RTMCTL);
+
+	/* Set OSC_DIV field to TRNG */
+	temp_reg = __raw_readl(CAAM_RTMCTL) | (RNG_TRIM_OSC_DIV << 2);
+	__raw_writel(temp_reg, CAAM_RTMCTL);
+
+	/* Set delay */
+	__raw_writel(((RNG_TRIM_ENT_DLY << 16) | 0x09C4), CAAM_RTSDCTL);   
+	__raw_writel((RNG_TRIM_ENT_DLY >> 1), CAAM_RTFRQMIN);
+	__raw_writel((RNG_TRIM_ENT_DLY << 4), CAAM_RTFRQMAX);
+
+	/* Resume TRNG Run mode */
+	temp_reg = __raw_readl(CAAM_RTMCTL) ^ RTMCTL_PGM;
+	__raw_writel(temp_reg, CAAM_RTMCTL);   
+
+	/* Clear the ERR bit in RTMCTL if set. The TRNG error can occur when the
+	 * RNG clock is not within 1/2x to 8x the system clock.
+	 * This error is possible if ROM code does not initialize the system PLLs
+	 * immediately after PoR.
+	 */
+	temp_reg = __raw_readl(CAAM_RTMCTL) | RTMCTL_ERR;
+	__raw_writel(temp_reg, CAAM_RTMCTL);
+
+	/* Run descriptor to instantiate the RNG */
+	/* Add job to input ring */
+	g_input_ring[0] = (uint32_t)rng_inst_dsc;
+
+	flush_dcache_range((uint32_t)g_input_ring & 0xffffffe0, ((uint32_t)g_input_ring & 0xffffffe0) + 128);
+	/* Increment jobs added */
+	__raw_writel(1, CAAM_IRJAR0); 
+
+	/* Wait for job ring to complete the job: 1 completed job expected */
+	while(__raw_readl(CAAM_ORSFR0) != 1);
+
+
+	invalidate_dcache_range((uint32_t)g_output_ring & 0xffffffe0, ((uint32_t)g_output_ring & 0xffffffe0) + 128);
+
+	/* check that descriptor address is the one expected in the out ring */
+	if(g_output_ring[0] == (uint32_t)rng_inst_dsc)
+	{
+		/* check if any error is reported in the output ring */
+		if ((g_output_ring[1] & JOB_RING_STS) != 0)
+		{
+		printf("Error: RNG instantiation errors g_output_ring[1]: 0x%X\n"
+			, g_output_ring[1]);
+		printf("RTMCTL 0x%X\n", __raw_readl(CAAM_RTMCTL));
+		printf("RTSTATUS 0x%X\n", __raw_readl(CAAM_RTSTATUS));
+		printf("RTSTA 0x%X\n", __raw_readl(CAAM_RDSTA));
+            }
+	}
+	else
+	{
+		printf("Error: RNG job output ring descriptor address does " \
+				"not match: 0x%X != 0x%X \n", g_output_ring[0], rng_inst_dsc[0]);
+	}
+
+		/* ensure that the RNG was correctly instantiated */
+		temp_reg = __raw_readl(CAAM_RDSTA);
+		if (temp_reg != (RDSTA_IF0 | RDSTA_SKVN))
+		{
+		
+			printf("Error: RNG instantiation failed 0x%X\n", temp_reg);
+		}
+		
+		/* Remove job from Job Ring Output Queue */
+		__raw_writel(1, CAAM_ORJRR0);
+	}
+		
+	return;
+}
diff --git a/drivers/crypto/fsl_caam_internal.h b/drivers/crypto/fsl_caam_internal.h
new file mode 100644
index 0000000..755cad8
--- /dev/null
+++ b/drivers/crypto/fsl_caam_internal.h
@@ -0,0 +1,401 @@
+/*
+ * Copyright (c) 2012-2016, Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * o Redistributions of source code must retain the above copyright notice, this list
+ *   of conditions and the following disclaimer.
+ *
+ * o Redistributions in binary form must reproduce the above copyright notice, this
+ *   list of conditions and the following disclaimer in the documentation and/or
+ *   other materials provided with the distribution.
+ *
+ * o Neither the name of Freescale Semiconductor, Inc. nor the names of its
+ *   contributors may be used to endorse or promote products derived from this
+ *   software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
+ * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef __CAAM_INTERNAL_H__
+#define	__CAAM_INTERNAL_H__
+
+/* 4kbyte pages */
+#define CAAM_SEC_RAM_START_ADDR CAAM_ARB_BASE_ADDR
+
+#define SEC_MEM_PAGE0       CAAM_SEC_RAM_START_ADDR
+#define SEC_MEM_PAGE1       (CAAM_SEC_RAM_START_ADDR + 0x1000)
+#define SEC_MEM_PAGE2       (CAAM_SEC_RAM_START_ADDR + 0x2000)
+#define SEC_MEM_PAGE3       (CAAM_SEC_RAM_START_ADDR + 0x3000)
+
+/* Configuration and special key registers */
+#define CAAM_MCFGR          CAAM_BASE_ADDR + 0x0004
+#define CAAM_SCFGR          CAAM_BASE_ADDR + 0x000c
+#define CAAM_JR0MIDR        CAAM_BASE_ADDR + 0x0010
+#define CAAM_JR1MIDR        CAAM_BASE_ADDR + 0x0018
+#define CAAM_DECORR         CAAM_BASE_ADDR + 0x009c
+#define CAAM_DECO0MID       CAAM_BASE_ADDR + 0x00a0
+#define CAAM_DAR            CAAM_BASE_ADDR + 0x0120
+#define CAAM_DRR            CAAM_BASE_ADDR + 0x0124
+#define CAAM_JDKEKR         CAAM_BASE_ADDR + 0x0400
+#define CAAM_TDKEKR         CAAM_BASE_ADDR + 0x0420
+#define CAAM_TDSKR          CAAM_BASE_ADDR + 0x0440
+#define CAAM_SKNR           CAAM_BASE_ADDR + 0x04e0
+#define CAAM_SMSTA          CAAM_BASE_ADDR + 0x0FB4
+#define CAAM_STA            CAAM_BASE_ADDR + 0x0FD4
+#define CAAM_SMPO_0         CAAM_BASE_ADDR + 0x1FBC
+
+/* RNG registers */
+#define CAAM_RTMCTL         CAAM_BASE_ADDR + 0x0600
+#define CAAM_RTSDCTL        CAAM_BASE_ADDR + 0x0610
+#define CAAM_RTFRQMIN       CAAM_BASE_ADDR + 0x0618
+#define CAAM_RTFRQMAX       CAAM_BASE_ADDR + 0x061C
+#define CAAM_RTSTATUS		CAAM_BASE_ADDR + 0x063C
+#define CAAM_RDSTA          CAAM_BASE_ADDR + 0x06C0
+
+/* Job Ring 0 registers */
+#define CAAM_IRBAR0         CAAM_BASE_ADDR + 0x1004
+#define CAAM_IRSR0          CAAM_BASE_ADDR + 0x100c
+#define CAAM_IRSAR0         CAAM_BASE_ADDR + 0x1014
+#define CAAM_IRJAR0         CAAM_BASE_ADDR + 0x101c
+#define CAAM_ORBAR0         CAAM_BASE_ADDR + 0x1024
+#define CAAM_ORSR0          CAAM_BASE_ADDR + 0x102c
+#define CAAM_ORJRR0         CAAM_BASE_ADDR + 0x1034
+#define CAAM_ORSFR0         CAAM_BASE_ADDR + 0x103c
+#define CAAM_JRSTAR0        CAAM_BASE_ADDR + 0x1044
+#define CAAM_JRINTR0        CAAM_BASE_ADDR + 0x104c
+#define CAAM_JRCFGR0_MS     CAAM_BASE_ADDR + 0x1050
+#define CAAM_JRCFGR0_LS     CAAM_BASE_ADDR + 0x1054
+#define CAAM_IRRIR0         CAAM_BASE_ADDR + 0x105c
+#define CAAM_ORWIR0         CAAM_BASE_ADDR + 0x1064
+#define CAAM_JRCR0          CAAM_BASE_ADDR + 0x106c
+#define CAAM_SMCJR0         CAAM_BASE_ADDR + 0x10f4
+#define CAAM_SMCSJR0        CAAM_BASE_ADDR + 0x10fc
+#define CAAM_SMAPJR0(y)     (CAAM_BASE_ADDR + 0x1104 + y*16)
+#define CAAM_SMAG2JR0(y)    (CAAM_BASE_ADDR + 0x1108 + y*16)
+#define CAAM_SMAG1JR0(y)    (CAAM_BASE_ADDR + 0x110C + y*16)
+#define CAAM_SMAPJR0_PRTN1  CAAM_BASE_ADDR + 0x1114
+#define CAAM_SMAG2JR0_PRTN1 CAAM_BASE_ADDR + 0x1118
+#define CAAM_SMAG1JR0_PRTN1 CAAM_BASE_ADDR + 0x111c
+#define CAAM_SMPO           CAAM_BASE_ADDR + 0x1fbc
+
+#define JRCFG_LS_IMSK       0x00000001      /* Interrupt Mask */
+#define JR_MID              2               /* Matches ROM configuration */
+#define KS_G1               (1 << JR_MID)   /* CAAM only */
+#define PERM                0x0000B008      /* Clear on release,
+                                             * lock SMAP
+                                             * lock SMAG
+                                             * group 1 Blob
+                                             */    
+
+#define CMD_PAGE_ALLOC      0x1
+#define CMD_PAGE_DEALLOC    0x2
+#define CMD_PART_DEALLOC    0x3
+#define CMD_INQUIRY         0x5
+#define PAGE(x)             (x << 16)
+#define PARTITION(x)        (x << 8)
+
+#define SMCSJR_AERR         (3 << 12)
+#define SMCSJR_CERR         (3 << 14)
+#define CMD_COMPLETE        (3 << 14)
+
+#define SMCSJR_PO           (3 << 6)
+#define PAGE_AVAILABLE      0
+#define PAGE_OWNED          (3 << 6)
+
+#define PARTITION_OWNER(x)  (0x3 << (x*2))
+
+#define CAAM_BUSY_MASK      0x00000001      /* BUSY from status reg */
+#define CAAM_IDLE_MASK      0x00000002      /* IDLE from status reg */
+
+#define JOB_RING_ENTRIES    1
+#define JOB_RING_STS        (0xF << 28)
+
+/** OSC_DIV in RNG trim fuses */
+#define RNG_TRIM_OSC_DIV    0
+/** ENT_DLY multiplier in RNG trim fuses */
+//#define RNG_TRIM_ENT_DLY    200*4
+#define RNG_TRIM_ENT_DLY    3200
+
+#define RTMCTL_PGM  (1 << 16)
+#define RTMCTL_ERR  (1 << 12)
+#define RDSTA_IF0   1
+#define RDSTA_SKVN  (1 << 30)
+
+typedef enum {
+    PAGE_0,
+    PAGE_1,
+    PAGE_2,
+    PAGE_3,
+} page_num_e;
+
+typedef enum {
+    PARTITION_0,
+    PARTITION_1,
+    PARTITION_2,
+    PARTITION_3,
+    PARTITION_4,
+    PARTITION_5,
+    PARTITION_6,
+    PARTITION_7,
+} partition_num_e;
+
+/*****************************************
+ *----- Blob decapsulate descriptor -----*
+ *****************************************/
+/* 1. Header
+ *
+ *  1011 0000 1000 0000 0000 0000 0000 1001
+ *  |||| |                             ||||
+ *  ++++-+-- Header                    ++++-- 9 words in descriptor
+ */  
+#define DECAP_BLOB_DESC1 0xB0800009
+
+/* 2. Load command KEY 2 immediate
+ *  
+ *  0001 0100 1100 0000 0000 1100 0000 1000
+ *  |||| |||  |||| |||| |||| |||| |||| ||||
+ *  |||| |||  |||| |||| |||| |||| ++++-++++-- Length 
+ *  |||| |||  |||| |||| ++++-++++-- Offset
+ *  |||| |||  |+++-++++-- DST (Destination Register) Key2
+ *  |||| |||  +-- IMM (Immediate flag)
+ *  |||| |++-- class 2
+ *  ++++-+-- Load command
+ */
+#define DECAP_BLOB_DESC2 0x14C00C08
+
+/* 3. 8 bytes for load command above - aad data
+ *
+ *  0000 0000 0001 0000 0101 0101 0110 0110
+ *  |||| |||| |||| |||| |||| |||| |||| ||||
+ *  |||| |||| |||| |||| |||| |||| ++++-++++-- CCM Mode 
+ *  |||| |||| |||| |||| ++++-++++-- AES
+ *  |||| |||| ++++-++++-- Length
+ *  ++++-++++-- Flag
+ */
+#define DECAP_BLOB_DESC3 0x00105566
+#define DECAP_BLOB_DESC4 0x00000000
+
+/* 5. SEQ In Ptr
+ *  
+ *  1111 0000 0000 0000 0000 0000 0100 0000
+ *  |||| |              |||| |||| |||| ||||
+ *  |||| |              ++++-++++-++++-++++-- Length in bytes (64) 
+ *  ++++-+-- Seq In Ptr
+ */
+#define DECAP_BLOB_DESC5 0xF0000400
+//#define DECAP_BLOB_DESC5 0xF0000040
+
+/* 6. Pointer for above SEQ In ptr command */
+/* Address is provided during run time */
+#define DECAP_BLOB_DESC6 0x00000000 
+
+/* 7. SEQ Out Ptr
+ *  
+ *  1111 1000 0000 0000 0000 0000 0001 0000
+ *  |||| |              |||| |||| |||| ||||
+ *  |||| |              ++++-++++-++++-++++-- Length in bytes (16) 
+ *  ++++-+-- Seq In Ptr
+ */
+#define DECAP_BLOB_DESC7 0xF80003d0
+//#define DECAP_BLOB_DESC7 0xF8000010
+
+/* 8. Pointer for above SEQ Out ptr command */
+/* Address could be changed during run time */
+#define DECAP_BLOB_DESC8 SEC_MEM_PAGE1
+
+/* 9. Protocol 
+ *  
+ *  1000 0110 0000 1101 0000 0000 0000 1000
+ *  |||| |||| |||| |||| |||| |||| |||| ||||
+ *  |||| |||| |||| |||| ++++-++++-++++-++++-- Proto Info = sec mem blob
+ *  |||| |||| ++++-++++-- Protocol ID = Blob
+ *  |||| |+++-- Optype - decapsulation protocol
+ *  ++++-+-- Seq In Ptr
+ */
+#define DECAP_BLOB_DESC9 0x860D0008
+
+/*****************************************
+ *----- Blob encapsulate descriptor -----*
+ *****************************************/
+/* Blob Header
+ *
+ *  1011 0000 1000 0000 0000 0000 0000 1001
+ *  |||| |                             |
+ *  ++++-+-- Header                    +-- 9 words in descriptor
+ */  
+#define ENCAP_BLOB_DESC1  0xB0800009
+
+/* 2. Load command KEY 2 immediate
+ *  
+ *  0001 0100 1100 0000 0000 1100 0000 1000
+ *  |||| |||  |||| |||| |||| |||| |||| ||||
+ *  |||| |||  |||| |||| |||| |||| ++++-++++-- Length 
+ *  |||| |||  |||| |||| ++++-++++-- Offset
+ *  |||| |||  |+++-++++-- DST (Destination Register) Key2
+ *  |||| |||  +-- IMM (Immediate flag)
+ *  |||| |++-- class 2
+ *  ++++-+-- Load command
+ */
+#define ENCAP_BLOB_DESC2 0x14C00C08
+
+/* 3. 8 bytes for load command above - aad data
+ *
+ *  0000 0000 0001 0000 0101 0101 0110 0110
+ *  |||| |||| |||| |||| |||| |||| |||| ||||
+ *  |||| |||| |||| |||| |||| |||| ++++-++++-- CCM Mode 
+ *  |||| |||| |||| |||| ++++-++++-- AES
+ *  |||| |||| ++++-++++-- Length
+ *  ++++-++++-- Flag
+ */
+#define ENCAP_BLOB_DESC3 0x00105566
+#define ENCAP_BLOB_DESC4 0x00000000
+
+/* 5. SEQ In Ptr
+ *  
+ *  1111 0000 0000 0000 0000 0000 0001 0000
+ *  |||| |              |||| |||| |||| ||||
+ *  |||| |              ++++-++++-++++-++++-- Length in bytes (16) 
+ *  ++++-+-- Seq In Ptr
+ */
+#define ENCAP_BLOB_DESC5 0xF00003d0
+//#define ENCAP_BLOB_DESC5 0xF0000010
+
+/* 6. Pointer for above SEQ In ptr command */
+/* Address could be changed during run time */
+#define ENCAP_BLOB_DESC6 SEC_MEM_PAGE1
+
+/* 7. SEQ Out Ptr
+ *  
+ *  1111 1000 0000 0000 0000 0000 0100 0000
+ *  |||| |              |||| |||| |||| ||||
+ *  |||| |              ++++-++++-++++-++++-- Length in bytes (64) 
+ *  ++++-+-- Seq Out Ptr
+ */
+#define ENCAP_BLOB_DESC7  0xF8000400
+//#define ENCAP_BLOB_DESC7  0xF8000040
+
+/* 8. Pointer for above SEQ Out ptr command */
+/* Address is provided during run time */
+#define ENCAP_BLOB_DESC8  0x00000000
+
+/* 9. Protocol 
+ *  
+ *  1000 0111 0000 1101 0000 0000 0000 1000
+ *  |||| |||| |||| |||| |||| |||| |||| ||||
+ *  |||| |||| |||| |||| ++++-++++-++++-++++-- Proto Info = sec mem blob
+ *  |||| |||| ++++-++++-- Protocol ID = Blob
+ *  |||| |+++-- Optype - encapsulation protocol
+ *  ++++-+-- Seq In Ptr
+ */
+#define ENCAP_BLOB_DESC9  0x870D0008
+
+/****************************************
+ *----- Data encryption descriptor -----*
+ ****************************************/
+/* 1. Header
+ *
+ * 1011 0000 1000 0000 0000 0000 0000 1000
+ * |||| | | ||||
+ * ++++-+-- Header +-++++-- 8 words in descriptor
+ */
+#define ENCRYPT_DESC1 0xB0800008
+
+/* 2. Load AES-128 key from secure memory
+ *
+ * 0010 0010 0000 0000 0000 0000 0001 0000
+ * |||| | | |||| |||| |||| ||||
+ * |||| | | ++++-++++-++++-++++-- 16 bytes
+ * |||| | +-- Load FIFO with data for Class 1 CHA
+ * ++++-+-- FIFO Load
+ */
+#define ENCRYPT_DESC2 0x02200010
+
+/* 3. Pointer to key data in secure memory */
+/* Address is provided during run time */
+#define ENCRYPT_DESC3 0x00000000
+
+/* 4. Algorith Operation - Decrypt with ECB mode
+ *
+ * 1000 0010 0001 0000 0000 0010 0000 1101
+ * |||| |||| |||| |||| |||| |||| |||| ||||
+ * |||| |||| |||| |||| |||| |||| |||| |||+-- Encrypt
+ * |||| |||| |||| |||| |||| |||| |||| ++-- Initialize/Finalize
+ * |||| |||| |||| |||| ---+-++++-++++-- ECB mode
+ * |||| |||| ++++-++++-- AES
+ * |||| |+++-- Optype: Class 1 algorithm
+ * ++++-+-- ALGORITHM OP.
+ */
+#define ENCRYPT_DESC4 0x8210020D
+
+/* 5. Load 16 bytes of message data
+ *
+ * 0010 0010 0001 0010 0000 0000 0001 0000
+ * |||| |||| |||| |||| |||| |||| |||| ||||
+ * |||| |||| |||| |||| |||| |||| |||| ||||
+ * |||| |||| |||| |||| |||| |||| |||| ||||
+ * |||| |||| |||| |||| ++++-++++-++++-++++-- Msg Length = 16Bytes
+ * |||| |||| ||++-++++-- Input data type: Msg data LC1=1
+ * |||| |||| |+-- EXT: No extended length
+ * |||| |||| +-- IMM: data begins at the location pointed to by the next word
+ * |||| |||++-SGT/VLF: FIFO Load-Pointer points to actual data
+ * |||| |++-- Load FIFO with data for Class 1 CHA
+ * ++++-+-- FIFO Load
+ */
+#define ENCRYPT_DESC5 0x22120010
+
+/* 6. Pointer to plain text test vector message */
+/* Address is provided during run time */
+#define ENCRYPT_DESC6 0x00000000
+
+/* 7. FIFO STORE - encrypted result.
+ * 0110 0000 0011 0000 0000 0000 0001 0000
+ * |||| |||| |||| |||| |||| |||| |||| ||||
+ * |||| |||| |||| |||| ++++-++++-++++-++++-- Length = 16Bytes
+ * |||| |||| ||++-++++-- Output data type: Msg Data
+ * |||| |||| |+-- EXT: No extended length
+ * |||| |||| +-- CONT: No continue
+ * |||| |||+-- SGT/VLF: Pointer points to actual data
+ * |||| |++-- AUX: None
+ * ++++-+-- FIFO Store
+ */
+#define ENCRYPT_DESC7 0x60300010
+
+/* 8. Pointer to ciphered text buffer */
+/* Address is provided during run time */
+#define ENCRYPT_DESC8 0x00000000
+
+/*********************************************************************
+ *----- Descriptor to instantiate RNG in non-deterministic mode -----*
+ *********************************************************************/
+// Header
+#define RNG_INST_DESC1 0xB0800009
+// Class 1 context load for personalization string, 8bytes
+#define RNG_INST_DESC2 0x12A00008
+// 8 bytes of personalization string (8-byte UID + zeros)
+#define RNG_INST_DESC3 0x01020304
+#define RNG_INST_DESC4 0x05060708
+// Instantiate State Handle 0 using entropy from TRNG
+// without prediction resistance
+#define RNG_INST_DESC5 0x82500404
+// Wait for Class 1 done
+#define RNG_INST_DESC6 0xA2000001
+// Immediate 4 byte load to clear written register
+#define RNG_INST_DESC7 0x10880004
+// Clear primary mode bit
+#define RNG_INST_DESC8 0x00000001
+// Generate secure keys without prediction resistance
+#define RNG_INST_DESC9 0x82501000
+
+#endif /* __CAAM_INTERNAL_H__ */
diff --git a/drivers/misc/mxc_ocotp.c b/drivers/misc/mxc_ocotp.c
index bdbe0bd..c7cbf97 100644
--- a/drivers/misc/mxc_ocotp.c
+++ b/drivers/misc/mxc_ocotp.c
@@ -7,7 +7,7 @@
  * which is based on Freescale's
  * http://git.freescale.com/git/cgit.cgi/imx/uboot-imx.git/tree/drivers/misc/imx_otp.c?h=imx_v2009.08_1.1.0&id=9aa74e6,
  * which is:
- * Copyright (C) 2011-2015 Freescale Semiconductor, Inc.
+ * Copyright (C) 2011-2016 Freescale Semiconductor, Inc.
  *
  * SPDX-License-Identifier:	GPL-2.0+
  */
@@ -61,6 +61,8 @@
 #define FUSE_BANK_SIZE	0x80
 #ifdef CONFIG_MX6SL
 #define FUSE_BANKS	8
+#elif defined CONFIG_MX6ULL
+#define FUSE_BANKS	9
 #else
 #define FUSE_BANKS	16
 #endif
@@ -76,7 +78,7 @@
 
 /*
  * There is a hole in shadow registers address map of size 0x100
- * between bank 5 and bank 6 on iMX6QP, iMX6DQ, iMX6SDL, iMX6SX and iMX6UL.
+ * between bank 5 and bank 6 on iMX6QP, iMX6DQ, iMX6SDL, iMX6SX, iMX6UL and iMX6ULL.
  * Bank 5 ends at 0x6F0 and Bank 6 starts at 0x800. When reading the fuses,
  * we should account for this hole in address space.
  *
@@ -98,7 +100,10 @@ u32 fuse_bank_physical(int index)
 	if ((index == 0) || is_cpu_type(MXC_CPU_MX6SL) ||
 	    is_cpu_type(MXC_CPU_MX7D))
 		phy_index = index;
-	else if (is_cpu_type(MXC_CPU_MX6UL)) {
+	else if (is_cpu_type(MXC_CPU_MX6UL) || is_cpu_type(MXC_CPU_MX6ULL)) {
+		if (is_cpu_type(MXC_CPU_MX6ULL) && index == 8)
+			index = 7;
+
 		if (index >= 6)
 			phy_index = fuse_bank_physical(5) + (index - 6) + 3;
 		else
@@ -113,11 +118,27 @@ u32 fuse_bank_physical(int index)
 	}
 	return phy_index;
 }
+
+u32 fuse_word_physical(u32 bank, u32 word_index)
+{
+	if (is_cpu_type(MXC_CPU_MX6ULL)) {
+		if (bank == 8)
+			word_index = word_index + 4;
+	}
+
+	return word_index;
+}
 #else
 u32 fuse_bank_physical(int index)
 {
 	return index;
 }
+
+u32 fuse_word_physical(u32 bank, u32 word_index)
+{
+	return word_index;
+}
+
 #endif
 
 static void wait_busy(struct ocotp_regs *regs, unsigned int delay_us)
@@ -143,6 +164,14 @@ static int prepare_access(struct ocotp_regs **regs, u32 bank, u32 word,
 		return -EINVAL;
 	}
 
+	if (is_cpu_type(MXC_CPU_MX6ULL)) {
+		if ((bank == 7 || bank == 8) &&
+		    word >= ARRAY_SIZE((*regs)->bank[0].fuse_regs) >> 3) {
+			printf("mxc_ocotp %s(): Invalid argument on 6ULL\n", caller);
+			return -EINVAL;
+		}
+	}
+
 	enable_ocotp_clk(1);
 
 	wait_busy(*regs, 1);
@@ -177,14 +206,16 @@ int fuse_read(u32 bank, u32 word, u32 *val)
 	struct ocotp_regs *regs;
 	int ret;
 	u32 phy_bank;
+	u32 phy_word;
 
 	ret = prepare_read(&regs, bank, word, val, __func__);
 	if (ret)
 		return ret;
 
 	phy_bank = fuse_bank_physical(bank);
+	phy_word = fuse_word_physical(bank, word);
 
-	*val = readl(&regs->bank[phy_bank].fuse_regs[word << 2]);
+	*val = readl(&regs->bank[phy_bank].fuse_regs[phy_word << 2]);
 
 	return finish_access(regs, __func__);
 }
@@ -326,14 +357,16 @@ int fuse_override(u32 bank, u32 word, u32 val)
 	struct ocotp_regs *regs;
 	int ret;
 	u32 phy_bank;
+	u32 phy_word;
 
 	ret = prepare_write(&regs, bank, word, __func__);
 	if (ret)
 		return ret;
 
 	phy_bank = fuse_bank_physical(bank);
+	phy_word = fuse_word_physical(bank, word);
 
-	writel(val, &regs->bank[phy_bank].fuse_regs[word << 2]);
+	writel(val, &regs->bank[phy_bank].fuse_regs[phy_word << 2]);
 
 	return finish_access(regs, __func__);
 }
diff --git a/drivers/misc/mxc_ocotp.c.orig b/drivers/misc/mxc_ocotp.c.orig
new file mode 100644
index 0000000..bdbe0bd
--- /dev/null
+++ b/drivers/misc/mxc_ocotp.c.orig
@@ -0,0 +1,339 @@
+/*
+ * (C) Copyright 2013 ADVANSEE
+ * Benoît Thébaudeau <benoit.thebaudeau@advansee.com>
+ *
+ * Based on Dirk Behme's
+ * https://github.com/dirkbehme/u-boot-imx6/blob/28b17e9/drivers/misc/imx_otp.c,
+ * which is based on Freescale's
+ * http://git.freescale.com/git/cgit.cgi/imx/uboot-imx.git/tree/drivers/misc/imx_otp.c?h=imx_v2009.08_1.1.0&id=9aa74e6,
+ * which is:
+ * Copyright (C) 2011-2015 Freescale Semiconductor, Inc.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <common.h>
+#include <fuse.h>
+#include <asm/errno.h>
+#include <asm/io.h>
+#include <asm/arch/clock.h>
+#include <asm/arch/imx-regs.h>
+
+#define BO_CTRL_WR_UNLOCK		16
+#define BM_CTRL_WR_UNLOCK		0xffff0000
+#define BV_CTRL_WR_UNLOCK_KEY		0x3e77
+#define BM_CTRL_ERROR			0x00000200
+#define BM_CTRL_BUSY			0x00000100
+#define BO_CTRL_ADDR			0
+#ifdef CONFIG_MX7
+#define BM_CTRL_ADDR			0x0000000f
+#define BM_CTRL_RELOAD			0x00000400
+#else
+#define BM_CTRL_ADDR			0x0000007f
+#endif
+
+#ifdef CONFIG_MX7
+#define BO_TIMING_FSOURCE		12
+#define BM_TIMING_FSOURCE		0x0007f000
+#define BV_TIMING_FSOURCE_NS		1001
+#define BO_TIMING_PROG			0
+#define BM_TIMING_PROG			0x00000fff
+#define BV_TIMING_PROG_US		10
+#else
+#define BO_TIMING_STROBE_READ		16
+#define BM_TIMING_STROBE_READ		0x003f0000
+#define BV_TIMING_STROBE_READ_NS	37
+#define BO_TIMING_RELAX			12
+#define BM_TIMING_RELAX			0x0000f000
+#define BV_TIMING_RELAX_NS		17
+#define BO_TIMING_STROBE_PROG		0
+#define BM_TIMING_STROBE_PROG		0x00000fff
+#define BV_TIMING_STROBE_PROG_US	10
+#endif
+
+#define BM_READ_CTRL_READ_FUSE		0x00000001
+
+#define BF(value, field)		(((value) << BO_##field) & BM_##field)
+
+#define WRITE_POSTAMBLE_US		2
+
+#if defined(CONFIG_MX6) || defined(CONFIG_VF610)
+#define FUSE_BANK_SIZE	0x80
+#ifdef CONFIG_MX6SL
+#define FUSE_BANKS	8
+#else
+#define FUSE_BANKS	16
+#endif
+#elif defined CONFIG_MX7
+#define FUSE_BANK_SIZE	0x40
+#define FUSE_BANKS	16
+#else
+#error "Unsupported architecture\n"
+#endif
+
+#if defined(CONFIG_MX6) || defined(CONFIG_MX7)
+#include <asm/arch/sys_proto.h>
+
+/*
+ * There is a hole in shadow registers address map of size 0x100
+ * between bank 5 and bank 6 on iMX6QP, iMX6DQ, iMX6SDL, iMX6SX and iMX6UL.
+ * Bank 5 ends at 0x6F0 and Bank 6 starts at 0x800. When reading the fuses,
+ * we should account for this hole in address space.
+ *
+ * Similar hole exists between bank 14 and bank 15 of size
+ * 0x80 on iMX6QP, iMX6DQ, iMX6SDL and iMX6SX.
+ * Note: iMX6SL has only 0-7 banks and there is no hole.
+ * Note: iMX6UL doesn't have this one.
+ *
+ * This function is to covert user input to physical bank index.
+ * Only needed when read fuse, because we use register offset, so
+ * need to calculate real register offset.
+ * When write, no need to consider hole, always use the bank/word
+ * index from fuse map.
+ */
+u32 fuse_bank_physical(int index)
+{
+	u32 phy_index;
+
+	if ((index == 0) || is_cpu_type(MXC_CPU_MX6SL) ||
+	    is_cpu_type(MXC_CPU_MX7D))
+		phy_index = index;
+	else if (is_cpu_type(MXC_CPU_MX6UL)) {
+		if (index >= 6)
+			phy_index = fuse_bank_physical(5) + (index - 6) + 3;
+		else
+			phy_index = index;
+	} else {
+		if (index >= 15)
+			phy_index = fuse_bank_physical(14) + (index - 15) + 2;
+		else if (index >= 6)
+			phy_index = fuse_bank_physical(5) + (index - 6) + 3;
+		else
+			phy_index = index;
+	}
+	return phy_index;
+}
+#else
+u32 fuse_bank_physical(int index)
+{
+	return index;
+}
+#endif
+
+static void wait_busy(struct ocotp_regs *regs, unsigned int delay_us)
+{
+	while (readl(&regs->ctrl) & BM_CTRL_BUSY)
+		udelay(delay_us);
+}
+
+static void clear_error(struct ocotp_regs *regs)
+{
+	writel(BM_CTRL_ERROR, &regs->ctrl_clr);
+}
+
+static int prepare_access(struct ocotp_regs **regs, u32 bank, u32 word,
+				int assert, const char *caller)
+{
+	*regs = (struct ocotp_regs *)OCOTP_BASE_ADDR;
+
+	if (bank >= FUSE_BANKS ||
+	    word >= ARRAY_SIZE((*regs)->bank[0].fuse_regs) >> 2 ||
+	    !assert) {
+		printf("mxc_ocotp %s(): Invalid argument\n", caller);
+		return -EINVAL;
+	}
+
+	enable_ocotp_clk(1);
+
+	wait_busy(*regs, 1);
+	clear_error(*regs);
+
+	return 0;
+}
+
+static int finish_access(struct ocotp_regs *regs, const char *caller)
+{
+	u32 err;
+
+	err = !!(readl(&regs->ctrl) & BM_CTRL_ERROR);
+	clear_error(regs);
+
+	if (err) {
+		printf("mxc_ocotp %s(): Access protect error\n", caller);
+		return -EIO;
+	}
+
+	return 0;
+}
+
+static int prepare_read(struct ocotp_regs **regs, u32 bank, u32 word, u32 *val,
+			const char *caller)
+{
+	return prepare_access(regs, bank, word, val != NULL, caller);
+}
+
+int fuse_read(u32 bank, u32 word, u32 *val)
+{
+	struct ocotp_regs *regs;
+	int ret;
+	u32 phy_bank;
+
+	ret = prepare_read(&regs, bank, word, val, __func__);
+	if (ret)
+		return ret;
+
+	phy_bank = fuse_bank_physical(bank);
+
+	*val = readl(&regs->bank[phy_bank].fuse_regs[word << 2]);
+
+	return finish_access(regs, __func__);
+}
+
+#ifdef CONFIG_MX7
+static void set_timing(struct ocotp_regs *regs)
+{
+	u32 ipg_clk;
+	u32 fsource, prog;
+	u32 timing;
+
+	ipg_clk = mxc_get_clock(MXC_IPG_CLK);
+
+	fsource = DIV_ROUND_UP((ipg_clk / 1000) * BV_TIMING_FSOURCE_NS,
+			       1000000) + 1;
+	prog = DIV_ROUND_CLOSEST(ipg_clk * BV_TIMING_PROG_US, 1000000) + 1;
+
+	timing = BF(fsource, TIMING_FSOURCE) | BF(prog, TIMING_PROG);
+
+	clrsetbits_le32(&regs->timing, BM_TIMING_FSOURCE | BM_TIMING_PROG,
+			timing);
+}
+#else
+static void set_timing(struct ocotp_regs *regs)
+{
+	u32 ipg_clk;
+	u32 relax, strobe_read, strobe_prog;
+	u32 timing;
+
+	ipg_clk = mxc_get_clock(MXC_IPG_CLK);
+
+	relax = DIV_ROUND_UP(ipg_clk * BV_TIMING_RELAX_NS, 1000000000) - 1;
+	strobe_read = DIV_ROUND_UP(ipg_clk * BV_TIMING_STROBE_READ_NS,
+					1000000000) + 2 * (relax + 1) - 1;
+	strobe_prog = DIV_ROUND_CLOSEST(ipg_clk * BV_TIMING_STROBE_PROG_US,
+						1000000) + 2 * (relax + 1) - 1;
+
+	timing = BF(strobe_read, TIMING_STROBE_READ) |
+			BF(relax, TIMING_RELAX) |
+			BF(strobe_prog, TIMING_STROBE_PROG);
+
+	clrsetbits_le32(&regs->timing, BM_TIMING_STROBE_READ | BM_TIMING_RELAX |
+			BM_TIMING_STROBE_PROG, timing);
+}
+#endif
+
+static void setup_direct_access(struct ocotp_regs *regs, u32 bank, u32 word,
+				int write)
+{
+	u32 wr_unlock = write ? BV_CTRL_WR_UNLOCK_KEY : 0;
+#ifdef CONFIG_MX7
+	u32 addr = bank;
+#else
+	u32 addr = bank << 3 | word;
+#endif
+
+	set_timing(regs);
+	clrsetbits_le32(&regs->ctrl, BM_CTRL_WR_UNLOCK | BM_CTRL_ADDR,
+			BF(wr_unlock, CTRL_WR_UNLOCK) |
+			BF(addr, CTRL_ADDR));
+}
+
+int fuse_sense(u32 bank, u32 word, u32 *val)
+{
+	struct ocotp_regs *regs;
+	int ret;
+
+	ret = prepare_read(&regs, bank, word, val, __func__);
+	if (ret)
+		return ret;
+
+	setup_direct_access(regs, bank, word, false);
+	writel(BM_READ_CTRL_READ_FUSE, &regs->read_ctrl);
+	wait_busy(regs, 1);
+#ifdef CONFIG_MX7
+	*val = readl((&regs->read_fuse_data0) + (word << 2));
+#else
+	*val = readl(&regs->read_fuse_data);
+#endif
+
+	return finish_access(regs, __func__);
+}
+
+static int prepare_write(struct ocotp_regs **regs, u32 bank, u32 word,
+				const char *caller)
+{
+	return prepare_access(regs, bank, word, true, caller);
+}
+
+int fuse_prog(u32 bank, u32 word, u32 val)
+{
+	struct ocotp_regs *regs;
+	int ret;
+
+	ret = prepare_write(&regs, bank, word, __func__);
+	if (ret)
+		return ret;
+
+	setup_direct_access(regs, bank, word, true);
+#ifdef CONFIG_MX7
+	switch (word) {
+	case 0:
+		writel(0, &regs->data1);
+		writel(0, &regs->data2);
+		writel(0, &regs->data3);
+		writel(val, &regs->data0);
+		break;
+	case 1:
+		writel(val, &regs->data1);
+		writel(0, &regs->data2);
+		writel(0, &regs->data3);
+		writel(0, &regs->data0);
+		break;
+	case 2:
+		writel(0, &regs->data1);
+		writel(val, &regs->data2);
+		writel(0, &regs->data3);
+		writel(0, &regs->data0);
+		break;
+	case 3:
+		writel(0, &regs->data1);
+		writel(0, &regs->data2);
+		writel(val, &regs->data3);
+		writel(0, &regs->data0);
+		break;
+	}
+	wait_busy(regs, BV_TIMING_PROG_US);
+#else
+	writel(val, &regs->data);
+	wait_busy(regs, BV_TIMING_STROBE_PROG_US);
+#endif
+	udelay(WRITE_POSTAMBLE_US);
+
+	return finish_access(regs, __func__);
+}
+
+int fuse_override(u32 bank, u32 word, u32 val)
+{
+	struct ocotp_regs *regs;
+	int ret;
+	u32 phy_bank;
+
+	ret = prepare_write(&regs, bank, word, __func__);
+	if (ret)
+		return ret;
+
+	phy_bank = fuse_bank_physical(bank);
+
+	writel(val, &regs->bank[phy_bank].fuse_regs[word << 2]);
+
+	return finish_access(regs, __func__);
+}
diff --git a/drivers/mmc/mmc_write.c b/drivers/mmc/mmc_write.c
index 3db9669..9edf214 100644
--- a/drivers/mmc/mmc_write.c
+++ b/drivers/mmc/mmc_write.c
@@ -49,7 +49,7 @@ static ulong mmc_erase_t(struct mmc *mmc, ulong start, lbaint_t blkcnt)
 		goto err_out;
 
 	cmd.cmdidx = MMC_CMD_ERASE;
-	cmd.cmdarg = SECURE_ERASE;
+	cmd.cmdarg = MMC_ERASE_ARG;
 	cmd.resp_type = MMC_RSP_R1b;
 
 	err = mmc_send_cmd(mmc, &cmd, NULL);
diff --git a/drivers/usb/gadget/Makefile b/drivers/usb/gadget/Makefile
index 4869867..b00e753 100644
--- a/drivers/usb/gadget/Makefile
+++ b/drivers/usb/gadget/Makefile
@@ -20,6 +20,9 @@ obj-$(CONFIG_USBDOWNLOAD_GADGET) += g_dnl.o
 obj-$(CONFIG_DFU_FUNCTION) += f_dfu.o
 obj-$(CONFIG_USB_GADGET_MASS_STORAGE) += f_mass_storage.o
 obj-$(CONFIG_CMD_FASTBOOT) += f_fastboot.o
+obj-$(CONFIG_FASTBOOT_LOCK) += fastboot_lock_unlock.o
+obj-$(CONFIG_BRILLO_SUPPORT) += bootctrl.o
+obj-$(CONFIG_BCB_SUPPORT) += command.o bcb.o
 endif
 ifdef CONFIG_USB_ETHER
 obj-y += ether.o
diff --git a/drivers/usb/gadget/bcb.c b/drivers/usb/gadget/bcb.c
new file mode 100644
index 0000000..f6ccf91
--- /dev/null
+++ b/drivers/usb/gadget/bcb.c
@@ -0,0 +1,177 @@
+/*
+ * Copyright (C) 2015-2016 Freescale Semiconductor, Inc.
+ *
+ * SPDX-License-Identifier:     GPL-2.0+
+ */
+
+#include "bcb.h"
+#include "bootctrl.h"
+#include <linux/stat.h>
+#include <linux/types.h>
+#include <common.h>
+#include <g_dnl.h>
+static unsigned int g_mmc_id;
+void set_mmc_id(unsigned int id)
+{
+	g_mmc_id = id;
+}
+#define ALIGN_BYTES 64 /*armv7 cache line need 64 bytes aligned */
+static ulong get_block_size(char *ifname, int dev, int part)
+{
+	block_dev_desc_t *dev_desc = NULL;
+	disk_partition_t part_info;
+
+	dev_desc = get_dev(ifname, dev);
+	if (dev_desc == NULL) {
+		printf("Block device %s %d not supported\n", ifname, dev);
+		return 0;
+	}
+
+	if (get_partition_info(dev_desc, part, &part_info)) {
+		printf("Cannot find partition %d\n", part);
+		return 0;
+	}
+
+	return part_info.blksz;
+}
+
+static int do_write(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
+{
+	char *ep;
+	block_dev_desc_t *dev_desc = NULL;
+	int dev;
+	int part = 0;
+	disk_partition_t part_info;
+	ulong offset = 0u;
+	ulong limit = 0u;
+	void *addr;
+	uint blk;
+	uint cnt;
+
+	if (argc != 6) {
+		cmd_usage(cmdtp);
+		return 1;
+	}
+
+	dev = (int)simple_strtoul(argv[2], &ep, 16);
+	if (*ep) {
+		if (*ep != ':') {
+			printf("Invalid block device %s\n", argv[2]);
+			return 1;
+		}
+		part = (int)simple_strtoul(++ep, NULL, 16);
+	}
+
+	dev_desc = get_dev(argv[1], dev);
+	if (dev_desc == NULL) {
+		printf("Block device %s %d not supported\n", argv[1], dev);
+		return 1;
+	}
+
+	addr = (void *)simple_strtoul(argv[3], NULL, 16);
+	blk = simple_strtoul(argv[4], NULL, 16);
+	cnt = simple_strtoul(argv[5], NULL, 16);
+
+	if (part != 0) {
+		if (get_partition_info(dev_desc, part, &part_info)) {
+			printf("Cannot find partition %d\n", part);
+			return 1;
+		}
+		offset = part_info.start;
+		limit = part_info.size;
+	} else {
+		/* Largest address not available in block_dev_desc_t. */
+		limit = ~0;
+	}
+
+	if (cnt + blk > limit) {
+		printf("Write out of range\n");
+		return 1;
+	}
+
+	if (dev_desc->block_write(dev, offset + blk, cnt, addr) < 0) {
+		printf("Error writing blocks\n");
+		return 1;
+	}
+
+	return 0;
+}
+
+U_BOOT_CMD(
+	write,	6,	0,	do_write,
+	"write binary data to a partition",
+	"<interface> <dev[:part]> addr blk# cnt"
+);
+
+int rw_block(bool bread, char **ppblock,
+		uint *pblksize, char *pblock_write, uint offset, uint size)
+{
+	int ret;
+	char *argv[6];
+	char addr_str[20];
+	char cnt_str[8];
+	char devpart_str[8];
+	char block_begin_str[8];
+	ulong blk_size = 0;
+	uint blk_begin = 0;
+	uint blk_end = 0;
+	uint block_cnt = 0;
+	char *p_block = NULL;
+
+	if (bread && ((ppblock == NULL) || (pblksize == NULL)))
+		return -1;
+
+	if (!bread && (pblock_write == NULL))
+		return -1;
+
+	blk_size = get_block_size("mmc", g_mmc_id,
+		CONFIG_ANDROID_MISC_PARTITION_MMC);
+	if (blk_size == 0) {
+		printf("rw_block, get_block_size return 0\n");
+		return -1;
+	}
+
+	blk_begin = offset/blk_size;
+	blk_end = (offset + size)/blk_size;
+	block_cnt = 1 + (blk_end - blk_begin);
+
+
+	sprintf(devpart_str, "0x%x:0x%x", g_mmc_id,
+		CONFIG_ANDROID_MISC_PARTITION_MMC);
+	sprintf(block_begin_str, "0x%x", blk_begin);
+	sprintf(cnt_str, "0x%x", block_cnt);
+
+	argv[0] = "rw"; /* not care */
+	argv[1] = "mmc";
+	argv[2] = devpart_str;
+	argv[3] = addr_str;
+	argv[4] = block_begin_str;
+	argv[5] = cnt_str;
+
+	if (bread) {
+		p_block = (char *)memalign(ALIGN_BYTES, blk_size * block_cnt);
+		if (NULL == p_block) {
+			printf("rw_block, memalign %d bytes failed\n",
+			(int)(blk_size * block_cnt));
+			return -1;
+		}
+		sprintf(addr_str, "0x%x", (unsigned int)p_block);
+		ret = do_raw_read(NULL, 0, 6, argv);
+		if (ret) {
+			free(p_block);
+			printf("do_raw_read failed, ret %d\n", ret);
+			return -1;
+		}
+
+		*ppblock = p_block;
+		*pblksize = (uint)blk_size;
+	} else {
+		sprintf(addr_str, "0x%x", (unsigned int)pblock_write);
+		ret = do_write(NULL, 0, 6, argv);
+		if (ret) {
+			printf("do_write failed, ret %d\n", ret);
+			return -1;
+		}
+	}
+	return 0;
+}
diff --git a/drivers/usb/gadget/bcb.h b/drivers/usb/gadget/bcb.h
new file mode 100644
index 0000000..2512a7f
--- /dev/null
+++ b/drivers/usb/gadget/bcb.h
@@ -0,0 +1,38 @@
+/*
+ * Copyright (C) 2015-2016 Freescale Semiconductor, Inc.
+ *
+ * SPDX-License-Identifier:     GPL-2.0+
+ */
+
+#ifndef BCB_H
+#define BCB_H
+#include <linux/types.h>
+#include <linux/stat.h>
+/* keep same as bootable/recovery/bootloader.h */
+struct bootloader_message {
+	char command[32];
+	char status[32];
+	char recovery[768];
+
+	/* The 'recovery' field used to be 1024 bytes.  It has only ever
+	been used to store the recovery command line, so 768 bytes
+	should be plenty.  We carve off the last 256 bytes to store the
+	stage string (for multistage packages) and possible future
+	expansion. */
+	char stage[32];
+	char slot_suffix[32];
+	char reserved[192];
+};
+
+/* start from bootloader_message.slot_suffix[BOOTCTRL_IDX] */
+#define BOOTCTRL_IDX                            0
+#define MISC_COMMAND_IDX                        0
+#define BOOTCTRL_OFFSET         \
+	(u32)(&(((struct bootloader_message *)0)->slot_suffix[BOOTCTRL_IDX]))
+#define MISC_COMMAND \
+	(u32)(&(((struct bootloader_message *)0)->command[MISC_COMMAND_IDX]))
+int rw_block(bool bread, char **ppblock,
+		uint *pblksize, char *pblock_write, uint offset, uint size);
+
+void set_mmc_id(unsigned int id);
+#endif
diff --git a/drivers/usb/gadget/bootctrl.c b/drivers/usb/gadget/bootctrl.c
new file mode 100644
index 0000000..21a7aee
--- /dev/null
+++ b/drivers/usb/gadget/bootctrl.c
@@ -0,0 +1,346 @@
+/*
+ * Copyright (C) 2015-2016 Freescale Semiconductor, Inc.
+ *
+ * SPDX-License-Identifier:     GPL-2.0+
+ */
+
+#include <common.h>
+#include <g_dnl.h>
+#include <fsl_fastboot.h>
+#include "bootctrl.h"
+#include <linux/types.h>
+#include <linux/stat.h>
+static unsigned int g_slot_selected;
+static const char *g_slot_suffix[SLOT_NUM] = {"_a", "_b"};
+
+static int do_write(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[]);
+
+static int strcmp_l1(const char *s1, const char *s2)
+{
+	if (!s1 || !s2)
+		return -1;
+	return strncmp(s1, s2, strlen(s1));
+}
+
+
+static void dump_slotmeta(struct boot_ctl *ptbootctl)
+{
+	int i;
+
+	if (ptbootctl == NULL)
+		return;
+
+	printf("RecoveryTryRemain %d, crc %u\n",
+		   ptbootctl->recovery_tryremain, ptbootctl->crc);
+
+	for (i = 0; i < SLOT_NUM; i++) {
+		printf("slot %d: pri %d, try %d, suc %d\n", i,
+			   ptbootctl->a_slot_meta[i].priority,
+				ptbootctl->a_slot_meta[i].tryremain,
+				ptbootctl->a_slot_meta[i].bootsuc);
+	}
+
+	return;
+}
+
+const char *get_slot_suffix(void)
+{
+	return g_slot_suffix[g_slot_selected];
+}
+
+static unsigned int slot_find(struct boot_ctl *ptbootctl)
+{
+	unsigned int max_pri = 0;
+	unsigned int slot = -1;
+	int i;
+
+	for (i	= 0; i < SLOT_NUM; i++) {
+		struct slot_meta *pslot_meta = &(ptbootctl->a_slot_meta[i]);
+		if ((pslot_meta->priority > max_pri) &&
+			((pslot_meta->bootsuc > 0) ||
+			(pslot_meta->tryremain > 0))) {
+			max_pri = pslot_meta->priority;
+			slot = i;
+			printf("select_slot slot %d\n", slot);
+		}
+	}
+
+	return slot;
+}
+
+
+
+static int read_bootctl(struct boot_ctl *ptbootctl)
+{
+	int ret = 0;
+	unsigned int crc = 0;
+	char *p_block = NULL;
+	uint offset_in_block = 0;
+	uint blk_size = 0;
+	char *pmagic = NULL;
+
+	if (ptbootctl == NULL)
+		return -1;
+	ret = rw_block(true, &p_block, &blk_size, NULL,
+			BOOTCTRL_OFFSET, sizeof(struct boot_ctl));
+	if (ret) {
+		printf("read_bootctl, rw_block read failed\n");
+		return -1;
+	}
+
+	offset_in_block = BOOTCTRL_OFFSET%blk_size;
+	memcpy(ptbootctl, p_block + offset_in_block, sizeof(struct boot_ctl));
+
+	pmagic = ptbootctl->magic;
+	if (!((pmagic[0] == '\0') && (pmagic[1] == 'F') &&
+	      (pmagic[2] == 'S') && (pmagic[3] == 'L'))) {
+		printf("magic error, %c %c %c %c\n",
+		       pmagic[0], pmagic[1], pmagic[2], pmagic[3]);
+
+		free(p_block);
+		return -1;
+	}
+
+	/* check crc */
+	crc = crc32(0, (unsigned char *)ptbootctl + CRC_DATA_OFFSET,
+		sizeof(struct boot_ctl) - CRC_DATA_OFFSET);
+	if (crc != ptbootctl->crc) {
+		printf("crc check failed, caculated %d, read %d\n",
+		       crc, ptbootctl->crc);
+
+		free(p_block);
+		return -1;
+	}
+
+	free(p_block);
+	return 0;
+}
+
+static int write_bootctl(struct boot_ctl *ptbootctl)
+{
+	int ret = 0;
+	char *p_block = NULL;
+	uint offset_in_block = 0;
+	uint blk_size = 0;
+
+	if (ptbootctl == NULL)
+		return -1;
+
+	ptbootctl->crc = crc32(0, (unsigned char *)ptbootctl + CRC_DATA_OFFSET,
+		sizeof(struct boot_ctl) - CRC_DATA_OFFSET);
+
+	ret = rw_block(true, &p_block, &blk_size, NULL,
+				BOOTCTRL_OFFSET, sizeof(struct boot_ctl));
+	if (ret) {
+		printf("write_bootctl, rw_block read failed\n");
+		return -1;
+	}
+	offset_in_block = BOOTCTRL_OFFSET%blk_size;
+	memcpy(p_block + offset_in_block, ptbootctl, sizeof(struct boot_ctl));
+
+	ret = rw_block(false, NULL, NULL, p_block,
+			BOOTCTRL_OFFSET, sizeof(struct boot_ctl));
+	if (ret) {
+		free(p_block);
+		printf("write_bootctl, rw_block write failed\n");
+		return -1;
+	}
+	free(p_block);
+	return 0;
+}
+
+char *select_slot(void)
+{
+	int i = 0;
+	int ret = 0;
+	unsigned int slot;
+	struct boot_ctl t_bootctl;
+	bool b_need_write = false;
+
+	ret = read_bootctl(&t_bootctl);
+	if (ret) {
+		printf("read_bootctl failed, ret %d\n", ret);
+		return NULL;
+	}
+
+	dump_slotmeta(&t_bootctl);
+
+	slot = slot_find(&t_bootctl);
+	if (slot >= SLOT_NUM) {
+		printf("!!! select_slot, no valid slot\n");
+		return NULL;
+	}
+
+	/* invalid slot, set priority to 0 */
+	for (i	= 0; i < SLOT_NUM; i++) {
+		struct slot_meta *pslot_meta = &(t_bootctl.a_slot_meta[i]);
+		if ((pslot_meta->bootsuc == 0) &&
+			(pslot_meta->tryremain == 0) &&
+			(pslot_meta->priority > 0)) {
+			pslot_meta->priority = 0;
+			b_need_write = true;
+		}
+	}
+
+	if (t_bootctl.recovery_tryremain != 7) {
+		b_need_write = true;
+		t_bootctl.recovery_tryremain = 7;
+	}
+
+	if ((t_bootctl.a_slot_meta[slot].bootsuc == 0) &&
+		(t_bootctl.a_slot_meta[slot].tryremain > 0)) {
+		b_need_write = true;
+		t_bootctl.a_slot_meta[slot].tryremain--;
+	}
+
+	if (b_need_write) {
+		ret = write_bootctl(&t_bootctl);
+		if (ret)
+			printf("!!! write_bootctl failed, ret %d\n", ret);
+	}
+
+	g_slot_selected = slot;
+
+	if (slot == 0)
+		return FASTBOOT_PARTITION_BOOT_A;
+	else
+		return FASTBOOT_PARTITION_BOOT_B;
+}
+
+static unsigned int slotidx_from_suffix(char *suffix)
+{
+	unsigned int slot = -1;
+
+	if (!strcmp(suffix, "_a"))
+		slot = 0;
+	else if (!strcmp(suffix, "_b"))
+		slot = 1;
+
+	return slot;
+}
+
+bool is_sotvar(char *cmd)
+{
+	if (!strcmp_l1("has-slot:", cmd) ||
+		!strcmp_l1("slot-successful:", cmd) ||
+		!strcmp_l1("slot-suffixes", cmd) ||
+		!strcmp_l1("current-slot", cmd) ||
+		!strcmp_l1("slot-unbootable:", cmd) ||
+		!strcmp_l1("slot-retry-count:", cmd)) {
+		return true;
+	}
+
+	return false;
+}
+
+void get_slotvar(char *cmd, char *response, size_t chars_left)
+{
+	int ret;
+	struct boot_ctl t_bootctl;
+	memset(&t_bootctl, 0, sizeof(t_bootctl));
+
+	ret = read_bootctl(&t_bootctl);
+	if (ret) {
+		error("get_slotvar, read_bootctl failed\n");
+		strcpy(response, "get_slotvar read_bootctl failed");
+		return;
+	}
+
+	if (!strcmp_l1("has-slot:", cmd)) {
+		char *ptnname = NULL;
+		ptnname = strchr(cmd, ':') + 1;
+		if (!strcmp(ptnname, "system") || !strcmp(ptnname, "boot"))
+			strncat(response, "yes", chars_left);
+		else
+			strncat(response, "no", chars_left);
+	} else if (!strcmp_l1("current-slot", cmd)) {
+		unsigned int slot = slot_find(&t_bootctl);
+		if (slot < SLOT_NUM)
+			strncat(response, g_slot_suffix[slot], chars_left);
+		else
+			strncat(response, "no valid slot", chars_left);
+	} else if (!strcmp_l1("slot-suffixes", cmd)) {
+		strncat(response, "_a,_b", chars_left);
+	} else if (!strcmp_l1("slot-successful:", cmd)) {
+		char *suffix = strchr(cmd, ':') + 1;
+		unsigned int slot = slotidx_from_suffix(suffix);
+		if (slot >= SLOT_NUM) {
+			strncat(response, "no such slot", chars_left);
+		} else {
+			bool suc = t_bootctl.a_slot_meta[slot].bootsuc;
+			strncat(response, suc ? "yes" : "no", chars_left);
+		}
+	} else if (!strcmp_l1("slot-unbootable:", cmd)) {
+		char *suffix = strchr(cmd, ':') + 1;
+		unsigned int slot = slotidx_from_suffix(suffix);
+		if (slot >= SLOT_NUM) {
+			strncat(response, "no such slot", chars_left);
+		} else {
+			unsigned int pri = t_bootctl.a_slot_meta[slot].priority;
+			strncat(response, pri ? "no" : "yes", chars_left);
+		}
+	} else if (!strcmp_l1("slot-retry-count:", cmd)) {
+		char *suffix = strchr(cmd, ':') + 1;
+		unsigned int slot = slotidx_from_suffix(suffix);
+		if (slot >= SLOT_NUM)
+			strncat(response, "no such slot", chars_left);
+		else
+			sprintf(response, "OKAY%d",
+				t_bootctl.a_slot_meta[slot].tryremain);
+	} else {
+		strncat(response, "no such slot command", chars_left);
+	}
+
+	return;
+}
+
+
+void cb_set_active(struct usb_ep *ep, struct usb_request *req)
+{
+	int ret;
+	int i;
+	unsigned int slot = 0;
+	char *cmd = req->buf;
+	struct boot_ctl t_bootctl;
+
+	memset(&t_bootctl, 0, sizeof(t_bootctl));
+
+	strsep(&cmd, ":");
+	if (!cmd) {
+		error("missing slot suffix\n");
+		fastboot_tx_write_str("FAILmissing slot suffix");
+		return;
+	}
+
+	slot = slotidx_from_suffix(cmd);
+	if (slot >= SLOT_NUM) {
+		fastboot_tx_write_str("FAILerr slot suffix");
+		return;
+	}
+
+	ret = read_bootctl(&t_bootctl);
+	if (ret)
+		fastboot_tx_write_str("FAILReadBootCtl failed");
+
+	t_bootctl.a_slot_meta[slot].bootsuc = 0;
+	t_bootctl.a_slot_meta[slot].priority = 15;
+	t_bootctl.a_slot_meta[slot].tryremain = 7;
+
+	/* low other slot priority */
+	for (i = 0; i < SLOT_NUM; i++) {
+		if (i == slot)
+			continue;
+
+		if (t_bootctl.a_slot_meta[i].priority >= 15)
+			t_bootctl.a_slot_meta[i].priority = 14;
+	}
+
+	ret = write_bootctl(&t_bootctl);
+	if (ret)
+		fastboot_tx_write_str("write_bootctl failed");
+	else
+		fastboot_tx_write_str("OKAY");
+
+	return;
+}
+
diff --git a/drivers/usb/gadget/bootctrl.h b/drivers/usb/gadget/bootctrl.h
new file mode 100644
index 0000000..7712f75
--- /dev/null
+++ b/drivers/usb/gadget/bootctrl.h
@@ -0,0 +1,37 @@
+/*
+ * Copyright (C) 2015-2016 Freescale Semiconductor, Inc.
+ *
+ * SPDX-License-Identifier:     GPL-2.0+
+ */
+
+#ifndef BOOTCTRL_H
+#define BOOTCTRL_H
+
+#include <common.h>
+#include <g_dnl.h>
+#include <linux/types.h>
+#include <linux/stat.h>
+#include "bcb.h"
+
+#define SLOT_NUM (unsigned int)2
+#define CRC_DATA_OFFSET		\
+	(uint32_t)(&(((struct boot_ctl *)0)->a_slot_meta[0]))
+
+struct slot_meta {
+	u8 bootsuc:1;
+	u8 tryremain:3;
+	u8 priority:4;
+};
+
+struct boot_ctl {
+	char magic[4]; /* "\0FSL" */
+	u32 crc;
+	struct slot_meta a_slot_meta[SLOT_NUM];
+	u8 recovery_tryremain;
+};
+char *select_slot(void);
+bool is_sotvar(char *cmd);
+void get_slotvar(char *cmd, char *response, size_t chars_left);
+void cb_set_active(struct usb_ep *ep, struct usb_request *req);
+const char *get_slot_suffix(void);
+#endif
diff --git a/drivers/usb/gadget/command.c b/drivers/usb/gadget/command.c
new file mode 100644
index 0000000..9693022
--- /dev/null
+++ b/drivers/usb/gadget/command.c
@@ -0,0 +1,158 @@
+/*
+ * Copyright (C) 2015-2016 Freescale Semiconductor, Inc.
+ *
+ * SPDX-License-Identifier:     GPL-2.0+
+ */
+
+#include <common.h>
+#include <g_dnl.h>
+#ifdef CONFIG_FASTBOOT_STORAGE_NAND
+#include <nand.h>
+#endif
+#include "bcb.h"
+
+static char command[32];
+#ifndef CONFIG_FASTBOOT_STORAGE_NAND
+static int read_command(char *command)
+{
+	int ret = 0;
+	char *p_block = NULL;
+	uint offset_in_block = 0;
+	uint blk_size = 0;
+
+	if (command == NULL)
+		return -1;
+
+	ret = rw_block(true, &p_block, &blk_size, NULL, MISC_COMMAND, 32);
+	if (ret) {
+		printf("read_bootctl, rw_block read failed\n");
+		return -1;
+	}
+
+	offset_in_block = MISC_COMMAND%blk_size;
+	memcpy(command, p_block + offset_in_block, 32);
+
+	return 0;
+}
+static int write_command(char *bcb_command)
+{
+	int ret = 0;
+	char *p_block = NULL;
+	uint offset_in_block = 0;
+	uint blk_size = 0;
+
+	if (bcb_command == NULL)
+		return -1;
+
+
+	ret = rw_block(true, &p_block, &blk_size, NULL,  MISC_COMMAND, 32);
+	if (ret) {
+		printf("write_bootctl, rw_block read failed\n");
+		return -1;
+	}
+
+	offset_in_block = MISC_COMMAND%blk_size;
+	memcpy(p_block + offset_in_block, bcb_command, 32);
+
+	ret = rw_block(false, NULL, NULL, p_block, MISC_COMMAND, 32);
+	if (ret) {
+		free(p_block);
+		printf("write_bootctl, rw_block write failed\n");
+		return -1;
+	}
+
+	free(p_block);
+	return 0;
+}
+
+#else
+#define ALIGN_BYTES 64
+#define MISC_PAGES 3
+static int read_command(char *command)
+{
+	char read_cmd[128];
+	char *addr_str;
+	char *nand_str;
+	ulong misc_info_size;
+	nand_info_t *nand = &nand_info[0];
+	if (command == NULL)
+		return -1;
+	memset(read_cmd, 0, 128);
+	misc_info_size = MISC_PAGES * nand->writesize;
+	nand_str = (char *)memalign(ALIGN_BYTES, misc_info_size);
+	sprintf(read_cmd, "nand read 0x%x ${misc_nand_offset} \
+			0x%x", nand_str, misc_info_size);
+	run_command(read_cmd, 0);
+	/* The offset of bootloader_message is 1 PAGE.
+	   The offset of bootloader_message and the size of misc info
+	   need align with user space and recovery.
+	*/
+	addr_str = nand_str + nand->writesize;
+	memcpy(command, (char *)addr_str, 32);
+	free(nand_str);
+	return 0;
+}
+static int write_command(char *command)
+{
+	char cmd[128];
+	char *addr_str;
+	char *nand_str;
+	ulong misc_info_size;
+	nand_info_t *nand = &nand_info[0];
+	if (command == NULL)
+		return -1;
+	memset(cmd, 0, 128);
+	misc_info_size = MISC_PAGES * nand->writesize;
+	nand_str = (char *)memalign(ALIGN_BYTES, misc_info_size);
+	sprintf(cmd, "nand read 0x%x ${misc_nand_offset} \
+			0x%x", nand_str, misc_info_size);
+	run_command(cmd, 0);
+	/* the offset of bootloader_message is 1 PAGE*/
+	addr_str = nand_str +  nand->writesize;
+	memcpy((char *)addr_str, command, 32);
+	/* erase 3 pages which hold BCB struct.*/
+	sprintf(cmd, "nand erase ${misc_nand_offset} 0x%x",nand->erasesize);
+	run_command(cmd, 0);
+	sprintf(cmd, "nand write 0x%x ${misc_nand_offset} 0x%x",nand_str, misc_info_size);
+	run_command(cmd, 0);
+	free(nand_str);
+	return 0;
+}
+#endif
+bool recovery_check_and_clean_command(void)
+{
+	int ret;
+	ret = read_command(command);
+	if (ret < 0) {
+		printf("read command failed\n");
+		return false;
+	}
+	if (!strcmp(command, "boot-recovery")) {
+		memset(command, 0, 32);
+		write_command(command);
+		return true;
+	}
+	return false;
+}
+bool fastboot_check_and_clean_command(void)
+{
+	int ret;
+	ret = read_command(command);
+	if (ret < 0) {
+		printf("read command failed\n");
+		return false;
+	}
+	if (!strcmp(command, "boot-bootloader")) {
+		memset(command, 0, 32);
+		write_command(command);
+		return true;
+	}
+
+	return false;
+}
+void fastboot_enable_command(void)
+{
+	char fastboot_command[32];
+	memcpy(fastboot_command,"boot-bootloader",32);
+	write_command(fastboot_command);
+}
diff --git a/drivers/usb/gadget/f_fastboot.c b/drivers/usb/gadget/f_fastboot.c
index 88c648f..42fd5ac 100644
--- a/drivers/usb/gadget/f_fastboot.c
+++ b/drivers/usb/gadget/f_fastboot.c
@@ -8,6 +8,8 @@
  * Copyright 2014 Linaro, Ltd.
  * Rob Herring <robh@kernel.org>
  *
+ * Copyright (C) 2016 Freescale Semiconductor, Inc.
+ *
  * SPDX-License-Identifier:	GPL-2.0+
  */
 #include <config.h>
@@ -36,8 +38,21 @@
 #endif
 #endif
 
+#ifdef CONFIG_BRILLO_SUPPORT
+#include "bootctrl.h"
+#endif
+#ifdef CONFIG_BCB_SUPPORT
+#include "bcb.h"
+#endif
 #define FASTBOOT_VERSION		"0.4"
 
+#ifdef CONFIG_FASTBOOT_LOCK
+#include "fastboot_lock_unlock.h"
+#define FASTBOOT_VAR_SECURE "yes"
+#define FASTBOOT_VAR_YES    "yes"
+#define FASTBOOT_VAR_NO     "no"
+#endif
+
 #define FASTBOOT_INTERFACE_CLASS	0xff
 #define FASTBOOT_INTERFACE_SUB_CLASS	0x42
 #define FASTBOOT_INTERFACE_PROTOCOL	0x03
@@ -155,13 +170,19 @@ static struct usb_gadget_strings *fastboot_strings[] = {
 
 /*pentry index internally*/
 enum {
-    PTN_MBR_INDEX = 0,
-    PTN_BOOTLOADER_INDEX,
-    PTN_KERNEL_INDEX,
-    PTN_URAMDISK_INDEX,
-    PTN_SYSTEM_INDEX,
-    PTN_RECOVERY_INDEX,
-    PTN_DATA_INDEX
+	PTN_MBR_INDEX = 0,
+	PTN_BOOTLOADER_INDEX,
+	PTN_KERNEL_INDEX,
+	PTN_URAMDISK_INDEX,
+	PTN_SYSTEM_INDEX,
+	PTN_RECOVERY_INDEX,
+	PTN_DATA_INDEX,
+#ifdef CONFIG_BRILLO_SUPPORT
+	PTN_KERNEL_B_INDEX,
+	PTN_SYSTEM_B_INDEX,
+	PTN_MISC_INDEX,
+#endif
+	PTN_NUM
 };
 
 static unsigned int download_bytes_unpadded;
@@ -811,10 +832,19 @@ static void process_flash_sata(const char *cmdbuf, char *response)
 #if defined(CONFIG_FASTBOOT_STORAGE_MMC)
 static int is_sparse_partition(struct fastboot_ptentry *ptn)
 {
+#ifdef CONFIG_BRILLO_SUPPORT
+	if (ptn && (!strncmp(ptn->name, FASTBOOT_PARTITION_SYSTEM_A,
+			     strlen(FASTBOOT_PARTITION_SYSTEM_A)) ||
+	    !strncmp(ptn->name, FASTBOOT_PARTITION_SYSTEM_B,
+	    strlen(FASTBOOT_PARTITION_SYSTEM_B)) ||
+	    !strncmp(ptn->name, FASTBOOT_PARTITION_DATA,
+	    strlen(FASTBOOT_PARTITION_DATA)))) {
+#else
 	 if (ptn && (!strncmp(ptn->name,
 				 FASTBOOT_PARTITION_SYSTEM, strlen(FASTBOOT_PARTITION_SYSTEM))
 				 || !strncmp(ptn->name,
 				 FASTBOOT_PARTITION_DATA, strlen(FASTBOOT_PARTITION_DATA)))) {
+#endif
 		printf("support sparse flash partition for %s\n", ptn->name);
 		return 1;
 	 } else
@@ -993,6 +1023,7 @@ static int rx_process_erase(const char *cmdbuf, char *response)
 	return 0;
 #else
 	printf("Not support erase command for EMMC\n");
+	sprintf(response, "OKAY");
 	return -1;
 #endif
 
@@ -1078,6 +1109,9 @@ static int _fastboot_setup_dev(void)
 		} else if (!strncmp(fastboot_env, "mmc", 3)) {
 			fastboot_devinfo.type = DEV_MMC;
 			fastboot_devinfo.dev_id = _fastboot_get_mmc_no(fastboot_env);
+#ifdef CONFIG_BCB_SUPPORT
+			set_mmc_id(fastboot_devinfo.dev_id);
+#endif
 		}
 	} else {
 		return 1;
@@ -1097,11 +1131,13 @@ static int _fastboot_parts_add_ptable_entry(int ptable_index,
 				      int mmc_dos_partition_index,
 				      int mmc_partition_index,
 				      const char *name,
+				      const char *fstype,
 				      block_dev_desc_t *dev_desc,
 				      struct fastboot_ptentry *ptable)
 {
 	disk_partition_t info;
 	strcpy(ptable[ptable_index].name, name);
+	strcpy(ptable[ptable_index].fstype, fstype);
 
 	if (get_partition_info(dev_desc,
 			       mmc_dos_partition_index, &info)) {
@@ -1131,7 +1167,7 @@ static int _fastboot_parts_load_from_ptable(void)
 
 	struct mmc *mmc;
 	block_dev_desc_t *dev_desc;
-	struct fastboot_ptentry ptable[PTN_DATA_INDEX + 1];
+	struct fastboot_ptentry ptable[PTN_NUM];
 
 	/* sata case in env */
 	if (fastboot_devinfo.type == DEV_SATA) {
@@ -1178,7 +1214,7 @@ static int _fastboot_parts_load_from_ptable(void)
 	}
 
 	memset((char *)ptable, 0,
-		    sizeof(struct fastboot_ptentry) * (PTN_DATA_INDEX + 1));
+		    sizeof(struct fastboot_ptentry) * (PTN_NUM));
 	/* MBR */
 	strcpy(ptable[PTN_MBR_INDEX].name, "mbr");
 	ptable[PTN_MBR_INDEX].start = ANDROID_MBR_OFFSET / dev_desc->blksz;
@@ -1192,24 +1228,86 @@ static int _fastboot_parts_load_from_ptable(void)
 				 ANDROID_BOOTLOADER_SIZE / dev_desc->blksz;
 	ptable[PTN_BOOTLOADER_INDEX].partition_id = boot_partition;
 
+#ifdef CONFIG_BRILLO_SUPPORT
 	_fastboot_parts_add_ptable_entry(PTN_KERNEL_INDEX,
-				   CONFIG_ANDROID_BOOT_PARTITION_MMC,
-				   user_partition,
-				   FASTBOOT_PARTITION_BOOT , dev_desc, ptable);
+					 CONFIG_ANDROID_BOOT_PARTITION_MMC,
+					 user_partition,
+					 FASTBOOT_PARTITION_BOOT_A,
+					 FASTBOOT_PARTITION_BOOT_FS,
+					 dev_desc, ptable);
+
 	_fastboot_parts_add_ptable_entry(PTN_RECOVERY_INDEX,
-				   CONFIG_ANDROID_RECOVERY_PARTITION_MMC,
-				   user_partition,
-				   FASTBOOT_PARTITION_RECOVERY, dev_desc, ptable);
+					 CONFIG_ANDROID_RECOVERY_PARTITION_MMC,
+					 user_partition,
+					 FASTBOOT_PARTITION_RECOVERY,
+					 FASTBOOT_PARTITION_RECOVERY_FS,
+					 dev_desc, ptable);
+
 	_fastboot_parts_add_ptable_entry(PTN_SYSTEM_INDEX,
-				   CONFIG_ANDROID_SYSTEM_PARTITION_MMC,
-				   user_partition,
-				   FASTBOOT_PARTITION_SYSTEM, dev_desc, ptable);
+					 CONFIG_ANDROID_SYSTEM_PARTITION_MMC,
+					 user_partition,
+					 FASTBOOT_PARTITION_SYSTEM_A,
+					 FASTBOOT_PARTITION_SYSTEM_FS,
+					 dev_desc, ptable);
+
 	_fastboot_parts_add_ptable_entry(PTN_DATA_INDEX,
-				   CONFIG_ANDROID_DATA_PARTITION_MMC,
-				   user_partition,
-				   FASTBOOT_PARTITION_DATA, dev_desc, ptable);
+					 CONFIG_ANDROID_DATA_PARTITION_MMC,
+					 user_partition,
+					 FASTBOOT_PARTITION_DATA,
+					 FASTBOOT_PARTITION_DATA_FS,
+					 dev_desc, ptable);
+
+	 _fastboot_parts_add_ptable_entry(PTN_KERNEL_B_INDEX,
+					  CONFIG_ANDROID_BOOT_B_PARTITION_MMC,
+					  user_partition,
+					  FASTBOOT_PARTITION_BOOT_B,
+					 FASTBOOT_PARTITION_BOOT_FS,
+					  dev_desc, ptable);
+
+	_fastboot_parts_add_ptable_entry(PTN_SYSTEM_B_INDEX,
+					 CONFIG_ANDROID_SYSTEM_B_PARTITION_MMC,
+					 user_partition,
+					 FASTBOOT_PARTITION_SYSTEM_B,
+					 FASTBOOT_PARTITION_SYSTEM_FS,
+					 dev_desc, ptable);
+
+	_fastboot_parts_add_ptable_entry(PTN_MISC_INDEX,
+					 CONFIG_ANDROID_MISC_PARTITION_MMC,
+					 user_partition,
+					 FASTBOOT_PARTITION_MISC,
+					 FASTBOOT_PARTITION_MISC_FS,
+					 dev_desc, ptable);
+#else
+	_fastboot_parts_add_ptable_entry(PTN_KERNEL_INDEX,
+					 CONFIG_ANDROID_BOOT_PARTITION_MMC,
+					 user_partition,
+					 FASTBOOT_PARTITION_BOOT,
+					 FASTBOOT_PARTITION_BOOT_FS,
+					 dev_desc, ptable);
+
+	_fastboot_parts_add_ptable_entry(PTN_RECOVERY_INDEX,
+					 CONFIG_ANDROID_RECOVERY_PARTITION_MMC,
+					 user_partition,
+					 FASTBOOT_PARTITION_RECOVERY,
+					 FASTBOOT_PARTITION_RECOVERY_FS,
+					 dev_desc, ptable);
 
-	for (i = 0; i <= PTN_DATA_INDEX; i++)
+	_fastboot_parts_add_ptable_entry(PTN_SYSTEM_INDEX,
+					 CONFIG_ANDROID_SYSTEM_PARTITION_MMC,
+					 user_partition,
+					 FASTBOOT_PARTITION_SYSTEM,
+					 FASTBOOT_PARTITION_SYSTEM_FS,
+					 dev_desc, ptable);
+
+	_fastboot_parts_add_ptable_entry(PTN_DATA_INDEX,
+					 CONFIG_ANDROID_DATA_PARTITION_MMC,
+					 user_partition,
+					 FASTBOOT_PARTITION_DATA,
+					 FASTBOOT_PARTITION_DATA_FS,
+					 dev_desc, ptable);
+#endif
+
+	for (i = 0; i < PTN_NUM; i++)
 		fastboot_flash_add_ptn(&ptable[i]);
 
 	return 0;
@@ -1458,7 +1556,7 @@ void fastboot_setup(void)
 	char serial[17];
 
 	get_board_serial(&serialnr);
-	sprintf(serial, "%u%u", serialnr.high, serialnr.low);
+	sprintf(serial, "%08x%08x", serialnr.high, serialnr.low);
 	g_dnl_set_serialnumber(serial);
 
 	/*execute board relevant initilizations for preparing fastboot */
@@ -1467,21 +1565,21 @@ void fastboot_setup(void)
 	/*get the fastboot dev*/
 	_fastboot_setup_dev();
 
+	/*load partitions information for the fastboot dev*/
+	_fastboot_load_partitions();
+
 	/*check if we need to setup recovery*/
 #ifdef CONFIG_ANDROID_RECOVERY
-    check_recovery_mode();
+	check_recovery_mode();
 #endif
 
-	/*load partitions information for the fastboot dev*/
-	_fastboot_load_partitions();
-
 	parameters_setup();
 }
 
 /* export to lib_arm/board.c */
 void check_fastboot(void)
 {
-	if (fastboot_check_and_clean_flag())
+	if (fastboot_check_and_clean_command())
 		run_command("fastboot", 0);
 }
 
@@ -1553,7 +1651,16 @@ int do_boota(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
 
 	if (argc > 2)
 		ptn = argv[2];
-
+#ifdef CONFIG_BRILLO_SUPPORT
+	else {
+		ptn = select_slot();
+		if (ptn == NULL) {
+			printf("no valid slot found, enter to recovery\n");
+			ptn = "recovery";
+		}
+		printf("use slot %s\n", ptn);
+	}
+#endif
 	if (mmcc != -1) {
 #ifdef CONFIG_MMC
 		struct fastboot_ptentry *pte;
@@ -1634,18 +1741,41 @@ int do_boota(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
 
 		addr = load_addr;
 
+#ifdef CONFIG_FASTBOOT_LOCK
+		int verifyresult = -1;
+#endif
 #ifdef CONFIG_SECURE_BOOT
 		extern uint32_t authenticate_image(uint32_t ddr_start,
 				uint32_t image_size);
 
 		if (authenticate_image(load_addr, image_size)) {
 			printf("Authenticate OK\n");
+#ifdef CONFIG_FASTBOOT_LOCK
+			verifyresult = 0;
+#endif
 		} else {
 			printf("Authenticate image Fail, Please check\n\n");
+
+		/* For Android if the verify not passed we continue the boot process */
+#ifdef CONFIG_FASTBOOT_LOCK
+#ifndef CONFIG_ANDROID_SUPPORT
 			return 1;
+#endif
+			verifyresult = 1;
+#endif
 		}
 #endif /*CONFIG_SECURE_BOOT*/
 
+#ifdef CONFIG_FASTBOOT_LOCK
+		int lock_status = fastboot_get_lock_stat();
+		if (lock_status == FASTBOOT_LOCK_ERROR) {
+		    printf("In boota get fastboot lock status error. Set lock status\n");
+		    fastboot_set_lock_stat(FASTBOOT_LOCK);
+		}
+		display_lock(fastboot_get_lock_stat(), verifyresult);
+#endif
+
+
 		sector = pte->start + (hdr->page_size / 512);
 		sector += ALIGN(hdr->kernel_size, hdr->page_size) / 512;
 		if (mmc->block_dev.block_read(mmcc, sector,
@@ -1997,7 +2127,7 @@ static int fastboot_tx_write(const char *buffer, unsigned int buffer_size)
 	return 0;
 }
 
-static int fastboot_tx_write_str(const char *buffer)
+int fastboot_tx_write_str(const char *buffer)
 {
 	return fastboot_tx_write(buffer, strlen(buffer));
 }
@@ -2020,6 +2150,20 @@ static int strcmp_l1(const char *s1, const char *s2)
 	return strncmp(s1, s2, strlen(s1));
 }
 
+static int get_block_size() {
+	int mmc_no = 0;
+	block_dev_desc_t *dev_desc;
+	mmc_no = fastboot_devinfo.dev_id;
+
+	dev_desc = get_dev("mmc", mmc_no);
+	if (NULL == dev_desc) {
+		printf("** Block device MMC %d not supported\n",
+			mmc_no);
+		return 0;
+	}
+	return dev_desc->blksz;
+}
+
 static void cb_getvar(struct usb_ep *ep, struct usb_request *req)
 {
 	char *cmd = req->buf;
@@ -2037,10 +2181,58 @@ static void cb_getvar(struct usb_ep *ep, struct usb_request *req)
 		return;
 	}
 
-	if (!strcmp_l1("version", cmd)) {
+#ifdef CONFIG_BRILLO_SUPPORT
+	if (is_sotvar(cmd)) {
+		get_slotvar(cmd, response, chars_left);
+		fastboot_tx_write_str(response);
+		return;
+	}
+#endif
+	char *str;
+	if (str = strstr(cmd, "partition-size:")) {
+		str+=strlen("partition-size:");
+		struct fastboot_ptentry* fb_part;
+		fb_part = fastboot_flash_find_ptn(str);
+		if (!fb_part)
+			strcpy(response, "FAILWrong partition name.");
+		else {
+			char var[32] = {0};
+			sprintf(var, "OKAY0x%016x", fb_part->length * get_block_size());
+			strcpy(response, var);
+		}
+	} else if (str = strstr(cmd, "partition-type:")) {
+		str+=strlen("partition-type:");
+		struct fastboot_ptentry* fb_part;
+		fb_part = fastboot_flash_find_ptn(str);
+		if (!fb_part)
+			strcpy(response, "FAILWrong partition name.");
+		else {
+			char var[32] = {0};
+			sprintf(var, "OKAY%s", fb_part->fstype);
+			strcpy(response, var);
+		}
+	} else if (!strcmp_l1("all", cmd)) {
+		strcpy(response, "OKAY");
+	} else if (!strcmp_l1("version-baseband", cmd)) {
+		strcpy(response, "OKAYN/A");
+	} else if (!strcmp_l1("version-bootloader", cmd)) {
+		char var[512] = {0};
+		sprintf(var, "OKAY%s", U_BOOT_VERSION);
+		strcpy(response, var);
+	} else if (!strcmp_l1("version", cmd)) {
 		strncat(response, FASTBOOT_VERSION, chars_left);
+	} else if (!strcmp_l1("battery-voltage", cmd)) {
+		strcpy(response, "OKAY0mV");
+	} else if (!strcmp_l1("battery-soc-ok", cmd)) {
+		strcpy(response, "OKAYyes");
+	} else if (!strcmp_l1("variant", cmd)) {
+		strcpy(response, "OKAY");
+	} else if (!strcmp_l1("off-mode-charge", cmd)) {
+		strcpy(response, "OKAY1");
 	} else if (!strcmp_l1("bootloader-version", cmd)) {
-		strncat(response, U_BOOT_VERSION, chars_left);
+		char var[512] = {0};
+		sprintf(var, "OKAY%s", U_BOOT_VERSION);
+		strcpy(response, var);
 	} else if (!strcmp_l1("downloadsize", cmd) ||
 		!strcmp_l1("max-download-size", cmd)) {
 		char str_num[12];
@@ -2053,9 +2245,22 @@ static void cb_getvar(struct usb_ep *ep, struct usb_request *req)
 			strncat(response, s, chars_left);
 		else
 			strcpy(response, "FAILValue not set");
-	} else if (!strcmp_l1("partition-type", cmd)) {
-		strcpy(response, "FAILVariable not implemented");
-	} else {
+	} else if (!strcmp_l1("product", cmd)) {
+		strncat(response, "Freescale i.MX", chars_left);
+	}
+#ifdef CONFIG_FASTBOOT_LOCK
+	else if (!strcmp_l1("secure", cmd)) {
+		strncat(response, FASTBOOT_VAR_SECURE, chars_left);
+	} else if (!strcmp_l1("unlocked",cmd)) {
+		int status = fastboot_get_lock_stat();
+		if (status == FASTBOOT_UNLOCK) {
+			strncat(response, FASTBOOT_VAR_YES, chars_left);
+		} else {
+			strncat(response, FASTBOOT_VAR_NO, chars_left);
+		}
+	}
+#endif
+	else {
 		error("unknown variable: %s\n", cmd);
 		strcpy(response, "FAILVariable not implemented");
 	}
@@ -2234,6 +2439,107 @@ static void cb_continue(struct usb_ep *ep, struct usb_request *req)
 	fastboot_tx_write_str("OKAY");
 }
 
+#ifdef CONFIG_FASTBOOT_LOCK
+
+int do_lock_status(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[]) {
+	int status = fastboot_get_lock_stat();
+	if (status != FASTBOOT_LOCK_ERROR) {
+		if (status == FASTBOOT_LOCK)
+			printf("fastboot lock status: locked.\n");
+		else
+			printf("fastboot lock status: unlocked.\n");
+	} else
+		printf("fastboot lock status error!\n");
+
+	display_lock(status, -1);
+
+	return 0;
+
+}
+
+U_BOOT_CMD(
+	lock_status, 2, 1, do_lock_status,
+	"lock_status",
+	"lock_status");
+
+static void cb_flashing(struct usb_ep *ep, struct usb_request *req)
+{
+	char *cmd = req->buf;
+	char response[RESPONSE_LEN];
+	unsigned char len = strlen(cmd);
+	int status;
+	if (!strncmp(cmd + len - 15, "unlock_critical", 15)) {
+		strcpy(response, "OKAY");
+	} else if (!strncmp(cmd + len - 13, "lock_critical", 13)) {
+		strcpy(response, "OKAY");
+	} else if (!strncmp(cmd + len - 6, "unlock", 6)) {
+		printf("flashing unlock.\n");
+		status = do_fastboot_unlock();
+		if (status >= 0)
+			strcpy(response, "OKAY");
+		else
+			strcpy(response, "FAIL unlock device failed.");
+	} else if (!strncmp(cmd + len - 4, "lock", 4)) {
+		printf("flashing lock.\n");
+		status = do_fastboot_lock();
+		if (status >= 0)
+			strcpy(response, "OKAY");
+		else
+			strcpy(response, "FAIL lock device failed.");
+	} else {
+		printf("Unknown flashing command:%s\n", cmd);
+		strcpy(response, "FAIL command not defined");
+	}
+	fastboot_tx_write_str(response);
+}
+
+int do_fastboot_unlock() {
+	int status;
+	if (fastboot_lock_enable() == FASTBOOT_UL_ENABLE) {
+		printf("It is able to unlock device. %d\n",fastboot_lock_enable());
+		status = fastboot_get_lock_stat();
+		if (status == FASTBOOT_UNLOCK) {
+			printf("The device is already unlocked\n");
+			return 1;
+		}
+		status = fastboot_set_lock_stat(FASTBOOT_UNLOCK);
+		if (status < 0)
+			return status;
+
+		printf("Start /data wipe process....\n");
+		fastboot_wipe_data_partition();
+		printf("Wipe /data completed.\n");
+
+	} else {
+		printf("It is not able to unlock device.");
+		return -1;
+	}
+
+	return status;
+}
+
+int do_fastboot_lock() {
+	int status;
+	status = fastboot_get_lock_stat();
+	if (status == FASTBOOT_LOCK) {
+		printf("The device is already locked\n");
+		return 1;
+	}
+	status = fastboot_set_lock_stat(FASTBOOT_LOCK);
+	if (status < 0)
+		return status;
+
+	printf("Start /data wipe process....\n");
+	fastboot_wipe_data_partition();
+	printf("Wipe /data completed.\n");
+
+	return status;
+
+}
+
+
+#endif
+
 #ifdef CONFIG_FASTBOOT_FLASH
 static void cb_flash(struct usb_ep *ep, struct usb_request *req)
 {
@@ -2247,6 +2553,25 @@ static void cb_flash(struct usb_ep *ep, struct usb_request *req)
 		return;
 	}
 
+#ifdef CONFIG_FASTBOOT_LOCK
+	int status;
+	status = fastboot_get_lock_stat();
+
+	if (status == FASTBOOT_LOCK) {
+		error("device is LOCKed!\n");
+		strcpy(response, "FAIL device is locked.");
+		fastboot_tx_write_str(response);
+		return;
+
+	} else if (status == FASTBOOT_LOCK_ERROR) {
+		error("write lock status into device!\n");
+		fastboot_set_lock_stat(FASTBOOT_LOCK);
+		strcpy(response, "FAIL device is locked.");
+		fastboot_tx_write_str(response);
+		return;
+	}
+#endif
+
 	strcpy(response, "FAILno flash device defined");
 
 #ifdef CONFIG_FSL_FASTBOOT
@@ -2315,7 +2640,7 @@ static void cb_reboot_bootloader(struct usb_ep *ep, struct usb_request *req)
 	fastboot_tx_write_str("OKAY");
 
 	udelay(1000000);
-	fastboot_enable_flag();
+	fastboot_enable_command();
 	do_reset(NULL, 0, 0, NULL);
 }
 #endif
@@ -2348,6 +2673,12 @@ static const struct cmd_dispatch_info cmd_dispatch_info[] = {
 		.cmd = "continue",
 		.cb = cb_continue,
 	},
+#ifdef CONFIG_FASTBOOT_LOCK
+	{
+		.cmd = "flashing",
+		.cb = cb_flashing,
+	},
+#endif
 #ifdef CONFIG_FASTBOOT_FLASH
 	{
 		.cmd = "flash",
@@ -2357,10 +2688,18 @@ static const struct cmd_dispatch_info cmd_dispatch_info[] = {
 		.cb = cb_erase,
 	},
 #endif
+#ifdef CONFIG_FASTBOOT_LOCK
 	{
 		.cmd = "oem",
-		.cb = cb_oem,
+		.cb = cb_flashing,
 	},
+#endif
+#ifdef CONFIG_BRILLO_SUPPORT
+	{
+		.cmd = "set_active",
+		.cb = cb_set_active,
+	},
+#endif
 };
 
 static void rx_handler_command(struct usb_ep *ep, struct usb_request *req)
diff --git a/drivers/usb/gadget/fastboot_lock_unlock.c b/drivers/usb/gadget/fastboot_lock_unlock.c
new file mode 100644
index 0000000..25f4660
--- /dev/null
+++ b/drivers/usb/gadget/fastboot_lock_unlock.c
@@ -0,0 +1,359 @@
+/*
+ * Copyright (c) 2016, Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * o Redistributions of source code must retain the above copyright notice, this list
+ *   of conditions and the following disclaimer.
+ *
+ * o Redistributions in binary form must reproduce the above copyright notice, this
+ *   list of conditions and the following disclaimer in the documentation and/or
+ *   other materials provided with the distribution.
+ *
+ * o Neither the name of Freescale Semiconductor, Inc. nor the names of its
+ *   contributors may be used to endorse or promote products derived from this
+ *   software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
+ * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include <fsl_fastboot.h>
+#include "fastboot_lock_unlock.h"
+
+#include <common.h>
+#include <linux/types.h>
+#include <part.h>
+#include <ext_common.h>
+#include <stdio_dev.h>
+
+#ifdef FASTBOOT_ENCRYPT_LOCK
+
+#include <hash.h>
+#include <fsl_caam.h>
+
+//Encrypted data is 80bytes length.
+#define ENDATA_LEN 80
+
+#endif
+
+
+#ifndef FASTBOOT_ENCRYPT_LOCK
+
+/*
+ * This will return FASTBOOT_LOCK, FASTBOOT_UNLOCK or FASTBOOT_ERROR
+ */
+inline unsigned char decrypt_lock_store(unsigned char* bdata) {
+	return *bdata;
+}
+
+inline void encrypt_lock_store(unsigned char lock, unsigned char* bdata) {
+	*bdata  = lock;
+}
+#else
+
+int sha1sum(unsigned char* data, int len, unsigned char* output) {
+	struct hash_algo *algo;
+	void *buf;
+	if (hash_lookup_algo("sha1", &algo)) {
+		printf("error in lookup sha1 algo!\n");
+		return -1;
+	}
+	buf = map_sysmem(data, len);
+	algo->hash_func_ws(buf, len, output, algo->chunk_size);
+	unmap_sysmem(buf);
+
+	return algo->digest_size;
+
+}
+
+int generate_salt(unsigned char* salt) {
+	unsigned long time = get_timer(0);
+	return sha1sum(&time, sizeof(unsigned long), salt);
+
+}
+
+unsigned char decrypt_lock_store(unsigned char *bdata) {
+	unsigned char plain_data[ENDATA_LEN];
+	int p = 0, ret;
+
+	caam_open();
+	ret = caam_decap_blob((uint32_t)plain_data, bdata + ENDATA_LEN, ENDATA_LEN);
+	if (ret != 0) {
+		printf("Error during blob decap operation: 0x%x\n",ret);
+		return FASTBOOT_LOCK_ERROR;
+	}
+#ifdef FASTBOOT_LOCK_DEBUG
+	DEBUG("Decrypt data block are:\n \t=======\t\n");
+	for (p = 0; p < ENDATA_LEN; p++) {
+		DEBUG("0x%2x  ", *(bdata + p));
+		if (p % 16 == 0)
+			DEBUG("\n");
+	}
+	DEBUG("\n \t========\t\n");
+	for (p = ENDATA_LEN; p < (ENDATA_LEN + ENDATA_LEN + 48 ); p++) {
+		DEBUG("0x%2x  ", *(bdata + p));
+		if (p % 16 == 0)
+			DEBUG("\n");
+	}
+
+	DEBUG("\n plain text are:\n");
+	for (p = 0; p < ENDATA_LEN; p++) {
+		DEBUG("0x%2x  ", plain_data[p]);
+		if (p % 16 == 0)
+			DEBUG("\n");
+	}
+	DEBUG("\n");
+#endif
+
+	for (p = 0; p < ENDATA_LEN-1; p++) {
+		if (*(bdata+p) != plain_data[p]) {
+			DEBUG("Verify salt in decrypt error on pointer %d\n", p);
+			return FASTBOOT_LOCK_ERROR;
+		}
+	}
+
+	return plain_data[ENDATA_LEN-1];
+}
+
+int encrypt_lock_store(unsigned char lock, unsigned char* bdata) {
+	unsigned int p = 0;
+	int ret;
+	int salt_len = generate_salt(bdata);
+	if (salt_len < 0)
+		return;
+
+    //salt_len cannot be longer than endata block size.
+	if (salt_len >= ENDATA_LEN)
+		salt_len = ENDATA_LEN - 1;
+
+	p = ENDATA_LEN - 1;
+
+	//Set lock value
+	*(bdata + p) = lock;
+
+	caam_open();
+	ret = caam_gen_blob((uint32_t)bdata, (uint32_t)(bdata + ENDATA_LEN), ENDATA_LEN);
+	if (ret != 0) {
+		printf("error in caam_gen_blob:0x%x\n", ret);
+		return -1;
+	}
+
+
+#ifdef FASTBOOT_LOCK_DEBUG
+	int i = 0;
+	DEBUG("encrypt plain_text:\n");
+	for (i = 0; i < ENDATA_LEN; i++) {
+		DEBUG("0x%2x\t", *(bdata+i));
+		if (i % 16 == 0)
+			printf("\n");
+	}
+	printf("\nto:\n");
+	for (i=0; i < ENDATA_LEN + 48; i++) {
+		DEBUG("0x%2x\t", *(bdata + ENDATA_LEN + i));
+		if (i % 16 == 0)
+			printf("\n");
+	}
+	printf("\n");
+
+#endif
+	//protect value
+	*(bdata + p) = 0xff;
+	return 0;
+}
+
+#endif
+
+static char mmc_dev_part[16];
+char* get_mmc_part(int part) {
+	u32 dev_no = mmc_get_env_devno();
+	sprintf(mmc_dev_part,"%x:%x",dev_no, part);
+	return mmc_dev_part;
+}
+
+/*
+ * The enabling value is stored in the last byte of target partition.
+ */
+inline unsigned char lock_enable_parse(unsigned char* bdata) {
+	DEBUG("lock_enable_parse: 0x%x\n", *(bdata + SECTOR_SIZE -1));
+	return *(bdata + SECTOR_SIZE -1);
+}
+
+/*
+ * Set status of the lock&unlock to FSL_FASTBOOT_FB_PART
+ * Currently use the very first Byte of FSL_FASTBOOT_FB_PART
+ * to store the fastboot lock&unlock status
+ */
+int fastboot_set_lock_stat(unsigned char lock) {
+	block_dev_desc_t *fs_dev_desc;
+	disk_partition_t fs_partition;
+	unsigned char *bdata;
+
+	bdata = (unsigned char *)memalign(ALIGN_BYTES, SECTOR_SIZE);
+	memset(bdata, 0, SECTOR_SIZE);
+
+	int status;
+	status = get_device_and_partition(FSL_FASTBOOT_FB_DEV,
+		get_mmc_part(FSL_FASTBOOT_FB_PART_NUM),
+		&fs_dev_desc, &fs_partition, 1);
+	if (status < 0) {
+		printf("%s:error in getdevice partition.\n", __FUNCTION__);
+		return -1;
+	}
+	DEBUG("%s %s partition.start=%d, size=%d\n",FSL_FASTBOOT_FB_DEV,
+		get_mmc_part(FSL_FASTBOOT_FB_PART_NUM), fs_partition.start, fs_partition.size);
+
+	status = encrypt_lock_store(lock, bdata);
+	if (status < 0)
+		return -1;
+	status = fs_dev_desc->block_write(fs_dev_desc->dev, fs_partition.start, 1, bdata);
+	if (!status) {
+		printf("%s:error in block write.\n", __FUNCTION__);
+		return -1;
+	}
+
+
+
+	return 0;
+}
+
+unsigned char fastboot_get_lock_stat() {
+
+	block_dev_desc_t *fs_dev_desc;
+	disk_partition_t fs_partition;
+	unsigned char *bdata;
+
+	bdata = (unsigned char *)memalign(ALIGN_BYTES, SECTOR_SIZE);
+
+	int status;
+	status = get_device_and_partition(FSL_FASTBOOT_FB_DEV,
+		get_mmc_part(FSL_FASTBOOT_FB_PART_NUM),
+		&fs_dev_desc, &fs_partition, 1);
+
+	if (status < 0) {
+		printf("%s:error in getdevice partition.\n", __FUNCTION__);
+		return FASTBOOT_LOCK_ERROR;
+	}
+	DEBUG("%s %s partition.start=%d, size=%d\n",FSL_FASTBOOT_FB_DEV,
+		get_mmc_part(FSL_FASTBOOT_FB_PART_NUM), fs_partition.start, fs_partition.size);
+
+	status = fs_dev_desc->block_read(fs_dev_desc->dev, fs_partition.start, 1, bdata);
+	if (!status) {
+		printf("%s:error in block read.\n", __FUNCTION__);
+		return FASTBOOT_LOCK_ERROR;
+	}
+
+	return decrypt_lock_store(bdata);
+}
+
+
+/* Return the last byte of of FSL_FASTBOOT_PR_DATA
+ * which is managed by PresistDataService
+ */
+
+#ifdef CONFIG_BRILLO_SUPPORT
+//Brillo has no presist data partition
+unsigned char fastboot_lock_enable() {
+	return FASTBOOT_UL_ENABLE;
+}
+#else
+unsigned char fastboot_lock_enable() {
+	block_dev_desc_t *fs_dev_desc;
+	disk_partition_t fs_partition;
+	unsigned char *bdata;
+
+	bdata = (unsigned char *)memalign(ALIGN_BYTES, SECTOR_SIZE);
+
+	int status;
+	status = get_device_and_partition(FSL_FASTBOOT_FB_DEV,
+		get_mmc_part(FSL_FASTBOOT_PR_DATA_PART_NUM),
+		&fs_dev_desc, &fs_partition, 1);
+	if (status < 0) {
+		printf("%s:error in getdevice partition.\n", __FUNCTION__);
+		return FASTBOOT_UL_ERROR;
+	}
+
+    //The data is stored in the last blcok of this partition.
+	lbaint_t target_block = fs_partition.start + fs_partition.size - 1;
+	DEBUG("target_block.start=%d, size=%d target_block=%d\n", fs_partition.start, fs_partition.size, target_block);
+	status = fs_dev_desc->block_read(fs_dev_desc->dev, target_block, 1, bdata);
+	if (!status) {
+		printf("%s: error in block read\n", __FUNCTION__);
+		return FASTBOOT_UL_ERROR;
+	}
+	int i = 0;
+	DEBUG("\n PRIST last sector is:\n");
+	for (i = 0; i < SECTOR_SIZE; i++) {
+		DEBUG("0x%x  ", *(bdata + i));
+		if (i % 32 == 0)
+			DEBUG("\n");
+	}
+	DEBUG("\n");
+	return lock_enable_parse(bdata);
+
+}
+#endif
+
+int display_lock(int lock, int verify) {
+	struct stdio_dev *disp;
+	disp = stdio_get_by_name("vga");
+	if (disp != NULL) {
+		if (lock == FASTBOOT_UNLOCK) {
+			disp->puts(disp, "\n============= NOTICE ============\n");
+			disp->puts(disp,   "|                               |\n");
+			disp->puts(disp,   "|   Your device is NOT locked.  |\n");
+			disp->puts(disp,   "|                               |\n");
+			disp->puts(disp,   "=================================\n");
+		} else {
+			if (verify == -1) {
+				disp->puts(disp, "\n============= NOTICE ============\n");
+				disp->puts(disp,   "|                               |\n");
+				disp->puts(disp,   "| Your device is NOT protected. |\n");
+				disp->puts(disp,   "|                               |\n");
+				disp->puts(disp,   "=================================\n");
+			} else if (verify == 1) {
+				disp->puts(disp, "\n============= NOTICE ============\n");
+				disp->puts(disp,   "|                               |\n");
+				disp->puts(disp,   "|       Boot verify failed!     |\n");
+				disp->puts(disp,   "|                               |\n");
+				disp->puts(disp,   "=================================\n");
+			}
+		}
+		return 0;
+	} else
+		printf("not found VGA disp console.\n");
+
+	return -1;
+
+}
+
+int fastboot_wipe_data_partition() {
+	block_dev_desc_t *fs_dev_desc;
+	disk_partition_t fs_partition;
+	int status;
+	status = get_device_and_partition(FSL_FASTBOOT_FB_DEV,
+		get_mmc_part(FSL_FASTBOOT_DATA_PART_NUM), &fs_dev_desc, &fs_partition, 1);
+	if (status < 0) {
+		printf("error in get device partition for wipe /data\n");
+		return -1;
+	}
+	DEBUG("fs->start=%x, size=%d\n", fs_partition.start, fs_partition.size);
+	status = fs_dev_desc->block_erase(fs_dev_desc->dev, fs_partition.start , fs_partition.size );
+	if (status != fs_partition.size ) {
+		printf("erase not complete\n");
+		return -1;
+	}
+	mdelay(2000);
+
+	return 0;
+}
diff --git a/drivers/usb/gadget/fastboot_lock_unlock.h b/drivers/usb/gadget/fastboot_lock_unlock.h
new file mode 100644
index 0000000..007da57
--- /dev/null
+++ b/drivers/usb/gadget/fastboot_lock_unlock.h
@@ -0,0 +1,68 @@
+/*
+ * Copyright (c) 2016, Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * o Redistributions of source code must retain the above copyright notice, this list
+ *   of conditions and the following disclaimer.
+ *
+ * o Redistributions in binary form must reproduce the above copyright notice, this
+ *   list of conditions and the following disclaimer in the documentation and/or
+ *   other materials provided with the distribution.
+ *
+ * o Neither the name of Freescale Semiconductor, Inc. nor the names of its
+ *   contributors may be used to endorse or promote products derived from this
+ *   software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
+ * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef FASTBOOT_LOCK_UNLOCK_H
+#define FASTBOOT_LOCK_UNLOCK_H
+
+#define ALIGN_BYTES 64 /*armv7 cache line need 64 bytes aligned */
+
+//#define FASTBOOT_LOCK_DEBUG
+#define FASTBOOT_ENCRYPT_LOCK
+
+#ifdef FASTBOOT_LOCK_DEBUG
+#define DEBUG(format, ...) printf(format, ##__VA_ARGS__)
+#else
+#define DEBUG(format, ...)
+#endif
+
+enum {
+	FASTBOOT_UNLOCK,
+	FASTBOOT_LOCK,
+	FASTBOOT_LOCK_ERROR,
+	FASTBOOT_LOCK_NUM
+};
+
+enum {
+	FASTBOOT_UL_DISABLE,
+	FASTBOOT_UL_ENABLE,
+	FASTBOOT_UL_ERROR,
+	FASTBOOT_UL_NUM
+};
+
+unsigned char fastboot_get_lock_stat();
+
+int fastboot_set_lock_stat(unsigned char lock);
+
+int fastboot_wipe_data_partition();
+
+unsigned char fastboot_lock_enable();
+
+int display_lock(int lock, int verify);
+#endif
diff --git a/include/common.h b/include/common.h
index 179392b..e7fefea 100644
--- a/include/common.h
+++ b/include/common.h
@@ -850,6 +850,10 @@ int cpu_disable(int nr);
 int cpu_release(int nr, int argc, char * const argv[]);
 #endif
 
+#ifdef CONFIG_CMD_READ
+int do_raw_read(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[]);
+#endif
+
 /* Define a null map_sysmem() if the architecture doesn't use it */
 # ifndef CONFIG_ARCH_MAP_SYSMEM
 static inline void *map_sysmem(phys_addr_t paddr, unsigned long len)
diff --git a/include/configs/mx6qarm2.h b/include/configs/mx6qarm2.h
index daeca9f..dab4bd6 100644
--- a/include/configs/mx6qarm2.h
+++ b/include/configs/mx6qarm2.h
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2010-2015 Freescale Semiconductor, Inc.
+ * Copyright (C) 2010-2016 Freescale Semiconductor, Inc.
  *
  * Configuration settings for the Freescale i.MX6Q Armadillo2 board.
  *
@@ -28,6 +28,7 @@
 #define CONFIG_DISPLAY_CPUINFO
 #define CONFIG_DISPLAY_BOARDINFO
 
+#include <linux/sizes.h>
 #include <asm/arch/imx-regs.h>
 
 #define CONFIG_CMDLINE_TAG
@@ -91,11 +92,17 @@
 #define CONFIG_LOADADDR			0x12000000
 #define CONFIG_SYS_TEXT_BASE		0x17800000
 
+#if defined(CONFIG_MX6DQ_POP_LPDDR2)
+#define CONFIG_DEFAULT_FDT_FILE "imx6q-pop-arm2.dtb"
+#else
+#define CONFIG_DEFAULT_FDT_FILE "imx6q-arm2.dtb"
+#endif
+
 #define CONFIG_EXTRA_ENV_SETTINGS \
 	"script=boot.scr\0" \
 	"image=zImage\0" \
 	"console=ttymxc3\0" \
-	"fdt_file=imx6q-arm2.dtb\0" \
+	"fdt_file=" CONFIG_DEFAULT_FDT_FILE "\0" \
 	"fdt_addr=0x18000000\0" \
 	"fdt_high=0xffffffff\0" \
 	"initrd_high=0xffffffff\0" \
@@ -189,7 +196,13 @@
 #define CONFIG_CMDLINE_EDITING
 
 /* Physical Memory Map */
+#if defined(CONFIG_MX6DQ_POP_LPDDR2)
+#define CONFIG_NR_DRAM_BANKS		2
+#define PHYS_SDRAM_0			MMDC0_ARB_BASE_ADDR
+#define PHYS_SDRAM_1			MMDC1_ARB_BASE_ADDR
+#else
 #define CONFIG_NR_DRAM_BANKS		1
+#endif
 #define PHYS_SDRAM			MMDC0_ARB_BASE_ADDR
 
 #define CONFIG_SYS_SDRAM_BASE		PHYS_SDRAM
@@ -204,7 +217,7 @@
 /* FLASH and environment organization */
 #define CONFIG_SYS_NO_FLASH
 
-#define CONFIG_ENV_OFFSET		(8 * 64 * 1024)
+#define CONFIG_ENV_OFFSET		(12 * SZ_64K)
 #define CONFIG_ENV_SIZE			(8 * 1024)
 #define CONFIG_ENV_IS_IN_MMC
 #define CONFIG_SYS_MMC_ENV_DEV		1
@@ -228,4 +241,37 @@
 #define CONFIG_USB_MAX_CONTROLLER_COUNT	1
 #endif
 
-#endif				/* __CONFIG_H */
+#ifdef CONFIG_MX6DQ_POP_LPDDR2
+/* I2C Configs */
+#define CONFIG_CMD_I2C
+#define CONFIG_SYS_I2C
+#define CONFIG_SYS_I2C_MXC
+#define CONFIG_SYS_I2C_SPEED            100000
+/* MAX7310 configs */
+#define CONFIG_MAX7310_IOEXP
+#define CONFIG_IOEXP_DEVICES_NUM	2
+#define CONFIG_IOEXP_DEV_PINS_NUM	8
+
+#define CONFIG_VIDEO
+#define CONFIG_VIDEO_IPUV3
+#define CONFIG_CFB_CONSOLE
+#define CONFIG_VGA_AS_SINGLE_DEVICE
+#define CONFIG_SYS_CONSOLE_IS_IN_ENV
+#define CONFIG_SYS_CONSOLE_OVERWRITE_ROUTINE
+#define CONFIG_VIDEO_BMP_RLE8
+#define CONFIG_SPLASH_SCREEN
+#define CONFIG_SPLASH_SCREEN_ALIGN
+#define CONFIG_BMP_16BPP
+#define CONFIG_VIDEO_LOGO
+#define CONFIG_VIDEO_BMP_LOGO
+#define CONFIG_IPUV3_CLK 198000000
+#define CONFIG_IMX_HDMI
+#define CONFIG_IMX_VIDEO_SKIP
+
+#endif
+
+#if defined(CONFIG_ANDROID_SUPPORT)
+#include "mx6qarm2_android.h"
+#endif
+
+#endif                         /* __CONFIG_H */
diff --git a/include/configs/mx6qarm2_android.h b/include/configs/mx6qarm2_android.h
new file mode 100644
index 0000000..315b78e
--- /dev/null
+++ b/include/configs/mx6qarm2_android.h
@@ -0,0 +1,83 @@
+/*
+ * Copyright (C) 2013-2016 Freescale Semiconductor, Inc. All Rights Reserved.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#ifndef IMX6Q_ARM2_ANDROID_H
+#define IMX6Q_ARM2_ANDROID_H
+
+#define CONFIG_CI_UDC
+#define CONFIG_USBD_HS
+#define CONFIG_USB_GADGET_DUALSPEED
+
+#define CONFIG_USB_GADGET
+#define CONFIG_CMD_USB_MASS_STORAGE
+#define CONFIG_USB_GADGET_MASS_STORAGE
+#define CONFIG_USBDOWNLOAD_GADGET
+#define CONFIG_USB_GADGET_VBUS_DRAW	2
+
+#define CONFIG_G_DNL_VENDOR_NUM		0x18d1
+#define CONFIG_G_DNL_PRODUCT_NUM	0x0d02
+#define CONFIG_G_DNL_MANUFACTURER	"FSL"
+
+#define CONFIG_CMD_FASTBOOT
+#define CONFIG_CMD_READ
+#define CONFIG_BCB_SUPPORT
+#define CONFIG_ANDROID_BOOT_IMAGE
+#define CONFIG_FASTBOOT_FLASH
+
+/* For NAND we don't support lock/unlock */
+#ifndef CONFIG_SYS_BOOT_NAND
+#define CONFIG_FASTBOOT_LOCK
+#endif
+
+#define FSL_FASTBOOT_FB_DEV "mmc"
+#define FSL_FASTBOOT_DATA_PART_NUM 4
+#define FSL_FASTBOOT_FB_PART_NUM 11
+#define FSL_FASTBOOT_PR_DATA_PART_NUM 12
+
+#define CONFIG_FSL_CAAM_KB
+#define CONFIG_CMD_FSL_CAAM_KB
+#define CONFIG_SHA1
+#define CONFIG_SHA256
+
+#define CONFIG_FSL_FASTBOOT
+#define CONFIG_ANDROID_RECOVERY
+
+#if defined CONFIG_SYS_BOOT_NAND
+#define CONFIG_FASTBOOT_STORAGE_NAND
+#elif defined CONFIG_SYS_BOOT_SATA
+#define CONFIG_FASTBOOT_STORAGE_SATA
+#else
+#define CONFIG_FASTBOOT_STORAGE_MMC
+#endif
+
+#define CONFIG_ANDROID_MAIN_MMC_BUS 2
+#define CONFIG_ANDROID_BOOT_PARTITION_MMC 1
+#define CONFIG_ANDROID_SYSTEM_PARTITION_MMC 5
+#define CONFIG_ANDROID_RECOVERY_PARTITION_MMC 2
+#define CONFIG_ANDROID_CACHE_PARTITION_MMC 6
+#define CONFIG_ANDROID_DATA_PARTITION_MMC 4
+#define CONFIG_ANDROID_MISC_PARTITION_MMC 8
+
+#if defined(CONFIG_FASTBOOT_STORAGE_NAND)
+#define ANDROID_FASTBOOT_NAND_PARTS "16m@64m(boot) 16m@80m(recovery) 810m@96m(android_root)ubifs"
+#endif
+
+#define CONFIG_CMD_BOOTA
+#define CONFIG_SUPPORT_RAW_INITRD
+#define CONFIG_SERIAL_TAG
+
+#undef CONFIG_EXTRA_ENV_SETTINGS
+#undef CONFIG_BOOTCOMMAND
+
+#define CONFIG_EXTRA_ENV_SETTINGS					\
+	"splashpos=m,m\0"	  \
+	"fdt_high=0xffffffff\0"	  \
+	"initrd_high=0xffffffff\0" \
+
+#define CONFIG_USB_FASTBOOT_BUF_ADDR   CONFIG_SYS_LOAD_ADDR
+#define CONFIG_USB_FASTBOOT_BUF_SIZE   0x19000000
+
+#endif /* IMX6Q_ARM2_ANDROID_H */
diff --git a/include/configs/mx6sabre_common.h b/include/configs/mx6sabre_common.h
index 481254f..bf30c62 100644
--- a/include/configs/mx6sabre_common.h
+++ b/include/configs/mx6sabre_common.h
@@ -387,7 +387,7 @@
 #endif
 
 #if defined(CONFIG_ENV_IS_IN_MMC)
-#define CONFIG_ENV_OFFSET		(8 * 64 * 1024)
+#define CONFIG_ENV_OFFSET		(12 * SZ_64K)
 #elif defined(CONFIG_ENV_IS_IN_SPI_FLASH)
 #define CONFIG_ENV_OFFSET              (768 * 1024)
 #define CONFIG_ENV_SECT_SIZE           (64 * 1024)
diff --git a/include/configs/mx6sabreandroid_common.h b/include/configs/mx6sabreandroid_common.h
index d2be182..57a4112 100644
--- a/include/configs/mx6sabreandroid_common.h
+++ b/include/configs/mx6sabreandroid_common.h
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2013-2015 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright (C) 2013-2016 Freescale Semiconductor, Inc. All Rights Reserved.
  *
  * SPDX-License-Identifier:	GPL-2.0+
  */
@@ -22,9 +22,26 @@
 #define CONFIG_G_DNL_MANUFACTURER	"FSL"
 
 #define CONFIG_CMD_FASTBOOT
+#define CONFIG_CMD_READ
+#define CONFIG_BCB_SUPPORT
 #define CONFIG_ANDROID_BOOT_IMAGE
 #define CONFIG_FASTBOOT_FLASH
 
+/* For NAND we don't support lock/unlock */
+#ifndef CONFIG_SYS_BOOT_NAND
+#define CONFIG_FASTBOOT_LOCK
+#endif
+
+#define FSL_FASTBOOT_FB_DEV "mmc"
+#define FSL_FASTBOOT_DATA_PART_NUM 4
+#define FSL_FASTBOOT_FB_PART_NUM 11
+#define FSL_FASTBOOT_PR_DATA_PART_NUM 12
+
+#define CONFIG_FSL_CAAM_KB
+#define CONFIG_CMD_FSL_CAAM_KB
+#define CONFIG_SHA1
+#define CONFIG_SHA256
+
 #define CONFIG_FSL_FASTBOOT
 #define CONFIG_ANDROID_RECOVERY
 
@@ -42,14 +59,16 @@
 #define CONFIG_ANDROID_RECOVERY_PARTITION_MMC 2
 #define CONFIG_ANDROID_CACHE_PARTITION_MMC 6
 #define CONFIG_ANDROID_DATA_PARTITION_MMC 4
+#define CONFIG_ANDROID_MISC_PARTITION_MMC 8
 
 #if defined(CONFIG_FASTBOOT_STORAGE_NAND)
-#define ANDROID_FASTBOOT_NAND_PARTS "16m@64m(boot) 16m@80m(recovery) 810m@96m(android_root)ubifs"
+#define ANDROID_FASTBOOT_NAND_PARTS "16m@64m(boot) 16m@80m(recovery) 1m@96m(misc) 810m@97m(android_root)ubifs"
 #endif
 
 #define CONFIG_CMD_BOOTA
 #define CONFIG_SUPPORT_RAW_INITRD
 #define CONFIG_SERIAL_TAG
+#define CONFIG_RESET_CAUSE
 
 #undef CONFIG_EXTRA_ENV_SETTINGS
 #undef CONFIG_BOOTCOMMAND
@@ -60,6 +79,9 @@
 	"initrd_high=0xffffffff\0" \
 
 #define CONFIG_USB_FASTBOOT_BUF_ADDR   CONFIG_SYS_LOAD_ADDR
+#ifdef CONFIG_FASTBOOT_STORAGE_NAND
+#define CONFIG_USB_FASTBOOT_BUF_SIZE   0x32000000
+#else
 #define CONFIG_USB_FASTBOOT_BUF_SIZE   0x19000000
-
+#endif
 #endif /* MX6_SABRE_ANDROID_COMMON_H */
diff --git a/include/configs/mx6slevk.h b/include/configs/mx6slevk.h
index aabc05c..b58b0c0 100644
--- a/include/configs/mx6slevk.h
+++ b/include/configs/mx6slevk.h
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2013-2015 Freescale Semiconductor, Inc.
+ * Copyright (C) 2013-2016 Freescale Semiconductor, Inc.
  *
  * Configuration settings for the Freescale i.MX6SL EVK board.
  *
@@ -246,7 +246,7 @@
 #define CONFIG_ENV_SPI_MODE             CONFIG_SF_DEFAULT_MODE
 #define CONFIG_ENV_SPI_MAX_HZ           CONFIG_SF_DEFAULT_SPEED
 #else
-#define CONFIG_ENV_OFFSET		(8 * SZ_64K)
+#define CONFIG_ENV_OFFSET		(12 * SZ_64K)
 #define CONFIG_ENV_IS_IN_MMC
 #endif
 
diff --git a/include/configs/mx6slevkandroid.h b/include/configs/mx6slevkandroid.h
index 3c3b2ce..33a3d12 100644
--- a/include/configs/mx6slevkandroid.h
+++ b/include/configs/mx6slevkandroid.h
@@ -1,6 +1,6 @@
 
 /*
- * Copyright (C) 2013-2015 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright (C) 2013-2016 Freescale Semiconductor, Inc. All Rights Reserved.
  *
  * SPDX-License-Identifier:	GPL-2.0+
  */
@@ -25,6 +25,8 @@
 #define CONFIG_G_DNL_MANUFACTURER	"FSL"
 
 #define CONFIG_CMD_FASTBOOT
+#define CONFIG_CMD_READ
+#define CONFIG_BCB_SUPPORT
 #define CONFIG_ANDROID_BOOT_IMAGE
 #define CONFIG_FASTBOOT_FLASH
 
@@ -39,10 +41,12 @@
 #define CONFIG_ANDROID_RECOVERY_PARTITION_MMC 2
 #define CONFIG_ANDROID_CACHE_PARTITION_MMC 6
 #define CONFIG_ANDROID_DATA_PARTITION_MMC 4
+#define CONFIG_ANDROID_MISC_PARTITION_MMC 8
 
 #define CONFIG_CMD_BOOTA
 #define CONFIG_SUPPORT_RAW_INITRD
 #define CONFIG_SERIAL_TAG
+#define CONFIG_RESET_CAUSE
 
 /*keyboard mapping*/
 #define CONFIG_VOL_DOWN_KEY     KEY_BACK
@@ -68,6 +72,9 @@
 	"initrd_high=0xffffffff\0" \
 
 #define CONFIG_USB_FASTBOOT_BUF_ADDR   CONFIG_SYS_LOAD_ADDR
+#ifdef CONFIG_FASTBOOT_STORAGE_NAND
+#define CONFIG_USB_FASTBOOT_BUF_SIZE   0x32000000
+#else
 #define CONFIG_USB_FASTBOOT_BUF_SIZE   0x19000000
-
+#endif
 #endif
diff --git a/include/configs/mx6sx_arm2.h b/include/configs/mx6sx_arm2.h
index 9c4484c..b141ae3 100644
--- a/include/configs/mx6sx_arm2.h
+++ b/include/configs/mx6sx_arm2.h
@@ -381,7 +381,7 @@
 
 
 #if defined(CONFIG_ENV_IS_IN_MMC)
-#define CONFIG_ENV_OFFSET		(8 * SZ_64K)
+#define CONFIG_ENV_OFFSET		(12 * SZ_64K)
 #elif defined(CONFIG_ENV_IS_IN_SPI_FLASH)
 #define CONFIG_ENV_OFFSET		(768 * 1024)
 #define CONFIG_ENV_SECT_SIZE		(64 * 1024)
diff --git a/include/configs/mx6sxsabreauto.h b/include/configs/mx6sxsabreauto.h
index 2032508..aa36255 100644
--- a/include/configs/mx6sxsabreauto.h
+++ b/include/configs/mx6sxsabreauto.h
@@ -368,7 +368,7 @@
 #define CONFIG_MMCROOT			"/dev/mmcblk2p2"  /* USDHC3 */
 
 #if defined(CONFIG_ENV_IS_IN_MMC)
-#define CONFIG_ENV_OFFSET		(8 * SZ_64K)
+#define CONFIG_ENV_OFFSET		(12 * SZ_64K)
 #elif defined(CONFIG_ENV_IS_IN_SPI_FLASH)
 #define CONFIG_ENV_OFFSET		(768 * 1024)
 #define CONFIG_ENV_SECT_SIZE		(64 * 1024)
diff --git a/include/configs/mx6sxsabreautoandroid.h b/include/configs/mx6sxsabreautoandroid.h
index e21c456..c187c31 100644
--- a/include/configs/mx6sxsabreautoandroid.h
+++ b/include/configs/mx6sxsabreautoandroid.h
@@ -1,6 +1,6 @@
 
 /*
- * Copyright (C) 2014-2015 Freescale Semiconductor, Inc.
+ * Copyright (C) 2014-2016 Freescale Semiconductor, Inc.
  *
  * SPDX-License-Identifier:	GPL-2.0+
  */
@@ -23,9 +23,26 @@
 #define CONFIG_G_DNL_MANUFACTURER	"FSL"
 
 #define CONFIG_CMD_FASTBOOT
+#define CONFIG_CMD_READ
+#define CONFIG_BCB_SUPPORT
 #define CONFIG_ANDROID_BOOT_IMAGE
 #define CONFIG_FASTBOOT_FLASH
 
+/* For NAND we don't support lock/unlock */
+#ifndef CONFIG_SYS_BOOT_NAND
+#define CONFIG_FASTBOOT_LOCK
+#endif
+
+#define FSL_FASTBOOT_FB_DEV "mmc"
+#define FSL_FASTBOOT_DATA_PART_NUM 4
+#define FSL_FASTBOOT_FB_PART_NUM 11
+#define FSL_FASTBOOT_PR_DATA_PART_NUM 12
+
+#define CONFIG_FSL_CAAM_KB
+#define CONFIG_CMD_FSL_CAAM_KB
+#define CONFIG_SHA1
+#define CONFIG_SHA256
+
 #define CONFIG_FSL_FASTBOOT
 #define CONFIG_ANDROID_RECOVERY
 
@@ -36,7 +53,7 @@
 #endif
 
 #if defined(CONFIG_FASTBOOT_STORAGE_NAND)
-#define ANDROID_FASTBOOT_NAND_PARTS "16m@64m(boot) 16m@80m(recovery) 810m@96m(android_root)ubifs"
+#define ANDROID_FASTBOOT_NAND_PARTS "16m@64m(boot) 16m@80m(recovery) 1m@96m(misc) 810m@97m(android_root)ubifs"
 #endif
 
 #define CONFIG_ANDROID_MAIN_MMC_BUS 2
@@ -45,10 +62,12 @@
 #define CONFIG_ANDROID_RECOVERY_PARTITION_MMC 2
 #define CONFIG_ANDROID_CACHE_PARTITION_MMC 6
 #define CONFIG_ANDROID_DATA_PARTITION_MMC 4
+#define CONFIG_ANDROID_MISC_PARTITION_MMC 8
 
 #define CONFIG_CMD_BOOTA
 #define CONFIG_SUPPORT_RAW_INITRD
 #define CONFIG_SERIAL_TAG
+#define CONFIG_RESET_CAUSE
 
 #undef CONFIG_EXTRA_ENV_SETTINGS
 #undef CONFIG_BOOTCOMMAND
@@ -59,6 +78,9 @@
 	"initrd_high=0xffffffff\0" \
 
 #define CONFIG_USB_FASTBOOT_BUF_ADDR   CONFIG_SYS_LOAD_ADDR
+#ifdef CONFIG_FASTBOOT_STORAGE_NAND
+#define CONFIG_USB_FASTBOOT_BUF_SIZE   0x32000000
+#else
 #define CONFIG_USB_FASTBOOT_BUF_SIZE   0x19000000
-
+#endif
 #endif
diff --git a/include/configs/mx6sxsabresd.h b/include/configs/mx6sxsabresd.h
index ddd7216..f5686d4 100644
--- a/include/configs/mx6sxsabresd.h
+++ b/include/configs/mx6sxsabresd.h
@@ -1,5 +1,5 @@
 /*
- * Copyright 2014-2015 Freescale Semiconductor, Inc.
+ * Copyright 2014-2016 Freescale Semiconductor, Inc.
  *
  * Configuration settings for the Freescale i.MX6SX Sabresd board.
  *
@@ -331,7 +331,7 @@
 #define CONFIG_MMCROOT			"/dev/mmcblk3p2"  /* USDHC4 */
 
 #if defined(CONFIG_ENV_IS_IN_MMC)
-#define CONFIG_ENV_OFFSET		(8 * SZ_64K)
+#define CONFIG_ENV_OFFSET		(12 * SZ_64K)
 #elif defined(CONFIG_ENV_IS_IN_SPI_FLASH)
 #define CONFIG_ENV_OFFSET		(768 * 1024)
 #define CONFIG_ENV_SECT_SIZE		(64 * 1024)
diff --git a/include/configs/mx6sxsabresdandroid.h b/include/configs/mx6sxsabresdandroid.h
index 68f86df..c1f31c6 100644
--- a/include/configs/mx6sxsabresdandroid.h
+++ b/include/configs/mx6sxsabresdandroid.h
@@ -1,6 +1,6 @@
 
 /*
- * Copyright (C) 2014-2015 Freescale Semiconductor, Inc.
+ * Copyright (C) 2014-2016 Freescale Semiconductor, Inc.
  *
  * SPDX-License-Identifier:	GPL-2.0+
  */
@@ -23,9 +23,26 @@
 #define CONFIG_G_DNL_MANUFACTURER	"FSL"
 
 #define CONFIG_CMD_FASTBOOT
+#define CONFIG_CMD_READ
+#define CONFIG_BCB_SUPPORT
 #define CONFIG_ANDROID_BOOT_IMAGE
 #define CONFIG_FASTBOOT_FLASH
 
+/* For NAND we don't support lock/unlock */
+#ifndef CONFIG_SYS_BOOT_NAND
+#define CONFIG_FASTBOOT_LOCK
+#endif
+
+#define FSL_FASTBOOT_FB_DEV "mmc"
+#define FSL_FASTBOOT_DATA_PART_NUM 4
+#define FSL_FASTBOOT_FB_PART_NUM 11
+#define FSL_FASTBOOT_PR_DATA_PART_NUM 12
+
+#define CONFIG_FSL_CAAM_KB
+#define CONFIG_CMD_FSL_CAAM_KB
+#define CONFIG_SHA1
+#define CONFIG_SHA256
+
 #define CONFIG_FSL_FASTBOOT
 #define CONFIG_ANDROID_RECOVERY
 
@@ -37,10 +54,12 @@
 #define CONFIG_ANDROID_RECOVERY_PARTITION_MMC 2
 #define CONFIG_ANDROID_CACHE_PARTITION_MMC 6
 #define CONFIG_ANDROID_DATA_PARTITION_MMC 4
+#define CONFIG_ANDROID_MISC_PARTITION_MMC 8
 
 #define CONFIG_CMD_BOOTA
 #define CONFIG_SUPPORT_RAW_INITRD
 #define CONFIG_SERIAL_TAG
+#define CONFIG_RESET_CAUSE
 
 #undef CONFIG_EXTRA_ENV_SETTINGS
 #undef CONFIG_BOOTCOMMAND
@@ -51,7 +70,10 @@
 	"initrd_high=0xffffffff\0" \
 
 #define CONFIG_USB_FASTBOOT_BUF_ADDR   CONFIG_SYS_LOAD_ADDR
+#ifdef CONFIG_FASTBOOT_STORAGE_NAND
+#define CONFIG_USB_FASTBOOT_BUF_SIZE   0x32000000
+#else
 #define CONFIG_USB_FASTBOOT_BUF_SIZE   0x19000000
-
+#endif
 
 #endif
diff --git a/include/configs/mx6ul_14x14_evk.h b/include/configs/mx6ul_14x14_evk.h
index 72104a1..bb0fc2a 100644
--- a/include/configs/mx6ul_14x14_evk.h
+++ b/include/configs/mx6ul_14x14_evk.h
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2015 Freescale Semiconductor, Inc.
+ * Copyright (C) 2015-2016 Freescale Semiconductor, Inc.
  *
  * Configuration settings for the Freescale i.MX6UL 14x14 EVK board.
  *
@@ -366,7 +366,7 @@
 #endif
 
 #if defined(CONFIG_ENV_IS_IN_MMC)
-#define CONFIG_ENV_OFFSET		(8 * SZ_64K)
+#define CONFIG_ENV_OFFSET		(12 * SZ_64K)
 #elif defined(CONFIG_ENV_IS_IN_SPI_FLASH)
 #define CONFIG_ENV_OFFSET		(768 * 1024)
 #define CONFIG_ENV_SECT_SIZE		(64 * 1024)
@@ -430,4 +430,9 @@
 #include "mx6ul_14x14_evk_android.h"
 #endif
 
+#if defined(CONFIG_BRILLO_SUPPORT)
+#include "mx6ul_14x14_evk_brillo.h"
+#endif
+
+
 #endif
diff --git a/include/configs/mx6ul_14x14_evk_android.h b/include/configs/mx6ul_14x14_evk_android.h
index 9d6a267..71c94e0 100644
--- a/include/configs/mx6ul_14x14_evk_android.h
+++ b/include/configs/mx6ul_14x14_evk_android.h
@@ -1,6 +1,6 @@
 
 /*
- * Copyright (C) 2015 Freescale Semiconductor, Inc.
+ * Copyright (C) 2015-2016 Freescale Semiconductor, Inc.
  *
  * SPDX-License-Identifier:	GPL-2.0+
  */
@@ -23,6 +23,7 @@
 #define CONFIG_G_DNL_MANUFACTURER	"FSL"
 
 #define CONFIG_CMD_FASTBOOT
+#define CONFIG_BCB_SUPPORT
 #define CONFIG_ANDROID_BOOT_IMAGE
 #define CONFIG_FASTBOOT_FLASH
 
diff --git a/include/configs/mx6ul_14x14_evk_brillo.h b/include/configs/mx6ul_14x14_evk_brillo.h
index 9b2f9e1..a91ff04 100644
--- a/include/configs/mx6ul_14x14_evk_brillo.h
+++ b/include/configs/mx6ul_14x14_evk_brillo.h
@@ -1,6 +1,6 @@
 
 /*
- * Copyright (C) 2015 Freescale Semiconductor, Inc.
+ * Copyright (C) 2015-2016 Freescale Semiconductor, Inc.
  *
  * SPDX-License-Identifier:	GPL-2.0+
  */
@@ -10,15 +10,23 @@
 
 #define CONFIG_ANDROID_BOOT_B_PARTITION_MMC 7
 #define CONFIG_ANDROID_SYSTEM_B_PARTITION_MMC 8
-#define CONFIG_ANDROID_SLOTMETA_PARTITION_MMC 9
+#define CONFIG_ANDROID_MISC_PARTITION_MMC 9
 
-
-#define CONFIG_CMD_EXT2
-#define CONFIG_CMD_EXT4
-#define CONFIG_CMD_EXT4_WRITE
 #define CONFIG_CMD_FAT
 #define CONFIG_DOS_PARTITION
 
+#define CONFIG_FASTBOOT_LOCK
+
+#define FSL_FASTBOOT_FB_DEV "mmc"
+#define FSL_FASTBOOT_DATA_PART_NUM 4
+#define FSL_FASTBOOT_FB_PART_NUM 10
+
+#define CONFIG_FSL_CAAM_KB
+#define CONFIG_SHA1
+#define CONFIG_SHA256
+
 #define CONFIG_SYS_BOOTM_LEN 0x1000000
 
+#define CONFIG_CMD_READ
+
 #endif
diff --git a/include/configs/mx6ul_arm2.h b/include/configs/mx6ul_arm2.h
index 23bddca..a465299 100644
--- a/include/configs/mx6ul_arm2.h
+++ b/include/configs/mx6ul_arm2.h
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2015 Freescale Semiconductor, Inc.
+ * Copyright (C) 2015-2016 Freescale Semiconductor, Inc.
  *
  * Configuration settings for the Freescale i.MX6UL ARM2 common.
  *
@@ -14,7 +14,9 @@
 #include "mx6_common.h"
 #include <asm/imx-common/gpio.h>
 
+#ifndef CONFIG_MX6
 #define CONFIG_MX6
+#endif
 #define CONFIG_ROM_UNIFIED_SECTIONS
 #define CONFIG_SYS_GENERIC_BOARD
 #define CONFIG_DISPLAY_CPUINFO
@@ -302,7 +304,7 @@
 #endif
 
 #if defined(CONFIG_ENV_IS_IN_MMC)
-#define CONFIG_ENV_OFFSET		(8 * SZ_64K)
+#define CONFIG_ENV_OFFSET		(12 * SZ_64K)
 #elif defined(CONFIG_ENV_IS_IN_SPI_FLASH)
 #define CONFIG_ENV_OFFSET		(768 * 1024)
 #define CONFIG_ENV_SECT_SIZE		(64 * 1024)
diff --git a/include/configs/mx6ull_ddr3_arm2.h b/include/configs/mx6ull_ddr3_arm2.h
new file mode 100644
index 0000000..6fc969f
--- /dev/null
+++ b/include/configs/mx6ull_ddr3_arm2.h
@@ -0,0 +1,73 @@
+/*
+ * Copyright (C) 2016 Freescale Semiconductor, Inc.
+ *
+ * Configuration settings for the Freescale i.MX6UL 14x14 DDR3 ARM2.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+#ifndef __MX6ULL_DDR3_ARM2_CONFIG_H
+#define __MX6ULL_DDR3_ARM2_CONFIG_H
+
+#define CONFIG_DEFAULT_FDT_FILE  "imx6ull-ddr3-arm2.dtb"
+
+#ifdef CONFIG_SYS_BOOT_QSPI
+#define CONFIG_SYS_USE_QSPI
+#define CONFIG_ENV_IS_IN_SPI_FLASH
+#elif defined CONFIG_SYS_BOOT_SPINOR
+#define CONFIG_SYS_USE_SPINOR
+#define CONFIG_ENV_IS_IN_SPI_FLASH
+#elif defined CONFIG_SYS_BOOT_NAND
+#define CONFIG_SYS_USE_NAND
+#define CONFIG_ENV_IS_IN_NAND
+#else
+#ifndef CONFIG_MX6ULL_DDR3_ARM2_EMMC_REWORK
+#define CONFIG_SYS_USE_QSPI
+#endif
+#define CONFIG_ENV_IS_IN_MMC
+#endif
+
+#define CONFIG_VIDEO
+#define CONFIG_FSL_USDHC
+#define CONFIG_BOOTARGS_CMA_SIZE   ""
+
+#include "mx6ul_arm2.h"
+
+#define PHYS_SDRAM_SIZE			SZ_1G
+
+#ifdef CONFIG_SYS_USE_SPINOR
+#define CONFIG_CMD_SF
+#define CONFIG_SPI_FLASH
+#define CONFIG_SPI_FLASH_STMICRO
+#define CONFIG_MXC_SPI
+#define CONFIG_SF_DEFAULT_BUS  0
+#define CONFIG_SF_DEFAULT_SPEED 20000000
+#define CONFIG_SF_DEFAULT_MODE (SPI_MODE_0)
+#define CONFIG_SF_DEFAULT_CS   0
+#endif
+
+#define CONFIG_CMD_NET
+#ifdef CONFIG_CMD_NET
+#define CONFIG_CMD_PING
+#define CONFIG_CMD_DHCP
+#define CONFIG_CMD_MII
+#define CONFIG_FEC_MXC
+#define CONFIG_MII
+#define CONFIG_FEC_ENET_DEV 1
+
+#if (CONFIG_FEC_ENET_DEV == 0)
+#define IMX_FEC_BASE			ENET_BASE_ADDR
+#define CONFIG_FEC_MXC_PHYADDR          0x1
+#define CONFIG_FEC_XCV_TYPE             RMII
+#elif (CONFIG_FEC_ENET_DEV == 1)
+#define IMX_FEC_BASE			ENET2_BASE_ADDR
+#define CONFIG_FEC_MXC_PHYADDR          0x2
+#define CONFIG_FEC_XCV_TYPE             MII100
+#endif
+#define CONFIG_ETHPRIME                 "FEC"
+
+#define CONFIG_PHYLIB
+#define CONFIG_PHY_MICREL
+#define CONFIG_FEC_DMA_MINALIGN		64
+#endif
+
+#endif
diff --git a/include/configs/mx7d_12x12_ddr3_arm2.h b/include/configs/mx7d_12x12_ddr3_arm2.h
index f65df50..9c0a5df 100644
--- a/include/configs/mx7d_12x12_ddr3_arm2.h
+++ b/include/configs/mx7d_12x12_ddr3_arm2.h
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2015 Freescale Semiconductor, Inc.
+ * Copyright (C) 2015-2016 Freescale Semiconductor, Inc.
  *
  * Configuration settings for the Freescale i.MX7D 12x12 DDR3 ARM2 board.
  *
@@ -50,6 +50,10 @@
 #define CONFIG_SF_DEFAULT_CS   0
 #endif
 
+#define CONFIG_CMD_PING
+#define CONFIG_CMD_DHCP
+#define CONFIG_CMD_NET
+
 #include "mx7d_arm2.h"
 
 #endif
diff --git a/include/configs/mx7d_arm2.h b/include/configs/mx7d_arm2.h
index 70cd1c9..4250740 100644
--- a/include/configs/mx7d_arm2.h
+++ b/include/configs/mx7d_arm2.h
@@ -338,7 +338,7 @@
 #endif
 
 #if defined(CONFIG_ENV_IS_IN_MMC)
-#define CONFIG_ENV_OFFSET		(8 * SZ_64K)
+#define CONFIG_ENV_OFFSET		(12 * SZ_64K)
 #elif defined(CONFIG_ENV_IS_IN_SPI_FLASH)
 #define CONFIG_ENV_OFFSET		(768 * 1024)
 #define CONFIG_ENV_SECT_SIZE		(64 * 1024)
diff --git a/include/configs/mx7dsabresd.h b/include/configs/mx7dsabresd.h
index 9d3a9a0..8e24e9b 100644
--- a/include/configs/mx7dsabresd.h
+++ b/include/configs/mx7dsabresd.h
@@ -366,7 +366,7 @@
 #endif
 
 #if defined(CONFIG_ENV_IS_IN_MMC)
-#define CONFIG_ENV_OFFSET		(8 * SZ_64K)
+#define CONFIG_ENV_OFFSET		(12 * SZ_64K)
 #elif defined(CONFIG_ENV_IS_IN_SPI_FLASH)
 #define CONFIG_ENV_OFFSET		(768 * 1024)
 #define CONFIG_ENV_SECT_SIZE		(64 * 1024)
diff --git a/include/configs/mx7dsabresdandroid.h b/include/configs/mx7dsabresdandroid.h
index 3ced17f..819a338 100644
--- a/include/configs/mx7dsabresdandroid.h
+++ b/include/configs/mx7dsabresdandroid.h
@@ -1,6 +1,6 @@
 
 /*
- * Copyright (C) 2015 Freescale Semiconductor, Inc.
+ * Copyright (C) 2015-2016 Freescale Semiconductor, Inc.
  *
  * SPDX-License-Identifier:	GPL-2.0+
  */
@@ -23,6 +23,8 @@
 #define CONFIG_G_DNL_MANUFACTURER	"FSL"
 
 #define CONFIG_CMD_FASTBOOT
+#define CONFIG_CMD_READ
+#define CONFIG_BCB_SUPPORT
 #define CONFIG_ANDROID_BOOT_IMAGE
 #define CONFIG_FASTBOOT_FLASH
 
@@ -36,10 +38,12 @@
 #define CONFIG_ANDROID_RECOVERY_PARTITION_MMC 2
 #define CONFIG_ANDROID_CACHE_PARTITION_MMC 6
 #define CONFIG_ANDROID_DATA_PARTITION_MMC 4
+#define CONFIG_ANDROID_MISC_PARTITION_MMC 8
 
 #define CONFIG_CMD_BOOTA
 #define CONFIG_SUPPORT_RAW_INITRD
 #define CONFIG_SERIAL_TAG
+#define CONFIG_RESET_CAUSE
 
 #undef CONFIG_EXTRA_ENV_SETTINGS
 #undef CONFIG_BOOTCOMMAND
@@ -51,7 +55,10 @@
 
 
 #define CONFIG_USB_FASTBOOT_BUF_ADDR   CONFIG_SYS_LOAD_ADDR
+#ifdef CONFIG_FASTBOOT_STORAGE_NAND
+#define CONFIG_USB_FASTBOOT_BUF_SIZE   0x32000000
+#else
 #define CONFIG_USB_FASTBOOT_BUF_SIZE   0x19000000
-
+#endif
 
 #endif
diff --git a/include/fsl_caam.h b/include/fsl_caam.h
new file mode 100644
index 0000000..d282a33
--- /dev/null
+++ b/include/fsl_caam.h
@@ -0,0 +1,74 @@
+/*
+ * Copyright (c) 2012-2016, Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * o Redistributions of source code must retain the above copyright notice, this list
+ *   of conditions and the following disclaimer.
+ *
+ * o Redistributions in binary form must reproduce the above copyright notice, this
+ *   list of conditions and the following disclaimer in the documentation and/or
+ *   other materials provided with the distribution.
+ *
+ * o Neither the name of Freescale Semiconductor, Inc. nor the names of its
+ *   contributors may be used to endorse or promote products derived from this
+ *   software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
+ * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef __CAAM_H__
+#define	__CAAM_H__
+
+//! @name Error codes
+//@{
+#if !defined(SUCCESS)
+#define SUCCESS (0)
+#endif
+
+#define ERROR_IN_PAGE_ALLOC (1)
+
+
+////////////////////////////////////////////////////////////////////////////////
+//! @brief Enable and initialize the CAAM driver.
+//!
+//! This function enables the clock to the CAAM. It initializes the RNG, and
+//! instantiate it to allow generation of key for blob.
+//!
+////////////////////////////////////////////////////////////////////////////////
+void caam_open(void);
+
+////////////////////////////////////////////////////////////////////////////////
+//! @brief Generate a blob of a secure key.
+//!
+//! @param[in] plain_data_addr  Location address of the plain text data.
+//! @param[in] blob_addr  Location address of the blob.
+//! @param[in] size  	Size in bytes of the data to encrypt.
+//!
+//! @return SUCCESS
+//! @return ERROR_XXX 
+////////////////////////////////////////////////////////////////////////////////
+uint32_t caam_gen_blob(uint32_t plain_data_addr, uint32_t blob_addr, uint32_t size);
+
+////////////////////////////////////////////////////////////////////////////////
+//! @brief Decapsulate a blob of a secure key.
+//!
+//! @param[in] blob_addr  Location address of the blob.
+//!
+//! @return SUCCESS
+//! @return ERROR_XXX
+////////////////////////////////////////////////////////////////////////////////
+uint32_t caam_decap_blob(uint32_t plain_text, uint32_t blob_addr, uint32_t size);
+
+#endif /* __CAAM_H__ */
diff --git a/include/fsl_fastboot.h b/include/fsl_fastboot.h
index 5a38d99..75b166b 100644
--- a/include/fsl_fastboot.h
+++ b/include/fsl_fastboot.h
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2010-2015 Freescale Semiconductor, Inc.
+ * Copyright (C) 2010-2016 Freescale Semiconductor, Inc.
  *
  * SPDX-License-Identifier:	GPL-2.0+
  */
@@ -7,6 +7,7 @@
 #ifndef FSL_FASTBOOT_H
 #define FSL_FASTBOOT_H
 
+#include <common.h>
 #define FASTBOOT_PTENTRY_FLAGS_REPEAT(n)              (n & 0x0f)
 #define FASTBOOT_PTENTRY_FLAGS_REPEAT_MASK            0x0000000F
 
@@ -33,12 +34,39 @@
 #define FASTBOOT_MMC_USER_PARTITION_ID  0
 #define FASTBOOT_MMC_NONE_PARTITION_ID -1
 
+#ifdef CONFIG_BRILLO_SUPPORT
+#define FASTBOOT_PARTITION_BOOT_A "boot_a"
+#define FASTBOOT_PARTITION_RECOVERY "recovery"
+#define FASTBOOT_PARTITION_SYSTEM_A "system_a"
+#define FASTBOOT_PARTITION_BOOTLOADER "bootloader"
+#define FASTBOOT_PARTITION_DATA "data"
+#define FASTBOOT_PARTITION_BOOT_B "boot_b"
+#define FASTBOOT_PARTITION_SYSTEM_B "system_b"
+#define FASTBOOT_PARTITION_MISC "misc"
+
+#define FASTBOOT_PARTITION_BOOT_FS		"emmc"
+#define FASTBOOT_PARTITION_RECOVERY_FS		"emmc"
+#define FASTBOOT_PARTITION_SYSTEM_FS		"ext4"
+#define FASTBOOT_PARTITION_BOOTLOADER_FS 	"emmc"
+#define FASTBOOT_PARTITION_DATA_FS 		"ext4"
+#define FASTBOOT_PARTITION_MISC_FS 		"emmc"
+
+#else
 #define FASTBOOT_PARTITION_BOOT "boot"
 #define FASTBOOT_PARTITION_RECOVERY "recovery"
 #define FASTBOOT_PARTITION_SYSTEM "system"
 #define FASTBOOT_PARTITION_BOOTLOADER "bootloader"
 #define FASTBOOT_PARTITION_DATA "data"
 
+#define FASTBOOT_PARTITION_BOOT_FS		"emmc"
+#define FASTBOOT_PARTITION_RECOVERY_FS		"emmc"
+#define FASTBOOT_PARTITION_SYSTEM_FS		"ext4"
+#define FASTBOOT_PARTITION_BOOTLOADER_FS 	"emmc"
+#define FASTBOOT_PARTITION_DATA_FS 		"ext4"
+#define FASTBOOT_PARTITION_MISC_FS 		"emmc"
+
+#endif
+
 enum {
     DEV_SATA,
     DEV_MMC,
@@ -120,6 +148,8 @@ struct fastboot_ptentry {
 	unsigned int partition_id;
 	/* partition number in block device */
 	unsigned int partition_index;
+	/* partition file system type in string */
+	char fstype[16];
 };
 
 struct fastboot_device_info {
@@ -146,10 +176,10 @@ void fastboot_flash_dump_ptn(void);
 
 
 /* Check the board special boot mode reboot to fastboot mode. */
-int fastboot_check_and_clean_flag(void);
+bool fastboot_check_and_clean_command(void);
 
 /* Set the flag which reboot to fastboot mode*/
-void fastboot_enable_flag(void);
+void fastboot_enable_command(void);
 
 /*check if fastboot mode is requested by user*/
 void check_fastboot(void);
@@ -169,4 +199,6 @@ void save_parts_values(struct fastboot_ptentry *ptn,
 int check_parts_values(struct fastboot_ptentry *ptn);
 #endif /*CONFIG_FASTBOOT_STORAGE_NAND*/
 
+int fastboot_tx_write_str(const char *buffer);
+
 #endif /* FSL_FASTBOOT_H */
diff --git a/include/mmc.h b/include/mmc.h
index 2ad0f19..7f717c4 100644
--- a/include/mmc.h
+++ b/include/mmc.h
@@ -123,7 +123,12 @@
 #define OCR_VOLTAGE_MASK	0x007FFF80
 #define OCR_ACCESS_MODE		0x60000000
 
-#define SECURE_ERASE		0x80000000
+#define MMC_ERASE_ARG		0x00000000
+#define MMC_SECURE_ERASE_ARG	0x80000000
+#define MMC_TRIM_ARG		0x00000001
+#define MMC_DISCARD_ARG		0x00000003
+#define MMC_SECURE_TRIM1_ARG	0x80000001
+#define MMC_SECURE_TRIM2_ARG	0x80008000
 
 #define MMC_STATUS_MASK		(~0x0206BF7F)
 #define MMC_STATUS_SWITCH_ERROR	(1 << 7)
diff --git a/include/recovery.h b/include/recovery.h
index 1e0492a..e1636bf 100644
--- a/include/recovery.h
+++ b/include/recovery.h
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2010-2014 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright (C) 2010-2016 Freescale Semiconductor, Inc. All Rights Reserved.
  *
  * SPDX-License-Identifier:	GPL-2.0+
  */
@@ -13,8 +13,10 @@ struct reco_envs {
 };
 
 void check_recovery_mode(void);
-int recovery_check_and_clean_flag(void);
+bool recovery_check_and_clean_command(void);
 int check_recovery_cmd_file(void);
 void board_recovery_setup(void);
+int read_boot_reason(void);
+void clear_boot_reason(void);
 
 #endif
-- 
1.9.1

